{"ast":null,"code":"/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\nvar chai = require('../../chai');\n\nvar transferFlags = require('./transferFlags');\n/**\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Overwrites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.lengthOf(3);\n *     expect(myFoo).to.have.lengthOf.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @namespace Utils\n * @name overwriteChainableMethod\n * @api public\n */\n\n\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};","map":{"version":3,"names":["chai","require","transferFlags","module","exports","overwriteChainableMethod","ctx","name","method","chainingBehavior","chainableBehavior","__methods","_chainingBehavior","overwritingChainableMethodGetter","result","call","undefined","newAssertion","Assertion","_method","overwritingChainableMethodWrapper","apply","arguments"],"sources":["F:/Games/slotmachinereact/node_modules/chai/lib/chai/utils/overwriteChainableMethod.js"],"sourcesContent":["/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = require('../../chai');\nvar transferFlags = require('./transferFlags');\n\n/**\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Overwrites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.lengthOf(3);\n *     expect(myFoo).to.have.lengthOf.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @namespace Utils\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,YAAD,CAAlB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,wBAAT,CAAkCC,GAAlC,EAAuCC,IAAvC,EAA6CC,MAA7C,EAAqDC,gBAArD,EAAuE;EACtF,IAAIC,iBAAiB,GAAGJ,GAAG,CAACK,SAAJ,CAAcJ,IAAd,CAAxB;EAEA,IAAIK,iBAAiB,GAAGF,iBAAiB,CAACD,gBAA1C;;EACAC,iBAAiB,CAACD,gBAAlB,GAAqC,SAASI,gCAAT,GAA4C;IAC/E,IAAIC,MAAM,GAAGL,gBAAgB,CAACG,iBAAD,CAAhB,CAAoCG,IAApC,CAAyC,IAAzC,CAAb;;IACA,IAAID,MAAM,KAAKE,SAAf,EAA0B;MACxB,OAAOF,MAAP;IACD;;IAED,IAAIG,YAAY,GAAG,IAAIjB,IAAI,CAACkB,SAAT,EAAnB;IACAhB,aAAa,CAAC,IAAD,EAAOe,YAAP,CAAb;IACA,OAAOA,YAAP;EACD,CATD;;EAWA,IAAIE,OAAO,GAAGT,iBAAiB,CAACF,MAAhC;;EACAE,iBAAiB,CAACF,MAAlB,GAA2B,SAASY,iCAAT,GAA6C;IACtE,IAAIN,MAAM,GAAGN,MAAM,CAACW,OAAD,CAAN,CAAgBE,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAb;;IACA,IAAIR,MAAM,KAAKE,SAAf,EAA0B;MACxB,OAAOF,MAAP;IACD;;IAED,IAAIG,YAAY,GAAG,IAAIjB,IAAI,CAACkB,SAAT,EAAnB;IACAhB,aAAa,CAAC,IAAD,EAAOe,YAAP,CAAb;IACA,OAAOA,YAAP;EACD,CATD;AAUD,CA1BD"},"metadata":{},"sourceType":"script"}
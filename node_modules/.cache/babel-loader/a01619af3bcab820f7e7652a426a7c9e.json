{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n/**\n * Memory implements a simple memory model\n * for the ethereum virtual machine.\n */\n\n\nvar Memory =\n/** @class */\nfunction () {\n  function Memory() {\n    this._store = [];\n  }\n  /**\n   * Extends the memory given an offset and size. Rounds extended\n   * memory to word-size.\n   */\n\n\n  Memory.prototype.extend = function (offset, size) {\n    if (size === 0) {\n      return;\n    }\n\n    var newSize = ceil(offset + size, 32);\n    var sizeDiff = newSize - this._store.length;\n\n    if (sizeDiff > 0) {\n      this._store = this._store.concat(new Array(sizeDiff).fill(0));\n    }\n  };\n  /**\n   * Writes a byte array with length `size` to memory, starting from `offset`.\n   * @param offset - Starting position\n   * @param size - How many bytes to write\n   * @param value - Value\n   */\n\n\n  Memory.prototype.write = function (offset, size, value) {\n    if (size === 0) {\n      return;\n    }\n\n    assert(value.length === size, 'Invalid value size');\n    assert(offset + size <= this._store.length, 'Value exceeds memory capacity');\n    assert(Buffer.isBuffer(value), 'Invalid value type');\n\n    for (var i = 0; i < size; i++) {\n      this._store[offset + i] = value[i];\n    }\n  };\n  /**\n   * Reads a slice of memory from `offset` till `offset + size` as a `Buffer`.\n   * It fills up the difference between memory's length and `offset + size` with zeros.\n   * @param offset - Starting position\n   * @param size - How many bytes to read\n   */\n\n\n  Memory.prototype.read = function (offset, size) {\n    var loaded = this._store.slice(offset, offset + size); // Fill the remaining length with zeros\n\n\n    for (var i = loaded.length; i < size; i++) {\n      loaded[i] = 0;\n    }\n\n    return Buffer.from(loaded);\n  };\n\n  return Memory;\n}();\n\nexports.default = Memory;\n\nvar ceil = function (value, ceiling) {\n  var r = value % ceiling;\n\n  if (r === 0) {\n    return value;\n  } else {\n    return value + ceiling - r;\n  }\n};","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;;;;;;AAIA;AAAA;AAAA;EAGE;IACE,KAAKA,MAAL,GAAc,EAAd;EACD;EAED;;;;;;EAIAC,oCAAOC,MAAP,EAAuBC,IAAvB,EAAmC;IACjC,IAAIA,IAAI,KAAK,CAAb,EAAgB;MACd;IACD;;IAED,IAAMC,OAAO,GAAGC,IAAI,CAACH,MAAM,GAAGC,IAAV,EAAgB,EAAhB,CAApB;IACA,IAAMG,QAAQ,GAAGF,OAAO,GAAG,KAAKJ,MAAL,CAAYO,MAAvC;;IACA,IAAID,QAAQ,GAAG,CAAf,EAAkB;MAChB,KAAKN,MAAL,GAAc,KAAKA,MAAL,CAAYQ,MAAZ,CAAmB,IAAIC,KAAJ,CAAUH,QAAV,EAAoBI,IAApB,CAAyB,CAAzB,CAAnB,CAAd;IACD;EACF,CAVD;EAYA;;;;;;;;EAMAT,mCAAMC,MAAN,EAAsBC,IAAtB,EAAoCQ,KAApC,EAAiD;IAC/C,IAAIR,IAAI,KAAK,CAAb,EAAgB;MACd;IACD;;IAEDS,MAAM,CAACD,KAAK,CAACJ,MAAN,KAAiBJ,IAAlB,EAAwB,oBAAxB,CAAN;IACAS,MAAM,CAACV,MAAM,GAAGC,IAAT,IAAiB,KAAKH,MAAL,CAAYO,MAA9B,EAAsC,+BAAtC,CAAN;IACAK,MAAM,CAACC,MAAM,CAACC,QAAP,CAAgBH,KAAhB,CAAD,EAAyB,oBAAzB,CAAN;;IAEA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,IAApB,EAA0BY,CAAC,EAA3B,EAA+B;MAC7B,KAAKf,MAAL,CAAYE,MAAM,GAAGa,CAArB,IAA0BJ,KAAK,CAACI,CAAD,CAA/B;IACD;EACF,CAZD;EAcA;;;;;;;;EAMAd,kCAAKC,MAAL,EAAqBC,IAArB,EAAiC;IAC/B,IAAMa,MAAM,GAAG,KAAKhB,MAAL,CAAYiB,KAAZ,CAAkBf,MAAlB,EAA0BA,MAAM,GAAGC,IAAnC,CAAf,CAD+B,CAE/B;;;IACA,KAAK,IAAIY,CAAC,GAAGC,MAAM,CAACT,MAApB,EAA4BQ,CAAC,GAAGZ,IAAhC,EAAsCY,CAAC,EAAvC,EAA2C;MACzCC,MAAM,CAACD,CAAD,CAAN,GAAY,CAAZ;IACD;;IACD,OAAOF,MAAM,CAACK,IAAP,CAAYF,MAAZ,CAAP;EACD,CAPD;;EAQF;AAAC,CAzDD;;;;AA2DA,IAAMX,IAAI,GAAG,UAACM,KAAD,EAAgBQ,OAAhB,EAA+B;EAC1C,IAAMC,CAAC,GAAGT,KAAK,GAAGQ,OAAlB;;EACA,IAAIC,CAAC,KAAK,CAAV,EAAa;IACX,OAAOT,KAAP;EACD,CAFD,MAEO;IACL,OAAOA,KAAK,GAAGQ,OAAR,GAAkBC,CAAzB;EACD;AACF,CAPD","names":["_store","Memory","offset","size","newSize","ceil","sizeDiff","length","concat","Array","fill","value","assert","Buffer","isBuffer","i","loaded","slice","from","ceiling","r"],"sources":["../../lib/evm/memory.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nfunction findImports(data) {\n  const result = []; // regex below matches all possible import statements, namely:\n  // - import \"somefile\";\n  // - import \"somefile\" as something;\n  // - import something from \"somefile\"\n  // (double that for single quotes)\n  // and captures file names\n\n  const regex = /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n  let match; // tslint:disable-next-line:no-conditional-assignment\n\n  while (match = regex.exec(data.source)) {\n    for (let i = 1; i < match.length; i++) {\n      if (match[i] !== undefined) {\n        result.push(match[i]);\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.findImports = findImports;\n/**\n * This function accepts root files to be searched for and resolves the sources, finds the imports in each source and traverses the whole dependency tree gathering absolute and uri paths\n * @param roots\n * @param workingDir\n * @param resolver\n */\n\nfunction gatherDepenencyTree(roots, workingDir, resolver) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const result = [];\n    const alreadyImported = new Set();\n    /**\n     * This function traverses the depedency tree and calculates absolute paths for each import on the way storing each file in in a global array\n     * @param file File in a depedency that should now be traversed\n     * @returns An absolute path for the requested file\n     */\n\n    function dfs(file) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const url = yield resolver.resolve(file.uri, file.searchCwd);\n\n        if (alreadyImported.has(url)) {\n          return url;\n        }\n\n        const resolvedFile = yield resolver.require(file.uri, file.searchCwd);\n        alreadyImported.add(url);\n        const foundImportURIs = findImports(resolvedFile);\n        const fileNode = Object.assign({\n          uri: file.uri,\n          imports: []\n        }, resolvedFile);\n        const resolvedCwd = path_1.default.dirname(url);\n\n        for (const importUri of foundImportURIs) {\n          const importUrl = yield dfs({\n            searchCwd: resolvedCwd,\n            uri: importUri\n          });\n          fileNode.imports.push({\n            uri: importUri,\n            url: importUrl\n          });\n        }\n\n        result.push(fileNode);\n        return resolvedFile.url;\n      });\n    }\n\n    yield Promise.all(roots.map(what => dfs({\n      searchCwd: workingDir,\n      uri: what\n    })));\n    return result;\n  });\n}\n\nfunction stripNodes(nodes) {\n  return nodes.map(node => {\n    return {\n      url: node.url,\n      source: node.source,\n      provider: node.provider\n    };\n  });\n}\n/**\n * Starts with roots and traverses the whole depedency tree of imports, returning an array of sources\n * @param roots\n * @param workingDir What's the starting working dir for resolving relative imports in roots\n * @param resolver\n */\n\n\nfunction gatherSources(roots, workingDir, resolver) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const result = [];\n    const queue = [];\n    const alreadyImported = new Set();\n\n    if (workingDir !== \"\") {\n      workingDir += \"/\";\n    }\n\n    const absoluteRoots = roots.map(what => url_1.default.resolve(workingDir, what));\n\n    for (const absWhat of absoluteRoots) {\n      queue.push({\n        cwd: workingDir,\n        file: absWhat,\n        relativeTo: workingDir\n      });\n      alreadyImported.add(absWhat);\n    }\n\n    while (queue.length > 0) {\n      const fileData = queue.shift();\n      const resolvedFile = yield resolver.require(fileData.file, fileData.cwd);\n      const foundImports = findImports(resolvedFile); // if imported path starts with '.' we assume it's relative and return it's\n      // path relative to resolved name of the file that imported it\n      // if not - return the same name it was imported with\n\n      let relativePath;\n\n      if (fileData.file[0] === \".\") {\n        relativePath = url_1.default.resolve(fileData.relativeTo, fileData.file);\n        result.push({\n          url: relativePath,\n          source: resolvedFile.source,\n          provider: resolvedFile.provider\n        });\n      } else {\n        relativePath = fileData.file;\n        result.push({\n          url: relativePath,\n          source: resolvedFile.source,\n          provider: resolvedFile.provider\n        });\n      }\n\n      const fileParentDir = path_1.default.dirname(resolvedFile.url);\n\n      for (const foundImport of foundImports) {\n        let importName;\n\n        if (foundImport[0] === \".\") {\n          importName = url_1.default.resolve(relativePath, foundImport);\n        } else {\n          importName = foundImport;\n        }\n\n        if (!alreadyImported.has(importName)) {\n          alreadyImported.add(importName);\n          queue.push({\n            cwd: fileParentDir,\n            file: foundImport,\n            relativeTo: relativePath\n          });\n        }\n      }\n    }\n\n    return result;\n  });\n}\n\nexports.gatherSources = gatherSources;\n/**\n * This function gathers sources and **REWRITES IMPORTS** inside the source files into resolved, absolute paths instead of using shortcut forms\n * Because the remapping api in solc is not compatible with multiple existing projects and frameworks, changing relative paths to absolute paths\n * makes us avoid any need for finding imports after starting the solc compilation\n * @param roots\n * @param workingDir What's the starting working dir for resolving relative imports in roots\n * @param resolver\n */\n\nfunction gatherSourcesAndCanonizeImports(roots, workingDir, resolver) {\n  return __awaiter(this, void 0, void 0, function* () {\n    function canonizeFile(file) {\n      file.imports.forEach(i => file.source = file.source.replace(i.uri, i.url));\n    }\n\n    const sources = yield gatherDepenencyTree(roots, workingDir, resolver);\n    sources.forEach(canonizeFile);\n    return stripNodes(sources);\n  });\n}\n\nexports.gatherSourcesAndCanonizeImports = gatherSourcesAndCanonizeImports;","map":{"version":3,"mappings":"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","names":["findImports","data","result","regex","match","exec","source","i","length","undefined","push","exports","gatherDepenencyTree","roots","workingDir","resolver","alreadyImported","Set","dfs","file","url","resolve","uri","searchCwd","has","resolvedFile","require","add","foundImportURIs","fileNode","imports","resolvedCwd","path_1","dirname","importUri","importUrl","Promise","all","map","what","stripNodes","nodes","node","provider","gatherSources","queue","absoluteRoots","url_1","absWhat","cwd","relativeTo","fileData","shift","foundImports","relativePath","fileParentDir","foundImport","importName","gatherSourcesAndCanonizeImports","canonizeFile","forEach","replace","sources"],"sources":["F:\\Games\\slotmachinereact\\node_modules\\@resolver-engine\\imports\\src\\utils.ts"],"sourcesContent":["import { ResolverEngine } from \"@resolver-engine/core\";\nimport pathSys from \"path\";\nimport urlSys from \"url\";\nimport { ImportFile } from \"./parsers/importparser\";\n\nexport function findImports(data: ImportFile): string[] {\n  const result: string[] = [];\n  // regex below matches all possible import statements, namely:\n  // - import \"somefile\";\n  // - import \"somefile\" as something;\n  // - import something from \"somefile\"\n  // (double that for single quotes)\n  // and captures file names\n  const regex: RegExp = /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n  let match: RegExpExecArray | null;\n  // tslint:disable-next-line:no-conditional-assignment\n  while ((match = regex.exec(data.source))) {\n    for (let i = 1; i < match.length; i++) {\n      if (match[i] !== undefined) {\n        result.push(match[i]);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\ninterface ImportTreeNode extends ImportFile {\n  uri: string;\n  // uri and url the same as in rest of resolver-engine\n  // it might mean github:user/repo/path.sol and raw link\n  // or it might mean relative vs absolute file path\n  imports: Array<{ uri: string; url: string }>;\n}\n\n/**\n * This function accepts root files to be searched for and resolves the sources, finds the imports in each source and traverses the whole dependency tree gathering absolute and uri paths\n * @param roots\n * @param workingDir\n * @param resolver\n */\nasync function gatherDepenencyTree(\n  roots: string[],\n  workingDir: string,\n  resolver: ResolverEngine<ImportFile>,\n): Promise<ImportTreeNode[]> {\n  const result: ImportTreeNode[] = [];\n  const alreadyImported = new Set();\n\n  /**\n   * This function traverses the depedency tree and calculates absolute paths for each import on the way storing each file in in a global array\n   * @param file File in a depedency that should now be traversed\n   * @returns An absolute path for the requested file\n   */\n  async function dfs(file: { searchCwd: string; uri: string }): Promise<string> {\n    const url = await resolver.resolve(file.uri, file.searchCwd);\n    if (alreadyImported.has(url)) {\n      return url;\n    }\n\n    const resolvedFile = await resolver.require(file.uri, file.searchCwd);\n\n    alreadyImported.add(url);\n\n    const foundImportURIs = findImports(resolvedFile);\n\n    const fileNode: ImportTreeNode = { uri: file.uri, imports: [], ...resolvedFile };\n\n    const resolvedCwd = pathSys.dirname(url);\n    for (const importUri of foundImportURIs) {\n      const importUrl = await dfs({ searchCwd: resolvedCwd, uri: importUri });\n      fileNode.imports.push({ uri: importUri, url: importUrl });\n    }\n\n    result.push(fileNode);\n    return resolvedFile.url;\n  }\n\n  await Promise.all(roots.map(what => dfs({ searchCwd: workingDir, uri: what })));\n\n  return result;\n}\n\nfunction stripNodes(nodes: ImportTreeNode[]): ImportFile[] {\n  return nodes.map(node => {\n    return { url: node.url, source: node.source, provider: node.provider };\n  });\n}\n\n/**\n * Starts with roots and traverses the whole depedency tree of imports, returning an array of sources\n * @param roots\n * @param workingDir What's the starting working dir for resolving relative imports in roots\n * @param resolver\n */\nexport async function gatherSources(\n  roots: string[],\n  workingDir: string,\n  resolver: ResolverEngine<ImportFile>,\n): Promise<ImportFile[]> {\n  const result: ImportFile[] = [];\n  const queue: Array<{ cwd: string; file: string; relativeTo: string }> = [];\n  const alreadyImported = new Set();\n\n  if (workingDir !== \"\") {\n    workingDir += \"/\";\n  }\n  const absoluteRoots = roots.map(what => urlSys.resolve(workingDir, what));\n  for (const absWhat of absoluteRoots) {\n    queue.push({ cwd: workingDir, file: absWhat, relativeTo: workingDir });\n    alreadyImported.add(absWhat);\n  }\n  while (queue.length > 0) {\n    const fileData = queue.shift()!;\n    const resolvedFile: ImportFile = await resolver.require(fileData.file, fileData.cwd);\n    const foundImports = findImports(resolvedFile);\n\n    // if imported path starts with '.' we assume it's relative and return it's\n    // path relative to resolved name of the file that imported it\n    // if not - return the same name it was imported with\n    let relativePath: string;\n    if (fileData.file[0] === \".\") {\n      relativePath = urlSys.resolve(fileData.relativeTo, fileData.file);\n      result.push({ url: relativePath, source: resolvedFile.source, provider: resolvedFile.provider });\n    } else {\n      relativePath = fileData.file;\n      result.push({ url: relativePath, source: resolvedFile.source, provider: resolvedFile.provider });\n    }\n\n    const fileParentDir = pathSys.dirname(resolvedFile.url);\n    for (const foundImport of foundImports) {\n      let importName: string;\n      if (foundImport[0] === \".\") {\n        importName = urlSys.resolve(relativePath, foundImport);\n      } else {\n        importName = foundImport;\n      }\n      if (!alreadyImported.has(importName)) {\n        alreadyImported.add(importName);\n        queue.push({ cwd: fileParentDir, file: foundImport, relativeTo: relativePath });\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * This function gathers sources and **REWRITES IMPORTS** inside the source files into resolved, absolute paths instead of using shortcut forms\n * Because the remapping api in solc is not compatible with multiple existing projects and frameworks, changing relative paths to absolute paths\n * makes us avoid any need for finding imports after starting the solc compilation\n * @param roots\n * @param workingDir What's the starting working dir for resolving relative imports in roots\n * @param resolver\n */\nexport async function gatherSourcesAndCanonizeImports(\n  roots: string[],\n  workingDir: string,\n  resolver: ResolverEngine<ImportFile>,\n): Promise<ImportFile[]> {\n  function canonizeFile(file: ImportTreeNode) {\n    file.imports.forEach(i => (file.source = file.source.replace(i.uri, i.url)));\n  }\n\n  const sources = await gatherDepenencyTree(roots, workingDir, resolver);\n  sources.forEach(canonizeFile);\n  return stripNodes(sources);\n}\n"]},"metadata":{},"sourceType":"script"}
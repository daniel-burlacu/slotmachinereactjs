{"ast":null,"code":"const Sublevel = require(\"level-sublevel\");\n\nconst MerklePatriciaTree = require(\"merkle-patricia-tree\");\n\nconst BaseTrie = require(\"merkle-patricia-tree/baseTrie\");\n\nconst checkpointInterface = require(\"merkle-patricia-tree/checkpoint-interface\");\n\nvar utils = require(\"ethereumjs-util\");\n\nvar inherits = require(\"util\").inherits;\n\nvar Web3 = require(\"web3\");\n\nvar to = require(\"../utils/to.js\");\n\ninherits(ForkedStorageBaseTrie, BaseTrie);\n\nfunction ForkedStorageBaseTrie(db, root, options) {\n  BaseTrie.call(this, db, root);\n  this._touched = Sublevel(this.db).sublevel(\"touched\");\n  this.options = options;\n  this.address = options.address;\n  this.forkBlockNumber = options.forkBlockNumber;\n  this.blockchain = options.blockchain;\n  this.fork = options.fork;\n  this.web3 = new Web3(this.fork);\n  this.persist = typeof options.persist === \"undefined\" ? true : options.persist;\n} // Note: This overrides a standard method whereas the other methods do not.\n\n\nForkedStorageBaseTrie.prototype.get = function (key, callback) {\n  var self = this;\n  key = utils.toBuffer(key);\n  self.keyExists(key, function (err, keyExists) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.getTouchedAt(key, function (err, touchedAt) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (keyExists && typeof touchedAt !== \"undefined\") {\n        MerklePatriciaTree.prototype.get.call(self, key, function (err, r) {\n          callback(err, r);\n        });\n      } else {\n        // If this is the main trie, get the whole account.\n        if (self.address == null) {\n          self.blockchain.fetchAccountFromFallback(key, self.forkBlockNumber, function (err, account) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, account.serialize());\n          });\n        } else {\n          self.web3.eth.getStorageAt(to.rpcDataHexString(self.address), to.rpcDataHexString(key), self.forkBlockNumber, function (err, value) {\n            if (err) {\n              return callback(err);\n            }\n\n            value = to.rpcQuantityBuffer(value);\n            callback(null, value);\n          });\n        }\n      }\n    });\n  });\n};\n\nForkedStorageBaseTrie.prototype.keyExists = function (key, callback) {\n  key = utils.toBuffer(key);\n  this.findPath(key, (err, node, remainder, stack) => {\n    const exists = node && remainder.length === 0;\n    callback(err, exists);\n  });\n};\n\nForkedStorageBaseTrie.prototype.touch = function (key, callback) {\n  if (!this.persist) {\n    return callback();\n  }\n\n  const self = this;\n  let rpcKey = to.rpcDataHexString(key);\n\n  if (this.address) {\n    rpcKey = `${to.rpcDataHexString(this.address)};${rpcKey}`;\n  }\n\n  rpcKey = rpcKey.toLowerCase();\n\n  this._touched.get(rpcKey, (err, result) => {\n    if (err && err.type !== \"NotFoundError\") {\n      return callback(err);\n    }\n\n    if (typeof result === \"undefined\") {\n      // key doesn't exist\n      this.blockchain.data.blocks.last((err, lastBlock) => {\n        if (err) {\n          return callback(err);\n        }\n\n        const number = lastBlock === null ? self.forkBlockNumber : to.number(lastBlock.header.number);\n\n        this._touched.put(rpcKey, number + 1);\n\n        this.blockchain._touchedKeys.push(rpcKey);\n\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n};\n\nconst originalPut = ForkedStorageBaseTrie.prototype.put;\n\nForkedStorageBaseTrie.prototype.put = function (key, value, callback) {\n  const self = this;\n  this.touch(key, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    originalPut.call(self, key, value, callback);\n  });\n};\n\nForkedStorageBaseTrie.prototype.getTouchedAt = function (key, callback) {\n  let rpcKey = to.rpcDataHexString(key);\n\n  if (this.address) {\n    rpcKey = `${to.rpcDataHexString(this.address)};${rpcKey}`;\n  }\n\n  rpcKey = rpcKey.toLowerCase();\n\n  this._touched.get(rpcKey, function (err, result) {\n    if (err && err.type !== \"NotFoundError\") {\n      return callback(err);\n    }\n\n    callback(null, result);\n  });\n};\n\nForkedStorageBaseTrie.prototype.del = function (key, callback) {\n  this.put(key, 0, callback);\n};\n\nForkedStorageBaseTrie.prototype.copy = function () {\n  return new ForkedStorageBaseTrie(this.db, this.root, this.options);\n};\n\ninherits(ForkedStorageTrie, ForkedStorageBaseTrie);\n\nfunction ForkedStorageTrie(db, root, options) {\n  ForkedStorageBaseTrie.call(this, db, root, options);\n  checkpointInterface.call(this, this);\n}\n\nForkedStorageTrie.prove = MerklePatriciaTree.prove;\nForkedStorageTrie.verifyProof = MerklePatriciaTree.verifyProof;\nmodule.exports = ForkedStorageTrie;","map":{"version":3,"names":["Sublevel","require","MerklePatriciaTree","BaseTrie","checkpointInterface","utils","inherits","Web3","to","ForkedStorageBaseTrie","db","root","options","call","_touched","sublevel","address","forkBlockNumber","blockchain","fork","web3","persist","prototype","get","key","callback","self","toBuffer","keyExists","err","getTouchedAt","touchedAt","r","fetchAccountFromFallback","account","serialize","eth","getStorageAt","rpcDataHexString","value","rpcQuantityBuffer","findPath","node","remainder","stack","exists","length","touch","rpcKey","toLowerCase","result","type","data","blocks","last","lastBlock","number","header","put","_touchedKeys","push","originalPut","del","copy","ForkedStorageTrie","prove","verifyProof","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/forking/forked_storage_trie.js"],"sourcesContent":["const Sublevel = require(\"level-sublevel\");\nconst MerklePatriciaTree = require(\"merkle-patricia-tree\");\nconst BaseTrie = require(\"merkle-patricia-tree/baseTrie\");\nconst checkpointInterface = require(\"merkle-patricia-tree/checkpoint-interface\");\nvar utils = require(\"ethereumjs-util\");\nvar inherits = require(\"util\").inherits;\nvar Web3 = require(\"web3\");\nvar to = require(\"../utils/to.js\");\n\ninherits(ForkedStorageBaseTrie, BaseTrie);\n\nfunction ForkedStorageBaseTrie(db, root, options) {\n  BaseTrie.call(this, db, root);\n  this._touched = Sublevel(this.db).sublevel(\"touched\");\n\n  this.options = options;\n  this.address = options.address;\n  this.forkBlockNumber = options.forkBlockNumber;\n  this.blockchain = options.blockchain;\n  this.fork = options.fork;\n  this.web3 = new Web3(this.fork);\n  this.persist = typeof options.persist === \"undefined\" ? true : options.persist;\n}\n\n// Note: This overrides a standard method whereas the other methods do not.\nForkedStorageBaseTrie.prototype.get = function(key, callback) {\n  var self = this;\n\n  key = utils.toBuffer(key);\n\n  self.keyExists(key, function(err, keyExists) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.getTouchedAt(key, function(err, touchedAt) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (keyExists && typeof touchedAt !== \"undefined\") {\n        MerklePatriciaTree.prototype.get.call(self, key, function(err, r) {\n          callback(err, r);\n        });\n      } else {\n        // If this is the main trie, get the whole account.\n        if (self.address == null) {\n          self.blockchain.fetchAccountFromFallback(key, self.forkBlockNumber, function(err, account) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, account.serialize());\n          });\n        } else {\n          self.web3.eth.getStorageAt(\n            to.rpcDataHexString(self.address),\n            to.rpcDataHexString(key),\n            self.forkBlockNumber,\n            function(err, value) {\n              if (err) {\n                return callback(err);\n              }\n\n              value = to.rpcQuantityBuffer(value);\n\n              callback(null, value);\n            }\n          );\n        }\n      }\n    });\n  });\n};\n\nForkedStorageBaseTrie.prototype.keyExists = function(key, callback) {\n  key = utils.toBuffer(key);\n  this.findPath(key, (err, node, remainder, stack) => {\n    const exists = node && remainder.length === 0;\n    callback(err, exists);\n  });\n};\n\nForkedStorageBaseTrie.prototype.touch = function(key, callback) {\n  if (!this.persist) {\n    return callback();\n  }\n\n  const self = this;\n  let rpcKey = to.rpcDataHexString(key);\n  if (this.address) {\n    rpcKey = `${to.rpcDataHexString(this.address)};${rpcKey}`;\n  }\n  rpcKey = rpcKey.toLowerCase();\n\n  this._touched.get(rpcKey, (err, result) => {\n    if (err && err.type !== \"NotFoundError\") {\n      return callback(err);\n    }\n\n    if (typeof result === \"undefined\") {\n      // key doesn't exist\n      this.blockchain.data.blocks.last((err, lastBlock) => {\n        if (err) {\n          return callback(err);\n        }\n\n        const number = lastBlock === null ? self.forkBlockNumber : to.number(lastBlock.header.number);\n        this._touched.put(rpcKey, number + 1);\n        this.blockchain._touchedKeys.push(rpcKey);\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n};\n\nconst originalPut = ForkedStorageBaseTrie.prototype.put;\nForkedStorageBaseTrie.prototype.put = function(key, value, callback) {\n  const self = this;\n  this.touch(key, function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    originalPut.call(self, key, value, callback);\n  });\n};\n\nForkedStorageBaseTrie.prototype.getTouchedAt = function(key, callback) {\n  let rpcKey = to.rpcDataHexString(key);\n  if (this.address) {\n    rpcKey = `${to.rpcDataHexString(this.address)};${rpcKey}`;\n  }\n  rpcKey = rpcKey.toLowerCase();\n\n  this._touched.get(rpcKey, function(err, result) {\n    if (err && err.type !== \"NotFoundError\") {\n      return callback(err);\n    }\n\n    callback(null, result);\n  });\n};\n\nForkedStorageBaseTrie.prototype.del = function(key, callback) {\n  this.put(key, 0, callback);\n};\n\nForkedStorageBaseTrie.prototype.copy = function() {\n  return new ForkedStorageBaseTrie(this.db, this.root, this.options);\n};\n\ninherits(ForkedStorageTrie, ForkedStorageBaseTrie);\n\nfunction ForkedStorageTrie(db, root, options) {\n  ForkedStorageBaseTrie.call(this, db, root, options);\n  checkpointInterface.call(this, this);\n}\n\nForkedStorageTrie.prove = MerklePatriciaTree.prove;\nForkedStorageTrie.verifyProof = MerklePatriciaTree.verifyProof;\n\nmodule.exports = ForkedStorageTrie;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
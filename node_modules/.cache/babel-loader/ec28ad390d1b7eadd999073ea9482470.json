{"ast":null,"code":"const EthereumJsTransaction = require(\"ethereumjs-tx\").Transaction;\n\nconst EthereumJsFakeTransaction = require(\"ethereumjs-tx\").FakeTransaction;\n\nconst Common = require(\"ethereumjs-common\").default;\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst assert = require(\"assert\");\n\nconst rlp = ethUtil.rlp;\n\nconst to = require(\"./to\");\n\nconst sign = EthereumJsTransaction.prototype.sign;\n\nconst fakeHash = function () {\n  // this isn't memoization of the hash. previous versions of ganache-core\n  // created hashes in a different/incorrect way and are recorded this way\n  // in snapshot dbs. We are preserving the chain's immutability by using the\n  // stored hash instead of calculating it.\n  if (this._hash != null) {\n    return this._hash;\n  }\n\n  return EthereumJsFakeTransaction.prototype.hash.apply(this, arguments);\n};\n\nconst BUFFER_ZERO = Buffer.from([0]);\n\nfunction configZeroableField(tx, fieldName) {\n  let fieldLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n\n  const index = tx._fields.indexOf(fieldName);\n\n  const descriptor = Object.getOwnPropertyDescriptor(tx, fieldName); // eslint-disable-next-line accessor-pairs\n\n  Object.defineProperty(tx, fieldName, {\n    set: v => {\n      descriptor.set.call(tx, v);\n      v = ethUtil.toBuffer(v);\n      assert(fieldLength >= v.length, `The field ${fieldName} must not have more ${fieldLength} bytes`);\n      tx._originals[index] = v;\n    },\n    get: () => {\n      return tx._originals[index];\n    }\n  });\n}\n/**\n * etheruemjs-tx's Transactions don't behave quite like we need them to, so\n * we're monkey-patching them to do what we want here.\n * @param {Transaction} tx The Transaction to fix\n * @param {Object} [data] The data object\n */\n\n\nfunction fixProps(tx, data) {\n  // ethereumjs-tx doesn't allow for a `0` value in fields, but we want it to\n  // in order to differentiate between a value that isn't set and a value\n  // that is set to 0 in a fake transaction.\n  // Once https://github.com/ethereumjs/ethereumjs-tx/issues/112 is figured\n  // out we can probably remove this fix/hack.\n  // We keep track of the original value and return that value when\n  // referenced by its property name. This lets us properly encode a `0` as\n  // an empty buffer while still being able to differentiate between a `0`\n  // and `null`/`undefined`.\n  tx._originals = [];\n  const fieldNames = [\"nonce\", \"gasPrice\", \"gasLimit\", \"value\"];\n  fieldNames.forEach(fieldName => configZeroableField(tx, fieldName, 32));\n\n  if (tx.isFake()) {\n    /**\n     * @prop {Buffer} from (read/write) Set from address to bypass transaction\n     * signing on fake transactions.\n     */\n    Object.defineProperty(tx, \"from\", {\n      enumerable: true,\n      configurable: true,\n      get: tx.getSenderAddress.bind(tx),\n      set: val => {\n        if (val) {\n          tx._from = ethUtil.toBuffer(val);\n        } else {\n          tx._from = null;\n        }\n      }\n    });\n\n    if (data && data.from) {\n      tx.from = data.from;\n    }\n\n    tx.hash = fakeHash;\n  }\n}\n/**\n * Parses the given data object and adds its properties to the given tx.\n * @param {Transaction} tx\n * @param {Object} [data]\n */\n\n\nfunction initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n\n    const self = tx;\n\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      } // make sure all the items are buffers\n\n\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n\n      tx._fields.forEach(function (field) {\n        if (keys.indexOf(field) !== -1) {\n          let val = data[field];\n\n          if (typeof val === \"string\" && !val.startsWith(\"0x\")) {\n            val = \"0x\" + val;\n          }\n\n          self[field] = val;\n        }\n\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self.gas = data.gas;\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self.input = data.input;\n          }\n        }\n      }); // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n\n\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}\n\nmodule.exports = class Transaction extends EthereumJsTransaction {\n  /**\n   * @param {Object} [data] The data for this Transaction.\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   * @param {Object} [common] EthereumJS common.fromCustomChain()\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n  constructor(data) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Transaction.types.none;\n    let common = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (data.chainId && !common) {\n      common = Common.forCustomChain(\"mainnet\", // TODO needs to match chain id\n      {\n        name: \"ganache\",\n        networkId: 1,\n        chainId: data.chainId,\n        comment: \"Local test network\",\n        bootstrapNodes: []\n      }, \"muirGlacier\");\n    }\n\n    super(undefined, {\n      common\n    });\n    this.ganacheTxCommon = common;\n    this.type = type;\n    fixProps(this, data);\n    initData(this, data);\n  }\n\n  static get types() {\n    // values must be powers of 2\n    return {\n      none: 0,\n      signed: 1,\n      fake: 2\n    };\n  }\n  /**\n   * Prepares arbitrary JSON data for use in a Transaction.\n   * @param {Object} json JSON object representing the Transaction\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   * @param {Object} [common] EthereumJS common.fromCustomChain()\n   * @param {Number} [networkId]\n   * @param {string} [hardfork]\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n\n\n  static fromJSON(json, type, common, networkId, hardfork) {\n    let toAccount;\n\n    if (json.to) {\n      // Remove all padding and make it easily comparible.\n      const buf = to.buffer(json.to);\n\n      if (buf.equals(Buffer.from([0]))) {\n        // if the address is 0x0 make it 0x0{20}\n        toAccount = ethUtil.setLengthLeft(buf, 20);\n      } else {\n        toAccount = buf;\n      }\n    }\n\n    const data = json.data || json.input;\n    const options = {\n      nonce: ethUtil.toBuffer(to.hex(json.nonce)),\n      from: ethUtil.toBuffer(to.hex(json.from)),\n      value: ethUtil.toBuffer(to.hex(json.value)),\n      gasLimit: ethUtil.toBuffer(to.hex(json.gas || json.gasLimit)),\n      gasPrice: ethUtil.toBuffer(to.hex(json.gasPrice)),\n      data: data ? to.buffer(data) : null,\n      to: toAccount,\n      v: ethUtil.toBuffer(json.v),\n      r: ethUtil.toBuffer(json.r),\n      s: ethUtil.toBuffer(json.s)\n    };\n\n    if (!common && options.v.length > 0) {\n      const chainId = Math.floor((json.v - 35) / 2);\n      common = Common.forCustomChain(\"mainnet\", // TODO needs to match chain id\n      {\n        name: \"ganache\",\n        networkId: networkId,\n        chainId: chainId >= 0 ? chainId : 1,\n        comment: \"Local test network\",\n        bootstrapNodes: []\n      }, hardfork);\n    }\n\n    const tx = new Transaction(options, type, common);\n    tx._hash = json.hash ? to.buffer(json.hash) : null;\n    return tx;\n  }\n  /**\n   * Encodes the Transaction in order to be used in a database. Can be decoded\n   * into an identical Transaction via `Transaction.decode(encodedTx)`.\n   */\n\n\n  encode() {\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(this.hash()),\n      nonce: to.nullableRpcQuantityHexString(this.nonce) || \"0x\",\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.nullableRpcQuantityHexString(this.value),\n      gas: to.nullableRpcQuantityHexString(this.gasLimit),\n      gasPrice: to.nullableRpcQuantityHexString(this.gasPrice),\n      data: this.data ? this.data.toString(\"hex\") : null,\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcQuantityHexString(this.r),\n      s: to.nullableRpcQuantityHexString(this.s),\n      _type: this.type,\n      _options: {\n        hardfork: this.ganacheTxCommon.hardfork(),\n        chainId: this.ganacheTxCommon.chainId(),\n        networkId: this.ganacheTxCommon.networkId()\n      }\n    };\n    return resultJSON;\n  }\n\n  isFake() {\n    return (this.type & Transaction.types.fake) === Transaction.types.fake;\n  }\n\n  isSigned() {\n    return (this.type & Transaction.types.signed) === Transaction.types.signed;\n  }\n  /**\n   * Compares the transaction's nonce value to the given expectedNonce taking in\n   * to account the type of transaction and comparison rules for each type.\n   *\n   * In a signed transaction a nonce of Buffer([]) is the same as Buffer([0]),\n   * but in a fake transaction Buffer([]) is null and Buffer([0]) is 0.\n   *\n   * @param {Buffer} expectedNonce The value of the from account's next nonce.\n   */\n\n\n  validateNonce(expectedNonce) {\n    let nonce;\n\n    if (this.isSigned() && this.nonce.length === 0) {\n      nonce = BUFFER_ZERO;\n    } else {\n      nonce = this.nonce;\n    }\n\n    return nonce.equals(expectedNonce);\n  }\n  /**\n   * Signs the transaction and sets the `type` bit for `signed` to 1,\n   * i.e., `isSigned() === true`\n   */\n\n\n  sign() {\n    sign.apply(this, arguments);\n    this.type |= Transaction.types.signed;\n  }\n  /**\n   * Returns a JSON-RPC spec compliant representation of this Transaction.\n   *\n   * @param {Object} block The block this Transaction appears in.\n   */\n\n\n  toJsonRpc(block) {\n    const hash = this.hash();\n    let transactionIndex = null;\n\n    for (let i = 0, txns = block.transactions, l = txns.length; i < l; i++) {\n      if (txns[i].hash().equals(hash)) {\n        transactionIndex = i;\n        break;\n      }\n    }\n\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(hash),\n      nonce: to.rpcQuantityHexString(this.nonce),\n      blockHash: to.nullableRpcDataHexString(block.hash()),\n      blockNumber: to.nullableRpcQuantityHexString(block.header.number),\n      transactionIndex: to.nullableRpcQuantityHexString(transactionIndex),\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.rpcQuantityHexString(this.value),\n      gas: to.rpcQuantityHexString(this.gasLimit),\n      gasPrice: to.rpcQuantityHexString(this.gasPrice),\n      input: to.rpcDataHexString(this.data),\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcQuantityHexString(this.r),\n      s: to.nullableRpcQuantityHexString(this.s)\n    };\n    return resultJSON;\n  }\n\n};","map":{"version":3,"names":["EthereumJsTransaction","require","Transaction","EthereumJsFakeTransaction","FakeTransaction","Common","default","ethUtil","assert","rlp","to","sign","prototype","fakeHash","_hash","hash","apply","arguments","BUFFER_ZERO","Buffer","from","configZeroableField","tx","fieldName","fieldLength","index","_fields","indexOf","descriptor","Object","getOwnPropertyDescriptor","defineProperty","set","v","call","toBuffer","length","_originals","get","fixProps","data","fieldNames","forEach","isFake","enumerable","configurable","getSenderAddress","bind","val","_from","initData","buffer","isBuffer","decode","self","Array","isArray","Error","d","i","keys","field","startsWith","gas","input","_chainId","chainId","raw","module","exports","constructor","type","types","none","common","forCustomChain","name","networkId","comment","bootstrapNodes","undefined","ganacheTxCommon","signed","fake","fromJSON","json","hardfork","toAccount","buf","equals","setLengthLeft","options","nonce","hex","value","gasLimit","gasPrice","r","s","Math","floor","encode","resultJSON","nullableRpcDataHexString","nullableRpcQuantityHexString","rpcDataHexString","toString","_type","_options","isSigned","validateNonce","expectedNonce","toJsonRpc","block","transactionIndex","txns","transactions","l","rpcQuantityHexString","blockHash","blockNumber","header","number"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/utils/transaction.js"],"sourcesContent":["const EthereumJsTransaction = require(\"ethereumjs-tx\").Transaction;\nconst EthereumJsFakeTransaction = require(\"ethereumjs-tx\").FakeTransaction;\nconst Common = require(\"ethereumjs-common\").default;\nconst ethUtil = require(\"ethereumjs-util\");\nconst assert = require(\"assert\");\nconst rlp = ethUtil.rlp;\nconst to = require(\"./to\");\n\nconst sign = EthereumJsTransaction.prototype.sign;\nconst fakeHash = function() {\n  // this isn't memoization of the hash. previous versions of ganache-core\n  // created hashes in a different/incorrect way and are recorded this way\n  // in snapshot dbs. We are preserving the chain's immutability by using the\n  // stored hash instead of calculating it.\n  if (this._hash != null) {\n    return this._hash;\n  }\n  return EthereumJsFakeTransaction.prototype.hash.apply(this, arguments);\n};\nconst BUFFER_ZERO = Buffer.from([0]);\n\nfunction configZeroableField(tx, fieldName, fieldLength = 32) {\n  const index = tx._fields.indexOf(fieldName);\n  const descriptor = Object.getOwnPropertyDescriptor(tx, fieldName);\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(tx, fieldName, {\n    set: (v) => {\n      descriptor.set.call(tx, v);\n      v = ethUtil.toBuffer(v);\n      assert(fieldLength >= v.length, `The field ${fieldName} must not have more ${fieldLength} bytes`);\n      tx._originals[index] = v;\n    },\n    get: () => {\n      return tx._originals[index];\n    }\n  });\n}\n\n/**\n * etheruemjs-tx's Transactions don't behave quite like we need them to, so\n * we're monkey-patching them to do what we want here.\n * @param {Transaction} tx The Transaction to fix\n * @param {Object} [data] The data object\n */\nfunction fixProps(tx, data) {\n  // ethereumjs-tx doesn't allow for a `0` value in fields, but we want it to\n  // in order to differentiate between a value that isn't set and a value\n  // that is set to 0 in a fake transaction.\n  // Once https://github.com/ethereumjs/ethereumjs-tx/issues/112 is figured\n  // out we can probably remove this fix/hack.\n  // We keep track of the original value and return that value when\n  // referenced by its property name. This lets us properly encode a `0` as\n  // an empty buffer while still being able to differentiate between a `0`\n  // and `null`/`undefined`.\n  tx._originals = [];\n  const fieldNames = [\"nonce\", \"gasPrice\", \"gasLimit\", \"value\"];\n  fieldNames.forEach((fieldName) => configZeroableField(tx, fieldName, 32));\n\n  if (tx.isFake()) {\n    /**\n     * @prop {Buffer} from (read/write) Set from address to bypass transaction\n     * signing on fake transactions.\n     */\n    Object.defineProperty(tx, \"from\", {\n      enumerable: true,\n      configurable: true,\n      get: tx.getSenderAddress.bind(tx),\n      set: (val) => {\n        if (val) {\n          tx._from = ethUtil.toBuffer(val);\n        } else {\n          tx._from = null;\n        }\n      }\n    });\n\n    if (data && data.from) {\n      tx.from = data.from;\n    }\n\n    tx.hash = fakeHash;\n  }\n}\n\n/**\n * Parses the given data object and adds its properties to the given tx.\n * @param {Transaction} tx\n * @param {Object} [data]\n */\nfunction initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    const self = tx;\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n      tx._fields.forEach(function(field) {\n        if (keys.indexOf(field) !== -1) {\n          let val = data[field];\n          if (typeof val === \"string\" && !val.startsWith(\"0x\")) {\n            val = \"0x\" + val;\n          }\n          self[field] = val;\n        }\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self.gas = data.gas;\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self.input = data.input;\n          }\n        }\n      });\n\n      // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}\n\nmodule.exports = class Transaction extends EthereumJsTransaction {\n  /**\n   * @param {Object} [data] The data for this Transaction.\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   * @param {Object} [common] EthereumJS common.fromCustomChain()\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n  constructor(data, type = Transaction.types.none, common) {\n    if (data.chainId && !common) {\n      common = Common.forCustomChain(\n        \"mainnet\", // TODO needs to match chain id\n        {\n          name: \"ganache\",\n          networkId: 1,\n          chainId: data.chainId,\n          comment: \"Local test network\",\n          bootstrapNodes: []\n        },\n        \"muirGlacier\"\n      );\n    }\n    super(undefined, { common });\n\n    this.ganacheTxCommon = common;\n    this.type = type;\n\n    fixProps(this, data);\n    initData(this, data);\n  }\n\n  static get types() {\n    // values must be powers of 2\n    return {\n      none: 0,\n      signed: 1,\n      fake: 2\n    };\n  }\n\n  /**\n   * Prepares arbitrary JSON data for use in a Transaction.\n   * @param {Object} json JSON object representing the Transaction\n   * @param {Number} type The `Transaction.types` bit flag for this transaction\n   * @param {Object} [common] EthereumJS common.fromCustomChain()\n   * @param {Number} [networkId]\n   * @param {string} [hardfork]\n   *  Can be a combination of `Transaction.types.none`, `Transaction.types.signed`, and `Transaction.types.fake`.\n   */\n  static fromJSON(json, type, common, networkId, hardfork) {\n    let toAccount;\n    if (json.to) {\n      // Remove all padding and make it easily comparible.\n      const buf = to.buffer(json.to);\n      if (buf.equals(Buffer.from([0]))) {\n        // if the address is 0x0 make it 0x0{20}\n        toAccount = ethUtil.setLengthLeft(buf, 20);\n      } else {\n        toAccount = buf;\n      }\n    }\n    const data = json.data || json.input;\n    const options = {\n      nonce: ethUtil.toBuffer(to.hex(json.nonce)),\n      from: ethUtil.toBuffer(to.hex(json.from)),\n      value: ethUtil.toBuffer(to.hex(json.value)),\n      gasLimit: ethUtil.toBuffer(to.hex(json.gas || json.gasLimit)),\n      gasPrice: ethUtil.toBuffer(to.hex(json.gasPrice)),\n      data: data ? to.buffer(data) : null,\n      to: toAccount,\n      v: ethUtil.toBuffer(json.v),\n      r: ethUtil.toBuffer(json.r),\n      s: ethUtil.toBuffer(json.s)\n    };\n    if (!common && options.v.length > 0) {\n      const chainId = Math.floor((json.v - 35) / 2);\n      common = Common.forCustomChain(\n        \"mainnet\", // TODO needs to match chain id\n        {\n          name: \"ganache\",\n          networkId: networkId,\n          chainId: chainId >= 0 ? chainId : 1,\n          comment: \"Local test network\",\n          bootstrapNodes: []\n        },\n        hardfork\n      );\n    }\n    const tx = new Transaction(options, type, common);\n    tx._hash = json.hash ? to.buffer(json.hash) : null;\n    return tx;\n  }\n\n  /**\n   * Encodes the Transaction in order to be used in a database. Can be decoded\n   * into an identical Transaction via `Transaction.decode(encodedTx)`.\n   */\n  encode() {\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(this.hash()),\n      nonce: to.nullableRpcQuantityHexString(this.nonce) || \"0x\",\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.nullableRpcQuantityHexString(this.value),\n      gas: to.nullableRpcQuantityHexString(this.gasLimit),\n      gasPrice: to.nullableRpcQuantityHexString(this.gasPrice),\n      data: this.data ? this.data.toString(\"hex\") : null,\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcQuantityHexString(this.r),\n      s: to.nullableRpcQuantityHexString(this.s),\n      _type: this.type,\n      _options: {\n        hardfork: this.ganacheTxCommon.hardfork(),\n        chainId: this.ganacheTxCommon.chainId(),\n        networkId: this.ganacheTxCommon.networkId()\n      }\n    };\n    return resultJSON;\n  }\n\n  isFake() {\n    return (this.type & Transaction.types.fake) === Transaction.types.fake;\n  }\n\n  isSigned() {\n    return (this.type & Transaction.types.signed) === Transaction.types.signed;\n  }\n\n  /**\n   * Compares the transaction's nonce value to the given expectedNonce taking in\n   * to account the type of transaction and comparison rules for each type.\n   *\n   * In a signed transaction a nonce of Buffer([]) is the same as Buffer([0]),\n   * but in a fake transaction Buffer([]) is null and Buffer([0]) is 0.\n   *\n   * @param {Buffer} expectedNonce The value of the from account's next nonce.\n   */\n  validateNonce(expectedNonce) {\n    let nonce;\n    if (this.isSigned() && this.nonce.length === 0) {\n      nonce = BUFFER_ZERO;\n    } else {\n      nonce = this.nonce;\n    }\n    return nonce.equals(expectedNonce);\n  }\n\n  /**\n   * Signs the transaction and sets the `type` bit for `signed` to 1,\n   * i.e., `isSigned() === true`\n   */\n  sign() {\n    sign.apply(this, arguments);\n    this.type |= Transaction.types.signed;\n  }\n\n  /**\n   * Returns a JSON-RPC spec compliant representation of this Transaction.\n   *\n   * @param {Object} block The block this Transaction appears in.\n   */\n  toJsonRpc(block) {\n    const hash = this.hash();\n\n    let transactionIndex = null;\n    for (let i = 0, txns = block.transactions, l = txns.length; i < l; i++) {\n      if (txns[i].hash().equals(hash)) {\n        transactionIndex = i;\n        break;\n      }\n    }\n\n    const resultJSON = {\n      hash: to.nullableRpcDataHexString(hash),\n      nonce: to.rpcQuantityHexString(this.nonce),\n      blockHash: to.nullableRpcDataHexString(block.hash()),\n      blockNumber: to.nullableRpcQuantityHexString(block.header.number),\n      transactionIndex: to.nullableRpcQuantityHexString(transactionIndex),\n      from: to.rpcDataHexString(this.from),\n      to: to.nullableRpcDataHexString(this.to),\n      value: to.rpcQuantityHexString(this.value),\n      gas: to.rpcQuantityHexString(this.gasLimit),\n      gasPrice: to.rpcQuantityHexString(this.gasPrice),\n      input: to.rpcDataHexString(this.data),\n      v: to.nullableRpcQuantityHexString(this.v),\n      r: to.nullableRpcQuantityHexString(this.r),\n      s: to.nullableRpcQuantityHexString(this.s)\n    };\n\n    return resultJSON;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
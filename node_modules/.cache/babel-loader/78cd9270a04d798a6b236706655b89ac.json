{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.supportHexEqual = void 0;\n\nfunction supportHexEqual(Assertion) {\n  Assertion.addMethod('hexEqual', function (other) {\n    const subject = this._obj;\n    const isNegated = this.__flags.negate === true;\n\n    const isHex = a => /^0x[0-9a-fA-F]*$/.test(a);\n\n    for (const element of [subject, other]) {\n      if (!isHex(element)) {\n        this.assert(isNegated, `Expected \"${subject}\" to be a hex string equal to \"${other}\", but \"${element}\" is not a valid hex string`, `Expected \"${subject}\" not to be a hex string equal to \"${other}\", but \"${element}\" is not a valid hex string`);\n      }\n    }\n\n    const extractNumeric = hex => hex.replace(/^0x0*/, '');\n\n    this.assert(extractNumeric(subject.toLowerCase()) === extractNumeric(other.toLowerCase()), `Expected \"${subject}\" to be a hex string equal equal to \"${other}\"`, `Expected \"${subject}\" not to a hex string equal be equal to \"${other}\", but it was`, `Hex string representing the same number as ${other}`, subject);\n  });\n}\n\nexports.supportHexEqual = supportHexEqual;","map":{"version":3,"names":["Object","defineProperty","exports","value","supportHexEqual","Assertion","addMethod","other","subject","_obj","isNegated","__flags","negate","isHex","a","test","element","assert","extractNumeric","hex","replace","toLowerCase"],"sources":["F:/Games/slotmachinereact/node_modules/@ethereum-waffle/chai/dist/cjs/matchers/hexEqual.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.supportHexEqual = void 0;\nfunction supportHexEqual(Assertion) {\n    Assertion.addMethod('hexEqual', function (other) {\n        const subject = this._obj;\n        const isNegated = this.__flags.negate === true;\n        const isHex = (a) => /^0x[0-9a-fA-F]*$/.test(a);\n        for (const element of [subject, other]) {\n            if (!isHex(element)) {\n                this.assert(isNegated, `Expected \"${subject}\" to be a hex string equal to \"${other}\", but \"${element}\" is not a valid hex string`, `Expected \"${subject}\" not to be a hex string equal to \"${other}\", but \"${element}\" is not a valid hex string`);\n            }\n        }\n        const extractNumeric = (hex) => hex.replace(/^0x0*/, '');\n        this.assert(extractNumeric(subject.toLowerCase()) === extractNumeric(other.toLowerCase()), `Expected \"${subject}\" to be a hex string equal equal to \"${other}\"`, `Expected \"${subject}\" not to a hex string equal be equal to \"${other}\", but it was`, `Hex string representing the same number as ${other}`, subject);\n    });\n}\nexports.supportHexEqual = supportHexEqual;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,SAASA,eAAT,CAAyBC,SAAzB,EAAoC;EAChCA,SAAS,CAACC,SAAV,CAAoB,UAApB,EAAgC,UAAUC,KAAV,EAAiB;IAC7C,MAAMC,OAAO,GAAG,KAAKC,IAArB;IACA,MAAMC,SAAS,GAAG,KAAKC,OAAL,CAAaC,MAAb,KAAwB,IAA1C;;IACA,MAAMC,KAAK,GAAIC,CAAD,IAAO,mBAAmBC,IAAnB,CAAwBD,CAAxB,CAArB;;IACA,KAAK,MAAME,OAAX,IAAsB,CAACR,OAAD,EAAUD,KAAV,CAAtB,EAAwC;MACpC,IAAI,CAACM,KAAK,CAACG,OAAD,CAAV,EAAqB;QACjB,KAAKC,MAAL,CAAYP,SAAZ,EAAwB,aAAYF,OAAQ,kCAAiCD,KAAM,WAAUS,OAAQ,6BAArG,EAAoI,aAAYR,OAAQ,sCAAqCD,KAAM,WAAUS,OAAQ,6BAArN;MACH;IACJ;;IACD,MAAME,cAAc,GAAIC,GAAD,IAASA,GAAG,CAACC,OAAJ,CAAY,OAAZ,EAAqB,EAArB,CAAhC;;IACA,KAAKH,MAAL,CAAYC,cAAc,CAACV,OAAO,CAACa,WAAR,EAAD,CAAd,KAA0CH,cAAc,CAACX,KAAK,CAACc,WAAN,EAAD,CAApE,EAA4F,aAAYb,OAAQ,wCAAuCD,KAAM,GAA7J,EAAkK,aAAYC,OAAQ,4CAA2CD,KAAM,eAAvO,EAAwP,8CAA6CA,KAAM,EAA3S,EAA8SC,OAA9S;EACH,CAXD;AAYH;;AACDN,OAAO,CAACE,eAAR,GAA0BA,eAA1B"},"metadata":{},"sourceType":"script"}
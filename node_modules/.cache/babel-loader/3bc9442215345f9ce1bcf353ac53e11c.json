{"ast":null,"code":"const TrieNode = require('./trieNode');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\n\n\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n\n    cb(null, p);\n  });\n};\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\n\n\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n\n        return cb(null, node.value);\n      }\n\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n\n        key = key.slice(embeddedNode.key.length);\n\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n\n      cld = node.value;\n      key = key.slice(node.key.length);\n\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n\n  cb(new Error('Unexpected end of proof'));\n};","map":{"version":3,"names":["TrieNode","require","ethUtil","matchingNibbleLength","exports","prove","trie","key","cb","nodes","findPath","err","node","remaining","stack","length","Error","p","i","rlpNode","serialize","push","verifyProof","rootHash","proof","stringToNibbles","wantHash","toBuffer","hash","sha3","Buffer","compare","rlp","decode","cld","type","value","raw","slice","embeddedNode"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/ethereumjs-block/node_modules/merkle-patricia-tree/proof.js"],"sourcesContent":["const TrieNode = require('./trieNode')\nconst ethUtil = require('ethereumjs-util')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\n\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\nexports.prove = function (trie, key, cb) {\n  var nodes\n\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err)\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'))\n    nodes = stack\n    var p = []\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize()\n\n      if ((rlpNode.length >= 32) || (i === 0)) {\n        p.push(rlpNode)\n      }\n    }\n    cb(null, p)\n  })\n}\n\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key)\n  var wantHash = ethUtil.toBuffer(rootHash)\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i])\n    var hash = ethUtil.sha3(proof[i])\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'))\n    }\n    var node = new TrieNode(ethUtil.rlp.decode(p))\n    var cld\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'))\n        }\n        return cb(null, node.value)\n      }\n      cld = node.raw[key[0]]\n      key = key.slice(1)\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld)\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'))\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'))\n        }\n        key = key.slice(embeddedNode.key.length)\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'))\n        }\n        return cb(null, embeddedNode.value)\n      } else {\n        wantHash = cld\n      }\n    } else if ((node.type === 'extention') || (node.type === 'leaf')) {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'))\n      }\n      cld = node.value\n      key = key.slice(node.key.length)\n      if (key.length === 0 || (cld.length === 17 && key.length === 1)) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1]\n          key = key.slice(1)\n        }\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'))\n        }\n        return cb(null, cld)\n      } else {\n        wantHash = cld\n      }\n    } else {\n      return cb(new Error('Invalid node type'))\n    }\n  }\n  cb(new Error('Unexpected end of proof'))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
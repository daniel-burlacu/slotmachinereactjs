{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar gitHosts = require('./git-host-info.js');\n\nvar GitHost = module.exports = require('./git-host.js');\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nvar cache = {};\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return;\n  var key = giturl + JSON.stringify(opts || {});\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts);\n  }\n\n  return cache[key];\n};\n\nfunction fromUrl(giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/);\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth;\n      }\n\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''));\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n        /* istanbul ignore else */\n\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        }\n\n        project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {} else throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n}\n\nfunction isGitHubShorthand(arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\n\nfunction fixupUnqualifiedGist(giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl);\n\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\n\nfunction parseGitUrl(giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n\n  if (!matched) {\n    var legacy = url.parse(giturl); // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/);\n      /* istanbul ignore else - this should be impossible */\n\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0]);\n        legacy.auth = whatwg.username || '';\n        if (whatwg.password) legacy.auth += ':' + whatwg.password;\n      }\n    }\n\n    return legacy;\n  }\n\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"names":["url","require","gitHosts","GitHost","module","exports","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","cache","fromUrl","giturl","opts","key","JSON","stringify","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","matches","Object","keys","map","gitHostName","gitHostInfo","auth","committish","hash","decodeURIComponent","substr","user","project","defaultRepresentation","replace","host","domain","protocols_re","test","path","pathmatch","matched","undefined","ex","URIError","filter","length","arg","parse","legacy","URL","authmatch","whatwg","username","password","slashes","port","hostname","search","query","pathname","href"],"sources":["F:/Games/slotmachinereact/node_modules/hosted-git-info/index.js"],"sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nvar cache = {}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts)\n  }\n\n  return cache[key]\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/)\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''))\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        }\n        project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {\n      } else throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) {\n    var legacy = url.parse(giturl)\n    // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/)\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0])\n        legacy.auth = whatwg.username || ''\n        if (whatwg.password) legacy.auth += ':' + whatwg.password\n      }\n    }\n    return legacy\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
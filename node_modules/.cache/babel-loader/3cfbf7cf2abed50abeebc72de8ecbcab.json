{"ast":null,"code":"/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file Registry.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar Contract = require('web3-eth-contract');\n\nvar namehash = require('eth-ens-namehash');\n\nvar PromiEvent = require('web3-core-promievent');\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar REGISTRY_ABI = require('../resources/ABI/Registry');\n\nvar RESOLVER_ABI = require('../resources/ABI/Resolver');\n/**\n * A wrapper around the ENS registry contract.\n *\n * @method Registry\n * @param {Ens} ens\n * @constructor\n */\n\n\nfunction Registry(ens) {\n  var self = this;\n  this.ens = ens;\n  this.contract = ens.checkNetwork().then(function (address) {\n    var contract = new Contract(REGISTRY_ABI, address);\n    contract.setProvider(self.ens.eth.currentProvider);\n    return contract;\n  });\n}\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @deprecated Please use the \"getOwner\" method instead of \"owner\"\n *\n * @method owner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\n\n\nRegistry.prototype.owner = function (name, callback) {\n  console.warn('Deprecated: Please use the \"getOwner\" method instead of \"owner\".');\n  return this.getOwner(name, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method getOwner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\n\n\nRegistry.prototype.getOwner = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.owner(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setOwner\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setOwner = function (name, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setOwner(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns the TTL of the given node by his name\n *\n * @method getTTL\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returnss {Promise<string>}\n */\n\n\nRegistry.prototype.getTTL = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.ttl(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setTTL\n *\n * @param {string} name\n * @param {number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setTTL = function (name, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setTTL(namehash.hash(name), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setSubnodeOwner\n *\n * @param {string} name\n * @param {string} label\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setSubnodeOwner = function (name, label, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n\n  if (!utils.isHexStrict(label)) {\n    label = utils.sha3(label);\n  }\n\n  this.contract.then(function (contract) {\n    return contract.methods.setSubnodeOwner(namehash.hash(name), label, formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Sets the owner, resolver, and TTL for an ENS record in a single operation.\n *\n * @method setRecord\n *\n * @param {string} name\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setRecord = function (name, owner, resolver, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setRecord(namehash.hash(name), formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Sets the owner, resolver and TTL for a subdomain, creating it if necessary.\n *\n * @method setSubnodeRecord\n *\n * @param {string} name\n * @param {string} label\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setSubnodeRecord = function (name, label, owner, resolver, ttl, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n\n  if (!utils.isHexStrict(label)) {\n    label = utils.sha3(label);\n  }\n\n  this.contract.then(function (contract) {\n    return contract.methods.setSubnodeRecord(namehash.hash(name), label, formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Sets or clears an approval by the given operator.\n *\n * @method setApprovalForAll\n *\n * @param {string} operator\n * @param {boolean} approved\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setApprovalForAll = function (operator, approved, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setApprovalForAll(formatters.inputAddressFormatter(operator), approved).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns true if the operator is approved\n *\n * @method isApprovedForAll\n *\n * @param {string} owner\n * @param {string} operator\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\n\n\nRegistry.prototype.isApprovedForAll = function (owner, operator, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.isApprovedForAll(formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(operator)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns true if the record exists\n *\n * @method recordExists\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\n\n\nRegistry.prototype.recordExists = function (name, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.recordExists(namehash.hash(name)).call();\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n/**\n * Returns the resolver contract associated with a name.\n *\n * @deprecated Please use the \"getResolver\" method instead of \"resolver\"\n *\n * @method resolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\n\n\nRegistry.prototype.resolver = function (name, callback) {\n  console.warn('Deprecated: Please use the \"getResolver\" method instead of \"resolver\".');\n  return this.getResolver(name, callback);\n};\n/**\n * Returns the resolver contract associated with a name.\n *\n * @method getResolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\n\n\nRegistry.prototype.getResolver = function (name, callback) {\n  var self = this;\n  return this.contract.then(function (contract) {\n    return contract.methods.resolver(namehash.hash(name)).call();\n  }).then(function (address) {\n    var contract = new Contract(RESOLVER_ABI, address);\n    contract.setProvider(self.ens.eth.currentProvider);\n\n    if (_.isFunction(callback)) {\n      // It's required to pass the contract to the first argument to be backward compatible and to have the required consistency\n      callback(contract, contract);\n      return;\n    }\n\n    return contract;\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    throw error;\n  });\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setResolver\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\n\n\nRegistry.prototype.setResolver = function (name, address, txConfig, callback) {\n  var promiEvent = new PromiEvent(true);\n  this.contract.then(function (contract) {\n    return contract.methods.setResolver(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n  }).then(function (receipt) {\n    if (_.isFunction(callback)) {\n      // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n      callback(receipt, receipt);\n      return;\n    }\n\n    promiEvent.resolve(receipt);\n  }).catch(function (error) {\n    if (_.isFunction(callback)) {\n      callback(error, null);\n      return;\n    }\n\n    promiEvent.reject(error);\n  });\n  return promiEvent.eventEmitter;\n};\n\nmodule.exports = Registry;","map":{"version":3,"names":["_","require","Contract","namehash","PromiEvent","formatters","utils","REGISTRY_ABI","RESOLVER_ABI","Registry","ens","self","contract","checkNetwork","then","address","setProvider","eth","currentProvider","prototype","owner","name","callback","console","warn","getOwner","promiEvent","methods","hash","call","receipt","isFunction","resolve","catch","error","reject","eventEmitter","setOwner","txConfig","inputAddressFormatter","send","getTTL","ttl","setTTL","setSubnodeOwner","label","isHexStrict","sha3","setRecord","resolver","setSubnodeRecord","setApprovalForAll","operator","approved","isApprovedForAll","recordExists","getResolver","setResolver","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/web3-eth-ens/src/contracts/Registry.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file Registry.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar Contract = require('web3-eth-contract');\nvar namehash = require('eth-ens-namehash');\nvar PromiEvent = require('web3-core-promievent');\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar REGISTRY_ABI = require('../resources/ABI/Registry');\nvar RESOLVER_ABI = require('../resources/ABI/Resolver');\n\n\n/**\n * A wrapper around the ENS registry contract.\n *\n * @method Registry\n * @param {Ens} ens\n * @constructor\n */\nfunction Registry(ens) {\n    var self = this;\n    this.ens = ens;\n    this.contract = ens.checkNetwork().then(function (address) {\n        var contract = new Contract(REGISTRY_ABI, address);\n        contract.setProvider(self.ens.eth.currentProvider);\n\n        return contract;\n    });\n}\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @deprecated Please use the \"getOwner\" method instead of \"owner\"\n *\n * @method owner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\nRegistry.prototype.owner = function (name, callback) {\n    console.warn('Deprecated: Please use the \"getOwner\" method instead of \"owner\".');\n\n    return this.getOwner(name, callback);\n};\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method getOwner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\nRegistry.prototype.getOwner = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.owner(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setOwner\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setOwner = function (name, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.setOwner(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns the TTL of the given node by his name\n *\n * @method getTTL\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returnss {Promise<string>}\n */\nRegistry.prototype.getTTL = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.ttl(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setTTL\n *\n * @param {string} name\n * @param {number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setTTL = function (name, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.setTTL(namehash.hash(name), ttl).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setSubnodeOwner\n *\n * @param {string} name\n * @param {string} label\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setSubnodeOwner = function (name, label, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    if (!utils.isHexStrict(label)) {\n        label = utils.sha3(label);\n    }\n\n    this.contract.then(function (contract) {\n        return contract.methods.setSubnodeOwner(\n            namehash.hash(name),\n            label,\n            formatters.inputAddressFormatter(address)\n        ).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Sets the owner, resolver, and TTL for an ENS record in a single operation.\n *\n * @method setRecord\n *\n * @param {string} name\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setRecord = function (name, owner, resolver, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.setRecord(\n            namehash.hash(name),\n            formatters.inputAddressFormatter(owner),\n            formatters.inputAddressFormatter(resolver),\n            ttl\n        ).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Sets the owner, resolver and TTL for a subdomain, creating it if necessary.\n *\n * @method setSubnodeRecord\n *\n * @param {string} name\n * @param {string} label\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setSubnodeRecord = function (name, label, owner, resolver, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    if (!utils.isHexStrict(label)) {\n        label = utils.sha3(label);\n    }\n\n    this.contract.then(function (contract) {\n        return contract.methods.setSubnodeRecord(\n            namehash.hash(name),\n            label,\n            formatters.inputAddressFormatter(owner),\n            formatters.inputAddressFormatter(resolver),\n            ttl\n        ).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Sets or clears an approval by the given operator.\n *\n * @method setApprovalForAll\n *\n * @param {string} operator\n * @param {boolean} approved\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setApprovalForAll = function (operator, approved, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.setApprovalForAll(formatters.inputAddressFormatter(operator), approved).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns true if the operator is approved\n *\n * @method isApprovedForAll\n *\n * @param {string} owner\n * @param {string} operator\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nRegistry.prototype.isApprovedForAll = function (owner, operator, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.isApprovedForAll(\n            formatters.inputAddressFormatter(owner),\n            formatters.inputAddressFormatter(operator)\n        ).call();\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns true if the record exists\n *\n * @method recordExists\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nRegistry.prototype.recordExists = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.recordExists(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\n/**\n * Returns the resolver contract associated with a name.\n *\n * @deprecated Please use the \"getResolver\" method instead of \"resolver\"\n *\n * @method resolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nRegistry.prototype.resolver = function (name, callback) {\n    console.warn('Deprecated: Please use the \"getResolver\" method instead of \"resolver\".');\n\n    return this.getResolver(name, callback);\n};\n\n/**\n * Returns the resolver contract associated with a name.\n *\n * @method getResolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nRegistry.prototype.getResolver = function (name, callback) {\n    var self = this;\n\n    return this.contract.then(function (contract) {\n        return contract.methods.resolver(namehash.hash(name)).call();\n    }).then(function (address) {\n        var contract = new Contract(RESOLVER_ABI, address);\n        contract.setProvider(self.ens.eth.currentProvider);\n\n        if (_.isFunction(callback)) {\n            // It's required to pass the contract to the first argument to be backward compatible and to have the required consistency\n            callback(contract, contract);\n\n            return;\n        }\n\n        return contract;\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        throw error;\n    });\n};\n\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setResolver\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setResolver = function (name, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n\n    this.contract.then(function (contract) {\n        return contract.methods.setResolver(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n    }).then(function (receipt) {\n        if (_.isFunction(callback)) {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n\n            return;\n        }\n\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (_.isFunction(callback)) {\n            callback(error, null);\n\n            return;\n        }\n\n        promiEvent.reject(error);\n    });\n\n    return promiEvent.eventEmitter;\n};\n\nmodule.exports = Registry;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
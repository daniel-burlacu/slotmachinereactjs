{"ast":null,"code":"var Writable = require('readable-stream').Writable;\n\nvar inherits = require('inherits');\n\nvar extend = require('xtend');\n\nvar defaultOptions = {\n  type: 'put'\n};\n\nfunction WriteStream(db, options) {\n  if (!(this instanceof WriteStream)) {\n    return new WriteStream(db, options);\n  }\n\n  options = extend(defaultOptions, options);\n  Writable.call(this, {\n    objectMode: true,\n    highWaterMark: options.highWaterMark || 16\n  });\n  this._options = options;\n  this._db = db;\n  this._buffer = [];\n  this._flushing = false;\n  this._maxBufferLength = options.maxBufferLength || Infinity;\n  var self = this;\n  this.on('finish', function () {\n    self.emit('close');\n  });\n}\n\ninherits(WriteStream, Writable);\n\nWriteStream.prototype._write = function (data, enc, next) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (!self._flushing) {\n    self._flushing = true;\n    process.nextTick(function () {\n      self._flush();\n    });\n  }\n\n  if (self._buffer.length >= self._maxBufferLength) {\n    self.once('_flush', function (err) {\n      if (err) return self.destroy(err);\n\n      self._write(data, enc, next);\n    });\n  } else {\n    self._buffer.push(extend({\n      type: self._options.type\n    }, data));\n\n    next();\n  }\n};\n\nWriteStream.prototype._flush = function () {\n  var self = this;\n  var buffer = self._buffer;\n  if (self.destroyed) return;\n  self._buffer = [];\n\n  self._db.batch(buffer, cb);\n\n  function cb(err) {\n    self._flushing = false;\n\n    if (!self.emit('_flush', err) && err) {\n      // There was no _flush listener.\n      self.destroy(err);\n    }\n  }\n};\n\nWriteStream.prototype._final = function (cb) {\n  var self = this;\n\n  if (this._flushing) {\n    // Wait for scheduled or in-progress _flush()\n    this.once('_flush', function (err) {\n      if (err) return cb(err); // There could be additional buffered writes\n\n      self._final(cb);\n    });\n  } else if (this._buffer && this._buffer.length) {\n    this.once('_flush', cb);\n\n    this._flush();\n  } else {\n    cb();\n  }\n};\n\nWriteStream.prototype._destroy = function (err, cb) {\n  var self = this;\n  this._buffer = null;\n  cb(err); // TODO when the next readable-stream (mirroring node v10) is out:\n  // remove this. Since nodejs/node#19836, streams always emit close.\n\n  process.nextTick(function () {\n    self.emit('close');\n  });\n};\n\nmodule.exports = WriteStream;","map":{"version":3,"names":["Writable","require","inherits","extend","defaultOptions","type","WriteStream","db","options","call","objectMode","highWaterMark","_options","_db","_buffer","_flushing","_maxBufferLength","maxBufferLength","Infinity","self","on","emit","prototype","_write","data","enc","next","destroyed","process","nextTick","_flush","length","once","err","destroy","push","buffer","batch","cb","_final","_destroy","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/level-ws/level-ws.js"],"sourcesContent":["var Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar extend = require('xtend')\n\nvar defaultOptions = { type: 'put' }\n\nfunction WriteStream (db, options) {\n  if (!(this instanceof WriteStream)) {\n    return new WriteStream(db, options)\n  }\n\n  options = extend(defaultOptions, options)\n\n  Writable.call(this, {\n    objectMode: true,\n    highWaterMark: options.highWaterMark || 16\n  })\n\n  this._options = options\n  this._db = db\n  this._buffer = []\n  this._flushing = false\n  this._maxBufferLength = options.maxBufferLength || Infinity\n\n  var self = this\n\n  this.on('finish', function () {\n    self.emit('close')\n  })\n}\n\ninherits(WriteStream, Writable)\n\nWriteStream.prototype._write = function (data, enc, next) {\n  var self = this\n  if (self.destroyed) return\n\n  if (!self._flushing) {\n    self._flushing = true\n    process.nextTick(function () { self._flush() })\n  }\n\n  if (self._buffer.length >= self._maxBufferLength) {\n    self.once('_flush', function (err) {\n      if (err) return self.destroy(err)\n      self._write(data, enc, next)\n    })\n  } else {\n    self._buffer.push(extend({ type: self._options.type }, data))\n    next()\n  }\n}\n\nWriteStream.prototype._flush = function () {\n  var self = this\n  var buffer = self._buffer\n\n  if (self.destroyed) return\n\n  self._buffer = []\n  self._db.batch(buffer, cb)\n\n  function cb (err) {\n    self._flushing = false\n\n    if (!self.emit('_flush', err) && err) {\n      // There was no _flush listener.\n      self.destroy(err)\n    }\n  }\n}\n\nWriteStream.prototype._final = function (cb) {\n  var self = this\n\n  if (this._flushing) {\n    // Wait for scheduled or in-progress _flush()\n    this.once('_flush', function (err) {\n      if (err) return cb(err)\n\n      // There could be additional buffered writes\n      self._final(cb)\n    })\n  } else if (this._buffer && this._buffer.length) {\n    this.once('_flush', cb)\n    this._flush()\n  } else {\n    cb()\n  }\n}\n\nWriteStream.prototype._destroy = function (err, cb) {\n  var self = this\n\n  this._buffer = null\n  cb(err)\n\n  // TODO when the next readable-stream (mirroring node v10) is out:\n  // remove this. Since nodejs/node#19836, streams always emit close.\n  process.nextTick(function () {\n    self.emit('close')\n  })\n}\n\nmodule.exports = WriteStream\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
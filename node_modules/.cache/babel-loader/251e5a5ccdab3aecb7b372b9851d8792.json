{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar assert = require('assert');\n\nvar level = require('level-mem');\n\nvar async = require('async');\n\nvar rlp = require('rlp');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar semaphore = require('semaphore');\n\nvar TrieNode = require('./trieNode');\n\nvar ReadStream = require('./readStream');\n\nvar PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\n\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\n\nvar doKeysMatch = require('./util').doKeysMatch;\n\nvar callTogether = require('./util').callTogether;\n\nvar asyncFirstSeries = require('./util').asyncFirstSeries;\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @public\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root] A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  function Trie(db, root) {\n    _classCallCheck(this, Trie);\n\n    var self = this;\n    this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n    this.sem = semaphore(1); // setup dbs\n\n    this.db = db || level();\n    this._getDBs = [this.db];\n    this._putDBs = [this.db];\n    Object.defineProperty(this, 'root', {\n      set: function set(value) {\n        if (value) {\n          value = ethUtil.toBuffer(value);\n          assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n        } else {\n          value = self.EMPTY_TRIE_ROOT;\n        }\n\n        this._root = value;\n      },\n      get: function get() {\n        return this._root;\n      }\n    });\n    this.root = root;\n    this.putRaw = this._putRaw;\n  }\n  /**\n   * Gets a value given a `key`\n   * @method get\n   * @memberof Trie\n   * @param {Buffer|String} key - the key to search for\n   * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n   */\n\n\n  _createClass(Trie, [{\n    key: \"get\",\n    value: function get(key, cb) {\n      key = ethUtil.toBuffer(key);\n      this.findPath(key, function (err, node, remainder, stack) {\n        var value = null;\n\n        if (node && remainder.length === 0) {\n          value = node.value;\n        }\n\n        cb(err, value);\n      });\n    }\n    /**\n     * Stores a given `value` at the given `key`\n     * @method put\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Buffer|String} Value\n     * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, cb) {\n      var _this = this;\n\n      key = ethUtil.toBuffer(key);\n      value = ethUtil.toBuffer(value);\n\n      if (!value || value.toString() === '') {\n        this.del(key, cb);\n      } else {\n        cb = callTogether(cb, this.sem.leave);\n        this.sem.take(function () {\n          if (_this.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n            // first try to find the give key or its nearst node\n            _this.findPath(key, function (err, foundValue, keyRemainder, stack) {\n              if (err) {\n                return cb(err);\n              } // then update\n\n\n              _this._updateNode(key, value, keyRemainder, stack, cb);\n            });\n          } else {\n            _this._createInitialNode(key, value, cb); // if no root initialize this trie\n\n          }\n        });\n      }\n    }\n    /**\n     * deletes a value given a `key`\n     * @method del\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Function} callback the callback `Function`\n     */\n\n  }, {\n    key: \"del\",\n    value: function del(key, cb) {\n      var _this2 = this;\n\n      key = ethUtil.toBuffer(key);\n      cb = callTogether(cb, this.sem.leave);\n      this.sem.take(function () {\n        _this2.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (foundValue) {\n            _this2._deleteNode(key, stack, cb);\n          } else {\n            cb();\n          }\n        });\n      });\n    }\n    /**\n     * Retrieves a raw value in the underlying db\n     * @method getRaw\n     * @memberof Trie\n     * @param {Buffer} key\n     * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n     */\n\n  }, {\n    key: \"getRaw\",\n    value: function getRaw(key, cb) {\n      key = ethUtil.toBuffer(key);\n\n      function dbGet(db, cb2) {\n        db.get(key, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, function (err, foundNode) {\n          if (err || !foundNode) {\n            cb2(null, null);\n          } else {\n            cb2(null, foundNode);\n          }\n        });\n      }\n\n      asyncFirstSeries(this._getDBs, dbGet, cb);\n    } // retrieves a node from dbs by hash\n\n  }, {\n    key: \"_lookupNode\",\n    value: function _lookupNode(node, cb) {\n      if (TrieNode.isRawNode(node)) {\n        cb(new TrieNode(node));\n      } else {\n        this.getRaw(node, function (err, value) {\n          if (err) {\n            throw err;\n          }\n\n          if (value) {\n            value = new TrieNode(rlp.decode(value));\n          }\n\n          cb(value);\n        });\n      }\n    }\n    /**\n     * Writes a value directly to the underlining db\n     * @method putRaw\n     * @memberof Trie\n     * @param {Buffer|String} key The key as a `Buffer` or `String`\n     * @param {Buffer} value The value to be stored\n     * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n     */\n    // TODO: remove the proxy method when changing the caching\n\n  }, {\n    key: \"_putRaw\",\n    value: function _putRaw(key, val, cb) {\n      function dbPut(db, cb2) {\n        db.put(key, val, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, cb2);\n      }\n\n      async.each(this._putDBs, dbPut, cb);\n    }\n    /**\n     * Removes a raw value in the underlying db\n     * @method delRaw\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n     */\n\n  }, {\n    key: \"delRaw\",\n    value: function delRaw(key, cb) {\n      function del(db, cb2) {\n        db.del(key, {\n          keyEncoding: 'binary'\n        }, cb2);\n      }\n\n      async.each(this._putDBs, del, cb);\n    } // writes a single node to dbs\n\n  }, {\n    key: \"_putNode\",\n    value: function _putNode(node, cb) {\n      var hash = node.hash();\n      var serialized = node.serialize();\n\n      this._putRaw(hash, serialized, cb);\n    } // writes many nodes to db\n\n  }, {\n    key: \"_batchNodes\",\n    value: function _batchNodes(opStack, cb) {\n      function dbBatch(db, cb) {\n        db.batch(opStack, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, cb);\n      }\n\n      async.each(this._putDBs, dbBatch, cb);\n    }\n    /**\n     * Tries to find a path to the node for the given key\n     * It returns a `stack` of nodes to the closet node\n     * @method findPath\n     * @memberof Trie\n     * @param {String|Buffer} - key - the search key\n     * @param {Function} - cb - the callback function. Its is given the following\n     * arguments\n     *  - err - any errors encontered\n     *  - node - the last node found\n     *  - keyRemainder - the remaining key nibbles not accounted for\n     *  - stack - an array of nodes that forms the path to node we are searching for\n     */\n\n  }, {\n    key: \"findPath\",\n    value: function findPath(targetKey, cb) {\n      var stack = [];\n      targetKey = TrieNode.stringToNibbles(targetKey);\n\n      this._walkTrie(this.root, processNode, cb);\n\n      function processNode(nodeRef, node, keyProgress, walkController) {\n        var nodeKey = node.key || [];\n        var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n        var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n        stack.push(node);\n\n        if (node.type === 'branch') {\n          if (keyRemainder.length === 0) {\n            walkController.return(null, node, [], stack); // we exhausted the key without finding a node\n          } else {\n            var branchIndex = keyRemainder[0];\n            var branchNode = node.getValue(branchIndex);\n\n            if (!branchNode) {\n              // there are no more nodes to find and we didn't find the key\n              walkController.return(null, null, keyRemainder, stack);\n            } else {\n              // node found, continuing search\n              walkController.only(branchIndex);\n            }\n          }\n        } else if (node.type === 'leaf') {\n          if (doKeysMatch(keyRemainder, nodeKey)) {\n            // keys match, return node with empty key\n            walkController.return(null, node, [], stack);\n          } else {\n            // reached leaf but keys dont match\n            walkController.return(null, null, keyRemainder, stack);\n          }\n        } else if (node.type === 'extention') {\n          if (matchingLen !== nodeKey.length) {\n            // keys dont match, fail\n            walkController.return(null, null, keyRemainder, stack);\n          } else {\n            // keys match, continue search\n            walkController.next();\n          }\n        }\n      }\n    }\n    /*\n     * Finds all nodes that store k,v values\n     */\n\n  }, {\n    key: \"_findNode\",\n    value: function _findNode(key, root, stack, cb) {\n      var _arguments = arguments;\n      this.findPath(key, function () {\n        cb.apply(null, _arguments);\n      });\n    }\n    /*\n     * Finds all nodes that store k,v values\n     */\n\n  }, {\n    key: \"_findValueNodes\",\n    value: function _findValueNodes(onFound, cb) {\n      this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n        var fullKey = key;\n\n        if (node.key) {\n          fullKey = key.concat(node.key);\n        }\n\n        if (node.type === 'leaf') {\n          // found leaf node!\n          onFound(nodeRef, node, fullKey, walkController.next);\n        } else if (node.type === 'branch' && node.value) {\n          // found branch with value\n          onFound(nodeRef, node, fullKey, walkController.next);\n        } else {\n          // keep looking for value nodes\n          walkController.next();\n        }\n      }, cb);\n    }\n    /*\n     * Finds all nodes that are stored directly in the db\n     * (some nodes are stored raw inside other nodes)\n     */\n\n  }, {\n    key: \"_findDbNodes\",\n    value: function _findDbNodes(onFound, cb) {\n      this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n        if (TrieNode.isRawNode(nodeRef)) {\n          walkController.next();\n        } else {\n          onFound(nodeRef, node, key, walkController.next);\n        }\n      }, cb);\n    }\n    /**\n     * Updates a node\n     * @method _updateNode\n     * @private\n     * @param {Buffer} key\n     * @param {Buffer| String} value\n     * @param {Array} keyRemainder\n     * @param {Array} stack -\n     * @param {Function} cb - the callback\n     */\n\n  }, {\n    key: \"_updateNode\",\n    value: function _updateNode(key, value, keyRemainder, stack, cb) {\n      var toSave = [];\n      var lastNode = stack.pop(); // add the new nodes\n\n      key = TrieNode.stringToNibbles(key); // Check if the last node is a leaf and the key matches to this\n\n      var matchLeaf = false;\n\n      if (lastNode.type === 'leaf') {\n        var l = 0;\n\n        for (var i = 0; i < stack.length; i++) {\n          var n = stack[i];\n\n          if (n.type === 'branch') {\n            l++;\n          } else {\n            l += n.key.length;\n          }\n        }\n\n        if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n          matchLeaf = true;\n        }\n      }\n\n      if (matchLeaf) {\n        // just updating a found value\n        lastNode.value = value;\n        stack.push(lastNode);\n      } else if (lastNode.type === 'branch') {\n        stack.push(lastNode);\n\n        if (keyRemainder !== 0) {\n          // add an extention to a branch node\n          keyRemainder.shift(); // create a new leaf\n\n          var newLeaf = new TrieNode('leaf', keyRemainder, value);\n          stack.push(newLeaf);\n        } else {\n          lastNode.value = value;\n        }\n      } else {\n        // create a branch node\n        var lastKey = lastNode.key;\n        var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n        var newBranchNode = new TrieNode('branch'); // create a new extention node\n\n        if (matchingLength !== 0) {\n          var newKey = lastNode.key.slice(0, matchingLength);\n          var newExtNode = new TrieNode('extention', newKey, value);\n          stack.push(newExtNode);\n          lastKey.splice(0, matchingLength);\n          keyRemainder.splice(0, matchingLength);\n        }\n\n        stack.push(newBranchNode);\n\n        if (lastKey.length !== 0) {\n          var branchKey = lastKey.shift();\n\n          if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n            // shriking extention or leaf\n            lastNode.key = lastKey;\n\n            var formatedNode = this._formatNode(lastNode, false, toSave);\n\n            newBranchNode.setValue(branchKey, formatedNode);\n          } else {\n            // remove extention or attaching\n            this._formatNode(lastNode, false, true, toSave);\n\n            newBranchNode.setValue(branchKey, lastNode.value);\n          }\n        } else {\n          newBranchNode.value = lastNode.value;\n        }\n\n        if (keyRemainder.length !== 0) {\n          keyRemainder.shift(); // add a leaf node to the new branch node\n\n          var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n          stack.push(newLeafNode);\n        } else {\n          newBranchNode.value = value;\n        }\n      }\n\n      this._saveStack(key, stack, toSave, cb);\n    } // walk tree\n\n  }, {\n    key: \"_walkTrie\",\n    value: function _walkTrie(root, onNode, onDone) {\n      var self = this;\n      root = root || this.root;\n\n      onDone = onDone || function () {};\n\n      var aborted = false;\n      var returnValues = [];\n\n      if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n        return onDone();\n      }\n\n      this._lookupNode(root, function (node) {\n        processNode(root, node, null, function (err) {\n          if (err) {\n            return onDone(err);\n          }\n\n          onDone.apply(null, returnValues);\n        });\n      }); // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n      // low enough to utilize the prioritisation of node lookup.\n\n\n      var maxPoolSize = 500;\n      var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n\n      function processNode(nodeRef, node, key, cb) {\n        if (!node || aborted) {\n          return cb();\n        }\n\n        var stopped = false;\n        key = key || [];\n        var walkController = {\n          stop: function stop() {\n            stopped = true;\n            cb();\n          },\n          // end all traversal and return values to the onDone cb\n          return: function _return() {\n            aborted = true;\n            returnValues = arguments;\n            cb();\n          },\n          next: function next() {\n            if (aborted || stopped) {\n              return cb();\n            }\n\n            var children = node.getChildren();\n            async.forEachOf(children, function (childData, index, cb) {\n              var keyExtension = childData[0];\n              var childRef = childData[1];\n              var childKey = key.concat(keyExtension);\n              var priority = childKey.length;\n              taskExecutor.execute(priority, function (taskCallback) {\n                self._lookupNode(childRef, function (childNode) {\n                  taskCallback();\n                  processNode(childRef, childNode, childKey, cb);\n                });\n              });\n            }, cb);\n          },\n          only: function only(childIndex) {\n            var childRef = node.getValue(childIndex);\n            var childKey = key.slice();\n            childKey.push(childIndex);\n            var priority = childKey.length;\n            taskExecutor.execute(priority, function (taskCallback) {\n              self._lookupNode(childRef, function (childNode) {\n                taskCallback();\n                processNode(childRef, childNode, childKey, cb);\n              });\n            });\n          }\n        };\n        onNode(nodeRef, node, key, walkController);\n      }\n    }\n    /**\n     * saves a stack\n     * @method _saveStack\n     * @private\n     * @param {Array} key - the key. Should follow the stack\n     * @param {Array} stack - a stack of nodes to the value given by the key\n     * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"_saveStack\",\n    value: function _saveStack(key, stack, opStack, cb) {\n      var lastRoot; // update nodes\n\n      while (stack.length) {\n        var node = stack.pop();\n\n        if (node.type === 'leaf') {\n          key.splice(key.length - node.key.length);\n        } else if (node.type === 'extention') {\n          key.splice(key.length - node.key.length);\n\n          if (lastRoot) {\n            node.value = lastRoot;\n          }\n        } else if (node.type === 'branch') {\n          if (lastRoot) {\n            var branchKey = key.pop();\n            node.setValue(branchKey, lastRoot);\n          }\n        }\n\n        lastRoot = this._formatNode(node, stack.length === 0, opStack);\n      }\n\n      if (lastRoot) {\n        this.root = lastRoot;\n      }\n\n      this._batchNodes(opStack, cb);\n    }\n  }, {\n    key: \"_deleteNode\",\n    value: function _deleteNode(key, stack, cb) {\n      var _this3 = this;\n\n      function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n        // branchNode is the node ON the branch node not THE branch node\n        var branchNodeKey = branchNode.key;\n\n        if (!parentNode || parentNode.type === 'branch') {\n          // branch->?\n          if (parentNode) {\n            stack.push(parentNode);\n          }\n\n          if (branchNode.type === 'branch') {\n            // create an extention node\n            // branch->extention->branch\n            var extentionNode = new TrieNode('extention', [branchKey], null);\n            stack.push(extentionNode);\n            key.push(branchKey);\n          } else {\n            // branch key is an extention or a leaf\n            // branch->(leaf or extention)\n            branchNodeKey.unshift(branchKey);\n            branchNode.key = branchNodeKey; // hackery. This is equvilant to array.concat except we need keep the\n            // rerfance to the `key` that was passed in.\n\n            branchNodeKey.unshift(0);\n            branchNodeKey.unshift(key.length);\n            key.splice.apply(key, branchNodeKey);\n          }\n\n          stack.push(branchNode);\n        } else {\n          // parent is a extention\n          var parentKey = parentNode.key;\n\n          if (branchNode.type === 'branch') {\n            // ext->branch\n            parentKey.push(branchKey);\n            key.push(branchKey);\n            parentNode.key = parentKey;\n            stack.push(parentNode);\n          } else {\n            // branch node is an leaf or extention and parent node is an exstention\n            // add two keys together\n            // dont push the parent node\n            branchNodeKey.unshift(branchKey);\n            key = key.concat(branchNodeKey);\n            parentKey = parentKey.concat(branchNodeKey);\n            branchNode.key = parentKey;\n          }\n\n          stack.push(branchNode);\n        }\n\n        return key;\n      }\n\n      var lastNode = stack.pop();\n      var parentNode = stack.pop();\n      var opStack = [];\n\n      if (!Array.isArray(key)) {\n        // convert key to nibbles\n        key = TrieNode.stringToNibbles(key);\n      }\n\n      if (!parentNode) {\n        // the root here has to be a leaf.\n        this.root = this.EMPTY_TRIE_ROOT;\n        cb();\n      } else {\n        if (lastNode.type === 'branch') {\n          lastNode.value = null;\n        } else {\n          // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n          // if it has one must be a branch.\n          var lastNodeKey = lastNode.key;\n          key.splice(key.length - lastNodeKey.length); // delete the value\n\n          this._formatNode(lastNode, false, true, opStack);\n\n          parentNode.setValue(key.pop(), null);\n          lastNode = parentNode;\n          parentNode = stack.pop();\n        } // nodes on the branch\n\n\n        var branchNodes = []; // count the number of nodes on the branch\n\n        lastNode.raw.forEach(function (node, i) {\n          var val = lastNode.getValue(i);\n\n          if (val) {\n            branchNodes.push([i, val]);\n          }\n        }); // if there is only one branch node left, collapse the branch node\n\n        if (branchNodes.length === 1) {\n          // add the one remaing branch node to node above it\n          var branchNode = branchNodes[0][1];\n          var branchNodeKey = branchNodes[0][0]; // look up node\n\n          this._lookupNode(branchNode, function (foundNode) {\n            key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n\n            _this3._saveStack(key, stack, opStack, cb);\n          });\n        } else {\n          // simple removing a leaf and recaluclation the stack\n          if (parentNode) {\n            stack.push(parentNode);\n          }\n\n          stack.push(lastNode);\n\n          this._saveStack(key, stack, opStack, cb);\n        }\n      }\n    } // Creates the initial node from an empty tree\n\n  }, {\n    key: \"_createInitialNode\",\n    value: function _createInitialNode(key, value, cb) {\n      var newNode = new TrieNode('leaf', key, value);\n      this.root = newNode.hash();\n\n      this._putNode(newNode, cb);\n    } // formats node to be saved by levelup.batch.\n    // returns either the hash that will be used key or the rawNode\n\n  }, {\n    key: \"_formatNode\",\n    value: function _formatNode(node, topLevel, remove, opStack) {\n      if (arguments.length === 3) {\n        opStack = remove;\n        remove = false;\n      }\n\n      var rlpNode = node.serialize();\n\n      if (rlpNode.length >= 32 || topLevel) {\n        var hashRoot = node.hash();\n\n        if (remove && this.isCheckpoint) {\n          opStack.push({\n            type: 'del',\n            key: hashRoot\n          });\n        } else {\n          opStack.push({\n            type: 'put',\n            key: hashRoot,\n            value: rlpNode\n          });\n        }\n\n        return hashRoot;\n      }\n\n      return node.raw;\n    }\n    /**\n     * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n     * @method createReadStream\n     * @memberof Trie\n     * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n     */\n\n  }, {\n    key: \"createReadStream\",\n    value: function createReadStream() {\n      return new ReadStream(this);\n    } // creates a new trie backed by the same db\n    // and starting at the same root\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Trie(this.db, this.root);\n    }\n    /**\n     * The given hash of operations (key additions or deletions) are executed on the DB\n     * @method batch\n     * @memberof Trie\n     * @example\n     * var ops = [\n     *    { type: 'del', key: 'father' }\n     *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n     *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n     *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n     *  , { type: 'put', key: 'occupation', value: 'Clown' }\n     * ]\n     * trie.batch(ops)\n     * @param {Array} ops\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(ops, cb) {\n      var _this4 = this;\n\n      async.eachSeries(ops, function (op, cb2) {\n        if (op.type === 'put') {\n          _this4.put(op.key, op.value, cb2);\n        } else if (op.type === 'del') {\n          _this4.del(op.key, cb2);\n        } else {\n          cb2();\n        }\n      }, cb);\n    }\n    /**\n     * Checks if a given root exists\n     * @method checkRoot\n     * @memberof Trie\n     * @param {Buffer} root\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"checkRoot\",\n    value: function checkRoot(root, cb) {\n      root = ethUtil.toBuffer(root);\n\n      this._lookupNode(root, function (value) {\n        cb(null, !!value);\n      });\n    }\n  }]);\n\n  return Trie;\n}();","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","assert","require","level","async","rlp","ethUtil","semaphore","TrieNode","ReadStream","PrioritizedTaskExecutor","matchingNibbleLength","doKeysMatch","callTogether","asyncFirstSeries","module","exports","Trie","db","root","self","EMPTY_TRIE_ROOT","SHA3_RLP","sem","_getDBs","_putDBs","set","value","toBuffer","_root","get","putRaw","_putRaw","cb","findPath","err","node","remainder","stack","put","_this","toString","del","leave","take","foundValue","keyRemainder","_updateNode","_createInitialNode","_this2","_deleteNode","getRaw","dbGet","cb2","keyEncoding","valueEncoding","foundNode","_lookupNode","isRawNode","decode","val","dbPut","each","delRaw","_putNode","hash","serialized","serialize","_batchNodes","opStack","dbBatch","batch","targetKey","stringToNibbles","_walkTrie","processNode","nodeRef","keyProgress","walkController","nodeKey","slice","matchingLen","push","type","return","branchIndex","branchNode","getValue","only","next","_findNode","_arguments","arguments","apply","_findValueNodes","onFound","fullKey","concat","_findDbNodes","toSave","lastNode","pop","matchLeaf","l","n","shift","newLeaf","lastKey","matchingLength","newBranchNode","newKey","newExtNode","splice","branchKey","formatedNode","_formatNode","setValue","newLeafNode","_saveStack","onNode","onDone","aborted","returnValues","maxPoolSize","taskExecutor","stopped","stop","_return","children","getChildren","forEachOf","childData","index","keyExtension","childRef","childKey","priority","execute","taskCallback","childNode","childIndex","lastRoot","_this3","processBranchNode","parentNode","branchNodeKey","extentionNode","unshift","parentKey","Array","isArray","lastNodeKey","branchNodes","raw","forEach","newNode","topLevel","remove","rlpNode","hashRoot","isCheckpoint","createReadStream","copy","ops","_this4","eachSeries","op","checkRoot"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/merkle-patricia-tree/baseTrie.js"],"sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar assert = require('assert');\n\nvar level = require('level-mem');\n\nvar async = require('async');\n\nvar rlp = require('rlp');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar semaphore = require('semaphore');\n\nvar TrieNode = require('./trieNode');\n\nvar ReadStream = require('./readStream');\n\nvar PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\n\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\n\nvar doKeysMatch = require('./util').doKeysMatch;\n\nvar callTogether = require('./util').callTogether;\n\nvar asyncFirstSeries = require('./util').asyncFirstSeries;\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @public\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root] A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\n\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function Trie(db, root) {\n    _classCallCheck(this, Trie);\n\n    var self = this;\n    this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n    this.sem = semaphore(1); // setup dbs\n\n    this.db = db || level();\n    this._getDBs = [this.db];\n    this._putDBs = [this.db];\n    Object.defineProperty(this, 'root', {\n      set: function set(value) {\n        if (value) {\n          value = ethUtil.toBuffer(value);\n          assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n        } else {\n          value = self.EMPTY_TRIE_ROOT;\n        }\n\n        this._root = value;\n      },\n      get: function get() {\n        return this._root;\n      }\n    });\n    this.root = root;\n    this.putRaw = this._putRaw;\n  }\n  /**\n   * Gets a value given a `key`\n   * @method get\n   * @memberof Trie\n   * @param {Buffer|String} key - the key to search for\n   * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n   */\n\n\n  _createClass(Trie, [{\n    key: \"get\",\n    value: function get(key, cb) {\n      key = ethUtil.toBuffer(key);\n      this.findPath(key, function (err, node, remainder, stack) {\n        var value = null;\n\n        if (node && remainder.length === 0) {\n          value = node.value;\n        }\n\n        cb(err, value);\n      });\n    }\n    /**\n     * Stores a given `value` at the given `key`\n     * @method put\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Buffer|String} Value\n     * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, cb) {\n      var _this = this;\n\n      key = ethUtil.toBuffer(key);\n      value = ethUtil.toBuffer(value);\n\n      if (!value || value.toString() === '') {\n        this.del(key, cb);\n      } else {\n        cb = callTogether(cb, this.sem.leave);\n        this.sem.take(function () {\n          if (_this.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n            // first try to find the give key or its nearst node\n            _this.findPath(key, function (err, foundValue, keyRemainder, stack) {\n              if (err) {\n                return cb(err);\n              } // then update\n\n\n              _this._updateNode(key, value, keyRemainder, stack, cb);\n            });\n          } else {\n            _this._createInitialNode(key, value, cb); // if no root initialize this trie\n\n          }\n        });\n      }\n    }\n    /**\n     * deletes a value given a `key`\n     * @method del\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Function} callback the callback `Function`\n     */\n\n  }, {\n    key: \"del\",\n    value: function del(key, cb) {\n      var _this2 = this;\n\n      key = ethUtil.toBuffer(key);\n      cb = callTogether(cb, this.sem.leave);\n      this.sem.take(function () {\n        _this2.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (foundValue) {\n            _this2._deleteNode(key, stack, cb);\n          } else {\n            cb();\n          }\n        });\n      });\n    }\n    /**\n     * Retrieves a raw value in the underlying db\n     * @method getRaw\n     * @memberof Trie\n     * @param {Buffer} key\n     * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n     */\n\n  }, {\n    key: \"getRaw\",\n    value: function getRaw(key, cb) {\n      key = ethUtil.toBuffer(key);\n\n      function dbGet(db, cb2) {\n        db.get(key, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, function (err, foundNode) {\n          if (err || !foundNode) {\n            cb2(null, null);\n          } else {\n            cb2(null, foundNode);\n          }\n        });\n      }\n\n      asyncFirstSeries(this._getDBs, dbGet, cb);\n    } // retrieves a node from dbs by hash\n\n  }, {\n    key: \"_lookupNode\",\n    value: function _lookupNode(node, cb) {\n      if (TrieNode.isRawNode(node)) {\n        cb(new TrieNode(node));\n      } else {\n        this.getRaw(node, function (err, value) {\n          if (err) {\n            throw err;\n          }\n\n          if (value) {\n            value = new TrieNode(rlp.decode(value));\n          }\n\n          cb(value);\n        });\n      }\n    }\n    /**\n     * Writes a value directly to the underlining db\n     * @method putRaw\n     * @memberof Trie\n     * @param {Buffer|String} key The key as a `Buffer` or `String`\n     * @param {Buffer} value The value to be stored\n     * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n     */\n    // TODO: remove the proxy method when changing the caching\n\n  }, {\n    key: \"_putRaw\",\n    value: function _putRaw(key, val, cb) {\n      function dbPut(db, cb2) {\n        db.put(key, val, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, cb2);\n      }\n\n      async.each(this._putDBs, dbPut, cb);\n    }\n    /**\n     * Removes a raw value in the underlying db\n     * @method delRaw\n     * @memberof Trie\n     * @param {Buffer|String} key\n     * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n     */\n\n  }, {\n    key: \"delRaw\",\n    value: function delRaw(key, cb) {\n      function del(db, cb2) {\n        db.del(key, {\n          keyEncoding: 'binary'\n        }, cb2);\n      }\n\n      async.each(this._putDBs, del, cb);\n    } // writes a single node to dbs\n\n  }, {\n    key: \"_putNode\",\n    value: function _putNode(node, cb) {\n      var hash = node.hash();\n      var serialized = node.serialize();\n\n      this._putRaw(hash, serialized, cb);\n    } // writes many nodes to db\n\n  }, {\n    key: \"_batchNodes\",\n    value: function _batchNodes(opStack, cb) {\n      function dbBatch(db, cb) {\n        db.batch(opStack, {\n          keyEncoding: 'binary',\n          valueEncoding: 'binary'\n        }, cb);\n      }\n\n      async.each(this._putDBs, dbBatch, cb);\n    }\n    /**\n     * Tries to find a path to the node for the given key\n     * It returns a `stack` of nodes to the closet node\n     * @method findPath\n     * @memberof Trie\n     * @param {String|Buffer} - key - the search key\n     * @param {Function} - cb - the callback function. Its is given the following\n     * arguments\n     *  - err - any errors encontered\n     *  - node - the last node found\n     *  - keyRemainder - the remaining key nibbles not accounted for\n     *  - stack - an array of nodes that forms the path to node we are searching for\n     */\n\n  }, {\n    key: \"findPath\",\n    value: function findPath(targetKey, cb) {\n      var stack = [];\n      targetKey = TrieNode.stringToNibbles(targetKey);\n\n      this._walkTrie(this.root, processNode, cb);\n\n      function processNode(nodeRef, node, keyProgress, walkController) {\n        var nodeKey = node.key || [];\n        var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n        var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n        stack.push(node);\n\n        if (node.type === 'branch') {\n          if (keyRemainder.length === 0) {\n            walkController.return(null, node, [], stack); // we exhausted the key without finding a node\n          } else {\n            var branchIndex = keyRemainder[0];\n            var branchNode = node.getValue(branchIndex);\n\n            if (!branchNode) {\n              // there are no more nodes to find and we didn't find the key\n              walkController.return(null, null, keyRemainder, stack);\n            } else {\n              // node found, continuing search\n              walkController.only(branchIndex);\n            }\n          }\n        } else if (node.type === 'leaf') {\n          if (doKeysMatch(keyRemainder, nodeKey)) {\n            // keys match, return node with empty key\n            walkController.return(null, node, [], stack);\n          } else {\n            // reached leaf but keys dont match\n            walkController.return(null, null, keyRemainder, stack);\n          }\n        } else if (node.type === 'extention') {\n          if (matchingLen !== nodeKey.length) {\n            // keys dont match, fail\n            walkController.return(null, null, keyRemainder, stack);\n          } else {\n            // keys match, continue search\n            walkController.next();\n          }\n        }\n      }\n    }\n    /*\n     * Finds all nodes that store k,v values\n     */\n\n  }, {\n    key: \"_findNode\",\n    value: function _findNode(key, root, stack, cb) {\n      var _arguments = arguments;\n      this.findPath(key, function () {\n        cb.apply(null, _arguments);\n      });\n    }\n    /*\n     * Finds all nodes that store k,v values\n     */\n\n  }, {\n    key: \"_findValueNodes\",\n    value: function _findValueNodes(onFound, cb) {\n      this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n        var fullKey = key;\n\n        if (node.key) {\n          fullKey = key.concat(node.key);\n        }\n\n        if (node.type === 'leaf') {\n          // found leaf node!\n          onFound(nodeRef, node, fullKey, walkController.next);\n        } else if (node.type === 'branch' && node.value) {\n          // found branch with value\n          onFound(nodeRef, node, fullKey, walkController.next);\n        } else {\n          // keep looking for value nodes\n          walkController.next();\n        }\n      }, cb);\n    }\n    /*\n     * Finds all nodes that are stored directly in the db\n     * (some nodes are stored raw inside other nodes)\n     */\n\n  }, {\n    key: \"_findDbNodes\",\n    value: function _findDbNodes(onFound, cb) {\n      this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n        if (TrieNode.isRawNode(nodeRef)) {\n          walkController.next();\n        } else {\n          onFound(nodeRef, node, key, walkController.next);\n        }\n      }, cb);\n    }\n    /**\n     * Updates a node\n     * @method _updateNode\n     * @private\n     * @param {Buffer} key\n     * @param {Buffer| String} value\n     * @param {Array} keyRemainder\n     * @param {Array} stack -\n     * @param {Function} cb - the callback\n     */\n\n  }, {\n    key: \"_updateNode\",\n    value: function _updateNode(key, value, keyRemainder, stack, cb) {\n      var toSave = [];\n      var lastNode = stack.pop(); // add the new nodes\n\n      key = TrieNode.stringToNibbles(key); // Check if the last node is a leaf and the key matches to this\n\n      var matchLeaf = false;\n\n      if (lastNode.type === 'leaf') {\n        var l = 0;\n\n        for (var i = 0; i < stack.length; i++) {\n          var n = stack[i];\n\n          if (n.type === 'branch') {\n            l++;\n          } else {\n            l += n.key.length;\n          }\n        }\n\n        if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n          matchLeaf = true;\n        }\n      }\n\n      if (matchLeaf) {\n        // just updating a found value\n        lastNode.value = value;\n        stack.push(lastNode);\n      } else if (lastNode.type === 'branch') {\n        stack.push(lastNode);\n\n        if (keyRemainder !== 0) {\n          // add an extention to a branch node\n          keyRemainder.shift(); // create a new leaf\n\n          var newLeaf = new TrieNode('leaf', keyRemainder, value);\n          stack.push(newLeaf);\n        } else {\n          lastNode.value = value;\n        }\n      } else {\n        // create a branch node\n        var lastKey = lastNode.key;\n        var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n        var newBranchNode = new TrieNode('branch'); // create a new extention node\n\n        if (matchingLength !== 0) {\n          var newKey = lastNode.key.slice(0, matchingLength);\n          var newExtNode = new TrieNode('extention', newKey, value);\n          stack.push(newExtNode);\n          lastKey.splice(0, matchingLength);\n          keyRemainder.splice(0, matchingLength);\n        }\n\n        stack.push(newBranchNode);\n\n        if (lastKey.length !== 0) {\n          var branchKey = lastKey.shift();\n\n          if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n            // shriking extention or leaf\n            lastNode.key = lastKey;\n\n            var formatedNode = this._formatNode(lastNode, false, toSave);\n\n            newBranchNode.setValue(branchKey, formatedNode);\n          } else {\n            // remove extention or attaching\n            this._formatNode(lastNode, false, true, toSave);\n\n            newBranchNode.setValue(branchKey, lastNode.value);\n          }\n        } else {\n          newBranchNode.value = lastNode.value;\n        }\n\n        if (keyRemainder.length !== 0) {\n          keyRemainder.shift(); // add a leaf node to the new branch node\n\n          var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n          stack.push(newLeafNode);\n        } else {\n          newBranchNode.value = value;\n        }\n      }\n\n      this._saveStack(key, stack, toSave, cb);\n    } // walk tree\n\n  }, {\n    key: \"_walkTrie\",\n    value: function _walkTrie(root, onNode, onDone) {\n      var self = this;\n      root = root || this.root;\n\n      onDone = onDone || function () {};\n\n      var aborted = false;\n      var returnValues = [];\n\n      if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n        return onDone();\n      }\n\n      this._lookupNode(root, function (node) {\n        processNode(root, node, null, function (err) {\n          if (err) {\n            return onDone(err);\n          }\n\n          onDone.apply(null, returnValues);\n        });\n      }); // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n      // low enough to utilize the prioritisation of node lookup.\n\n\n      var maxPoolSize = 500;\n      var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n\n      function processNode(nodeRef, node, key, cb) {\n        if (!node || aborted) {\n          return cb();\n        }\n\n        var stopped = false;\n        key = key || [];\n        var walkController = {\n          stop: function stop() {\n            stopped = true;\n            cb();\n          },\n          // end all traversal and return values to the onDone cb\n          return: function _return() {\n            aborted = true;\n            returnValues = arguments;\n            cb();\n          },\n          next: function next() {\n            if (aborted || stopped) {\n              return cb();\n            }\n\n            var children = node.getChildren();\n            async.forEachOf(children, function (childData, index, cb) {\n              var keyExtension = childData[0];\n              var childRef = childData[1];\n              var childKey = key.concat(keyExtension);\n              var priority = childKey.length;\n              taskExecutor.execute(priority, function (taskCallback) {\n                self._lookupNode(childRef, function (childNode) {\n                  taskCallback();\n                  processNode(childRef, childNode, childKey, cb);\n                });\n              });\n            }, cb);\n          },\n          only: function only(childIndex) {\n            var childRef = node.getValue(childIndex);\n            var childKey = key.slice();\n            childKey.push(childIndex);\n            var priority = childKey.length;\n            taskExecutor.execute(priority, function (taskCallback) {\n              self._lookupNode(childRef, function (childNode) {\n                taskCallback();\n                processNode(childRef, childNode, childKey, cb);\n              });\n            });\n          }\n        };\n        onNode(nodeRef, node, key, walkController);\n      }\n    }\n    /**\n     * saves a stack\n     * @method _saveStack\n     * @private\n     * @param {Array} key - the key. Should follow the stack\n     * @param {Array} stack - a stack of nodes to the value given by the key\n     * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"_saveStack\",\n    value: function _saveStack(key, stack, opStack, cb) {\n      var lastRoot; // update nodes\n\n      while (stack.length) {\n        var node = stack.pop();\n\n        if (node.type === 'leaf') {\n          key.splice(key.length - node.key.length);\n        } else if (node.type === 'extention') {\n          key.splice(key.length - node.key.length);\n\n          if (lastRoot) {\n            node.value = lastRoot;\n          }\n        } else if (node.type === 'branch') {\n          if (lastRoot) {\n            var branchKey = key.pop();\n            node.setValue(branchKey, lastRoot);\n          }\n        }\n\n        lastRoot = this._formatNode(node, stack.length === 0, opStack);\n      }\n\n      if (lastRoot) {\n        this.root = lastRoot;\n      }\n\n      this._batchNodes(opStack, cb);\n    }\n  }, {\n    key: \"_deleteNode\",\n    value: function _deleteNode(key, stack, cb) {\n      var _this3 = this;\n\n      function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n        // branchNode is the node ON the branch node not THE branch node\n        var branchNodeKey = branchNode.key;\n\n        if (!parentNode || parentNode.type === 'branch') {\n          // branch->?\n          if (parentNode) {\n            stack.push(parentNode);\n          }\n\n          if (branchNode.type === 'branch') {\n            // create an extention node\n            // branch->extention->branch\n            var extentionNode = new TrieNode('extention', [branchKey], null);\n            stack.push(extentionNode);\n            key.push(branchKey);\n          } else {\n            // branch key is an extention or a leaf\n            // branch->(leaf or extention)\n            branchNodeKey.unshift(branchKey);\n            branchNode.key = branchNodeKey; // hackery. This is equvilant to array.concat except we need keep the\n            // rerfance to the `key` that was passed in.\n\n            branchNodeKey.unshift(0);\n            branchNodeKey.unshift(key.length);\n            key.splice.apply(key, branchNodeKey);\n          }\n\n          stack.push(branchNode);\n        } else {\n          // parent is a extention\n          var parentKey = parentNode.key;\n\n          if (branchNode.type === 'branch') {\n            // ext->branch\n            parentKey.push(branchKey);\n            key.push(branchKey);\n            parentNode.key = parentKey;\n            stack.push(parentNode);\n          } else {\n            // branch node is an leaf or extention and parent node is an exstention\n            // add two keys together\n            // dont push the parent node\n            branchNodeKey.unshift(branchKey);\n            key = key.concat(branchNodeKey);\n            parentKey = parentKey.concat(branchNodeKey);\n            branchNode.key = parentKey;\n          }\n\n          stack.push(branchNode);\n        }\n\n        return key;\n      }\n\n      var lastNode = stack.pop();\n      var parentNode = stack.pop();\n      var opStack = [];\n\n      if (!Array.isArray(key)) {\n        // convert key to nibbles\n        key = TrieNode.stringToNibbles(key);\n      }\n\n      if (!parentNode) {\n        // the root here has to be a leaf.\n        this.root = this.EMPTY_TRIE_ROOT;\n        cb();\n      } else {\n        if (lastNode.type === 'branch') {\n          lastNode.value = null;\n        } else {\n          // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n          // if it has one must be a branch.\n          var lastNodeKey = lastNode.key;\n          key.splice(key.length - lastNodeKey.length); // delete the value\n\n          this._formatNode(lastNode, false, true, opStack);\n\n          parentNode.setValue(key.pop(), null);\n          lastNode = parentNode;\n          parentNode = stack.pop();\n        } // nodes on the branch\n\n\n        var branchNodes = []; // count the number of nodes on the branch\n\n        lastNode.raw.forEach(function (node, i) {\n          var val = lastNode.getValue(i);\n\n          if (val) {\n            branchNodes.push([i, val]);\n          }\n        }); // if there is only one branch node left, collapse the branch node\n\n        if (branchNodes.length === 1) {\n          // add the one remaing branch node to node above it\n          var branchNode = branchNodes[0][1];\n          var branchNodeKey = branchNodes[0][0]; // look up node\n\n          this._lookupNode(branchNode, function (foundNode) {\n            key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n\n            _this3._saveStack(key, stack, opStack, cb);\n          });\n        } else {\n          // simple removing a leaf and recaluclation the stack\n          if (parentNode) {\n            stack.push(parentNode);\n          }\n\n          stack.push(lastNode);\n\n          this._saveStack(key, stack, opStack, cb);\n        }\n      }\n    } // Creates the initial node from an empty tree\n\n  }, {\n    key: \"_createInitialNode\",\n    value: function _createInitialNode(key, value, cb) {\n      var newNode = new TrieNode('leaf', key, value);\n      this.root = newNode.hash();\n\n      this._putNode(newNode, cb);\n    } // formats node to be saved by levelup.batch.\n    // returns either the hash that will be used key or the rawNode\n\n  }, {\n    key: \"_formatNode\",\n    value: function _formatNode(node, topLevel, remove, opStack) {\n      if (arguments.length === 3) {\n        opStack = remove;\n        remove = false;\n      }\n\n      var rlpNode = node.serialize();\n\n      if (rlpNode.length >= 32 || topLevel) {\n        var hashRoot = node.hash();\n\n        if (remove && this.isCheckpoint) {\n          opStack.push({\n            type: 'del',\n            key: hashRoot\n          });\n        } else {\n          opStack.push({\n            type: 'put',\n            key: hashRoot,\n            value: rlpNode\n          });\n        }\n\n        return hashRoot;\n      }\n\n      return node.raw;\n    }\n    /**\n     * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n     * @method createReadStream\n     * @memberof Trie\n     * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n     */\n\n  }, {\n    key: \"createReadStream\",\n    value: function createReadStream() {\n      return new ReadStream(this);\n    } // creates a new trie backed by the same db\n    // and starting at the same root\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Trie(this.db, this.root);\n    }\n    /**\n     * The given hash of operations (key additions or deletions) are executed on the DB\n     * @method batch\n     * @memberof Trie\n     * @example\n     * var ops = [\n     *    { type: 'del', key: 'father' }\n     *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n     *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n     *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n     *  , { type: 'put', key: 'occupation', value: 'Clown' }\n     * ]\n     * trie.batch(ops)\n     * @param {Array} ops\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(ops, cb) {\n      var _this4 = this;\n\n      async.eachSeries(ops, function (op, cb2) {\n        if (op.type === 'put') {\n          _this4.put(op.key, op.value, cb2);\n        } else if (op.type === 'del') {\n          _this4.del(op.key, cb2);\n        } else {\n          cb2();\n        }\n      }, cb);\n    }\n    /**\n     * Checks if a given root exists\n     * @method checkRoot\n     * @memberof Trie\n     * @param {Buffer} root\n     * @param {Function} cb\n     */\n\n  }, {\n    key: \"checkRoot\",\n    value: function checkRoot(root, cb) {\n      root = ethUtil.toBuffer(root);\n\n      this._lookupNode(root, function (value) {\n        cb(null, !!value);\n      });\n    }\n  }]);\n\n  return Trie;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"script"}
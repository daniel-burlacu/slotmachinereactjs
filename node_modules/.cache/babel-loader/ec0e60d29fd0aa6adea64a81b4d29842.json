{"ast":null,"code":"\"use strict\";\n\nvar TrieNode = require('./trieNode');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\n/**\n * Returns a merkle proof for a given key\n * @method prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\n\n\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n\n    cb(null, p);\n  });\n};\n/**\n * Verifies a merkle proof for a given key\n * @method verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\n\n\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n\n        return cb(null, node.value);\n      }\n\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n\n        key = key.slice(embeddedNode.key.length);\n\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n\n      cld = node.value;\n      key = key.slice(node.key.length);\n\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n\n  cb(new Error('Unexpected end of proof'));\n};","map":{"version":3,"names":["TrieNode","require","ethUtil","matchingNibbleLength","exports","prove","trie","key","cb","nodes","findPath","err","node","remaining","stack","length","Error","p","i","rlpNode","serialize","push","verifyProof","rootHash","proof","stringToNibbles","wantHash","toBuffer","hash","sha3","Buffer","compare","rlp","decode","cld","type","value","raw","slice","embeddedNode"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/merkle-patricia-tree/proof.js"],"sourcesContent":["\"use strict\";\n\nvar TrieNode = require('./trieNode');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\n/**\n * Returns a merkle proof for a given key\n * @method prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\n\n\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n\n    cb(null, p);\n  });\n};\n/**\n * Verifies a merkle proof for a given key\n * @method verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\n\n\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n\n        return cb(null, node.value);\n      }\n\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n\n        key = key.slice(embeddedNode.key.length);\n\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n\n      cld = node.value;\n      key = key.slice(node.key.length);\n\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n\n  cb(new Error('Unexpected end of proof'));\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
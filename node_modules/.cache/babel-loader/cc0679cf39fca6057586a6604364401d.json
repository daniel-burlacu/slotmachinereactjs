{"ast":null,"code":"// It's unforutnate we have to have this subprovider, but it's because\n// we instamine, and web3 isn't written in a way that supports instamining\n// (i.e., it sets up the filter after the transaction has been processed).\n// This block filter will ensure that each block filter will always see\n// the change from the last block to the current block.\n//\n// Note: An added benefit of this is that it shaves off a signifcant\n// amount of time from tests that use web3 and block filters.\nvar Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\n\nvar inherits = require(\"util\").inherits;\n\nvar async = require(\"async\");\n\nvar to = require(\"../utils/to\");\n\ninherits(DelayedBlockFilter, Subprovider);\nmodule.exports = DelayedBlockFilter;\n\nfunction DelayedBlockFilter() {\n  this.watching = {};\n}\n\nDelayedBlockFilter.prototype.handleRequest = function (payload, next, end) {\n  if (payload.method === \"eth_newBlockFilter\") {\n    return this.handleNewBlockFilter(payload, next, end);\n  }\n\n  if (payload.method === \"eth_getFilterChanges\") {\n    return this.handleGetFilterChanges(payload, next, end);\n  }\n\n  next();\n};\n\nDelayedBlockFilter.prototype.handleNewBlockFilter = function (payload, next, end) {\n  var self = this; // Let this filter process and add it to our watch list.\n\n  next(function (err, result, cb) {\n    if (err) {\n      return cb();\n    }\n\n    self.watching[result] = true;\n    cb();\n  });\n};\n\nDelayedBlockFilter.prototype.handleGetFilterChanges = function (payload, next, end) {\n  var self = this;\n  var filterId = payload.params[0];\n\n  if (!this.watching[filterId]) {\n    return next();\n  } // Get the changes, and then alter the result.\n\n\n  next(function (err, result, cb) {\n    if (err) {\n      return cb();\n    }\n\n    var currentBlockHash;\n    var previousBlockHash;\n    var blockNumber;\n    async.series([function (c) {\n      // If we have a result, use it.\n      if (result.length !== 0) {\n        currentBlockHash = result[0];\n        c();\n      } else {\n        // Otherwise, get the current block number.\n        self.emitPayload({\n          method: \"eth_blockNumber\"\n        }, function (err, res) {\n          if (err) {\n            return c(err);\n          }\n\n          blockNumber = to.number(res.result);\n          c();\n        });\n      }\n    }, function (c) {\n      // If we got a block number above, meaning, we didn't get a block hash,\n      // skip this step.\n      if (blockNumber) {\n        return c();\n      } // If not skipped, then we got a block hash, and we need to get a block number from it.\n\n\n      self.emitPayload({\n        method: \"eth_getBlockByHash\",\n        params: [currentBlockHash, false]\n      }, function (err, res) {\n        if (err) {\n          return c(err);\n        }\n\n        blockNumber = to.number(res.result.number);\n        c();\n      });\n    }, function (c) {\n      // If we're at block 0, return no changes. See final function below.\n      blockNumber = to.number(blockNumber);\n\n      if (blockNumber === 0) {\n        previousBlockHash = undefined;\n        return c();\n      } // If at this point, we do have a block number, so let's subtract one\n      // from it and get the block hash of the block before it.\n\n\n      blockNumber = blockNumber - 1;\n      self.emitPayload({\n        method: \"eth_getBlockByNumber\",\n        params: [blockNumber, false]\n      }, function (err, res) {\n        if (err) {\n          return c(err);\n        }\n\n        previousBlockHash = res.result.hash;\n        c();\n      });\n    }], function (err) {\n      if (err) {// Unfortunately the subprovider code doesn't let us return an error\n        // through the callback cb(). So we'll just ignore it.... (famous last words).\n      } // If we got the previous block, use it. Otherwise do nothing.\n      // Then stop watching because we only want on getFilterChanges to react this way.\n\n\n      if (previousBlockHash) {\n        result[0] = previousBlockHash;\n      }\n\n      delete self.watching[filterId];\n      cb();\n    });\n  });\n};","map":{"version":3,"names":["Subprovider","require","inherits","async","to","DelayedBlockFilter","module","exports","watching","prototype","handleRequest","payload","next","end","method","handleNewBlockFilter","handleGetFilterChanges","self","err","result","cb","filterId","params","currentBlockHash","previousBlockHash","blockNumber","series","c","length","emitPayload","res","number","undefined","hash"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/subproviders/delayedblockfilter.js"],"sourcesContent":["// It's unforutnate we have to have this subprovider, but it's because\n// we instamine, and web3 isn't written in a way that supports instamining\n// (i.e., it sets up the filter after the transaction has been processed).\n// This block filter will ensure that each block filter will always see\n// the change from the last block to the current block.\n//\n// Note: An added benefit of this is that it shaves off a signifcant\n// amount of time from tests that use web3 and block filters.\n\nvar Subprovider = require(\"web3-provider-engine/subproviders/subprovider.js\");\nvar inherits = require(\"util\").inherits;\nvar async = require(\"async\");\nvar to = require(\"../utils/to\");\n\ninherits(DelayedBlockFilter, Subprovider);\n\nmodule.exports = DelayedBlockFilter;\n\nfunction DelayedBlockFilter() {\n  this.watching = {};\n}\n\nDelayedBlockFilter.prototype.handleRequest = function(payload, next, end) {\n  if (payload.method === \"eth_newBlockFilter\") {\n    return this.handleNewBlockFilter(payload, next, end);\n  }\n  if (payload.method === \"eth_getFilterChanges\") {\n    return this.handleGetFilterChanges(payload, next, end);\n  }\n\n  next();\n};\n\nDelayedBlockFilter.prototype.handleNewBlockFilter = function(payload, next, end) {\n  var self = this;\n\n  // Let this filter process and add it to our watch list.\n  next(function(err, result, cb) {\n    if (err) {\n      return cb();\n    }\n    self.watching[result] = true;\n    cb();\n  });\n};\n\nDelayedBlockFilter.prototype.handleGetFilterChanges = function(payload, next, end) {\n  var self = this;\n  var filterId = payload.params[0];\n\n  if (!this.watching[filterId]) {\n    return next();\n  }\n\n  // Get the changes, and then alter the result.\n  next(function(err, result, cb) {\n    if (err) {\n      return cb();\n    }\n\n    var currentBlockHash;\n    var previousBlockHash;\n    var blockNumber;\n\n    async.series(\n      [\n        function(c) {\n          // If we have a result, use it.\n          if (result.length !== 0) {\n            currentBlockHash = result[0];\n            c();\n          } else {\n            // Otherwise, get the current block number.\n            self.emitPayload(\n              {\n                method: \"eth_blockNumber\"\n              },\n              function(err, res) {\n                if (err) {\n                  return c(err);\n                }\n                blockNumber = to.number(res.result);\n                c();\n              }\n            );\n          }\n        },\n        function(c) {\n          // If we got a block number above, meaning, we didn't get a block hash,\n          // skip this step.\n          if (blockNumber) {\n            return c();\n          }\n\n          // If not skipped, then we got a block hash, and we need to get a block number from it.\n          self.emitPayload(\n            {\n              method: \"eth_getBlockByHash\",\n              params: [currentBlockHash, false]\n            },\n            function(err, res) {\n              if (err) {\n                return c(err);\n              }\n              blockNumber = to.number(res.result.number);\n              c();\n            }\n          );\n        },\n        function(c) {\n          // If we're at block 0, return no changes. See final function below.\n          blockNumber = to.number(blockNumber);\n          if (blockNumber === 0) {\n            previousBlockHash = undefined;\n            return c();\n          }\n\n          // If at this point, we do have a block number, so let's subtract one\n          // from it and get the block hash of the block before it.\n          blockNumber = blockNumber - 1;\n          self.emitPayload(\n            {\n              method: \"eth_getBlockByNumber\",\n              params: [blockNumber, false]\n            },\n            function(err, res) {\n              if (err) {\n                return c(err);\n              }\n              previousBlockHash = res.result.hash;\n              c();\n            }\n          );\n        }\n      ],\n      function(err) {\n        if (err) {\n          // Unfortunately the subprovider code doesn't let us return an error\n          // through the callback cb(). So we'll just ignore it.... (famous last words).\n        }\n\n        // If we got the previous block, use it. Otherwise do nothing.\n        // Then stop watching because we only want on getFilterChanges to react this way.\n        if (previousBlockHash) {\n          result[0] = previousBlockHash;\n        }\n\n        delete self.watching[filterId];\n        cb();\n      }\n    );\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = require(\"./comments\"),\n    isBlockComment = _require.isBlockComment,\n    hasLeadingComment = _require.hasLeadingComment;\n\nvar _require2 = require(\"../doc\"),\n    _require2$builders = _require2.builders,\n    indent = _require2$builders.indent,\n    join = _require2$builders.join,\n    hardline = _require2$builders.hardline,\n    softline = _require2$builders.softline,\n    literalline = _require2$builders.literalline,\n    concat = _require2$builders.concat,\n    group = _require2$builders.group,\n    dedentToRoot = _require2$builders.dedentToRoot,\n    _require2$utils = _require2.utils,\n    mapDoc = _require2$utils.mapDoc,\n    stripTrailingHardline = _require2$utils.stripTrailingHardline;\n\nfunction embed(path, print, textToDoc, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n\n  switch (node.type) {\n    case \"TemplateLiteral\":\n      {\n        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n          return isIt(path);\n        });\n\n        if (isCss) {\n          // Get full template literal with expressions replaced by placeholders\n          var rawQuasis = node.quasis.map(function (q) {\n            return q.value.raw;\n          });\n          var placeholderID = 0;\n          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n            return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n          }, \"\");\n          var doc = textToDoc(text, {\n            parser: \"css\"\n          });\n          return transformCssDoc(doc, path, print);\n        }\n        /*\n         * react-relay and graphql-tag\n         * graphql`...`\n         * graphql.experimental`...`\n         * gql`...`\n         *\n         * This intentionally excludes Relay Classic tags, as Prettier does not\n         * support Relay Classic formatting.\n         */\n\n\n        if (isGraphQL(path)) {\n          var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n          var numQuasis = node.quasis.length;\n\n          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n            return \"``\";\n          }\n\n          var parts = [];\n\n          for (var i = 0; i < numQuasis; i++) {\n            var templateElement = node.quasis[i];\n            var isFirst = i === 0;\n            var isLast = i === numQuasis - 1;\n            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n            // (which would make the `cooked` value be `null` or `undefined`)\n\n            if (typeof _text !== \"string\") {\n              return null;\n            }\n\n            var lines = _text.split(\"\\n\");\n\n            var numLines = lines.length;\n            var expressionDoc = expressionDocs[i];\n            var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n            var commentsAndWhitespaceOnly = lines.every(function (line) {\n              return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n            }); // Bail out if an interpolation occurs within a comment.\n\n            if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n              return null;\n            }\n\n            var _doc = null;\n\n            if (commentsAndWhitespaceOnly) {\n              _doc = printGraphqlComments(lines);\n            } else {\n              _doc = stripTrailingHardline(textToDoc(_text, {\n                parser: \"graphql\"\n              }));\n            }\n\n            if (_doc) {\n              _doc = escapeTemplateCharacters(_doc, false);\n\n              if (!isFirst && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              parts.push(_doc);\n\n              if (!isLast && endsWithBlankLine) {\n                parts.push(\"\");\n              }\n            } else if (!isFirst && !isLast && startsWithBlankLine) {\n              parts.push(\"\");\n            }\n\n            if (expressionDoc) {\n              parts.push(concat([\"${\", expressionDoc, \"}\"]));\n            }\n          }\n\n          return concat([\"`\", indent(concat([hardline, join(hardline, parts)])), hardline, \"`\"]);\n        }\n\n        var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n        if (htmlParser) {\n          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n        }\n\n        break;\n      }\n\n    case \"TemplateElement\":\n      {\n        /**\n         * md`...`\n         * markdown`...`\n         */\n        if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n            return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n          });\n\n          var indentation = getIndentation(_text2);\n          var hasIndent = indentation !== \"\";\n          return concat([hasIndent ? indent(concat([softline, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat([literalline, dedentToRoot(printMarkdown(_text2))]), softline]);\n        }\n\n        break;\n      }\n  }\n\n  function printMarkdown(text) {\n    var doc = textToDoc(text, {\n      parser: \"markdown\",\n      __inJsTemplate: true\n    });\n    return stripTrailingHardline(escapeTemplateCharacters(doc, true));\n  }\n}\n\nfunction getIndentation(str) {\n  var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n}\n\nfunction uncook(cookedValue) {\n  return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n}\n\nfunction escapeTemplateCharacters(doc, raw) {\n  return mapDoc(doc, function (currentDoc) {\n    if (!currentDoc.parts) {\n      return currentDoc;\n    }\n\n    var parts = [];\n    currentDoc.parts.forEach(function (part) {\n      if (typeof part === \"string\") {\n        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n      } else {\n        parts.push(part);\n      }\n    });\n    return Object.assign({}, currentDoc, {\n      parts: parts\n    });\n  });\n}\n\nfunction transformCssDoc(quasisDoc, path, print) {\n  var parentNode = path.getValue();\n  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n  if (isEmpty) {\n    return \"``\";\n  }\n\n  var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n  /* istanbul ignore if */\n\n  if (!newDoc) {\n    throw new Error(\"Couldn't insert all the expressions\");\n  }\n\n  return concat([\"`\", indent(concat([hardline, stripTrailingHardline(newDoc)])), softline, \"`\"]);\n} // Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\n\n\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  var expressions = expressionDocs.slice();\n  var replaceCounter = 0;\n  var newDoc = mapDoc(quasisDoc, function (doc) {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n\n    var parts = doc.parts;\n    var atIndex = parts.indexOf(\"@\");\n    var placeholderIndex = atIndex + 1;\n\n    if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n      // If placeholder is split, join it\n      var at = parts[atIndex];\n      var placeholder = parts[placeholderIndex];\n      var rest = parts.slice(placeholderIndex + 1);\n      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n    }\n\n    var atPlaceholderIndex = parts.findIndex(function (part) {\n      return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n    });\n\n    if (atPlaceholderIndex > -1) {\n      var _placeholder = parts[atPlaceholderIndex];\n\n      var _rest = parts.slice(atPlaceholderIndex + 1);\n\n      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n      // animation: linear ${time}s ease-out;\n\n      var suffix = placeholderMatch[2];\n      var expression = expressions[placeholderID];\n      replaceCounter++;\n      parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n    }\n\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n\nfunction printGraphqlComments(lines) {\n  var parts = [];\n  var seenComment = false;\n  lines.map(function (textLine) {\n    return textLine.trim();\n  }).forEach(function (textLine, i, array) {\n    // Lines are either whitespace only, or a comment (with poential whitespace\n    // around it). Drop whitespace-only lines.\n    if (textLine === \"\") {\n      return;\n    }\n\n    if (array[i - 1] === \"\" && seenComment) {\n      // If a non-first comment is preceded by a blank (whitespace only) line,\n      // add in a blank line.\n      parts.push(concat([hardline, textLine]));\n    } else {\n      parts.push(textLine);\n    }\n\n    seenComment = true;\n  }); // If `lines` was whitespace only, return `null`.\n\n  return parts.length === 0 ? null : join(hardline, parts);\n}\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\n\n\nfunction isStyledJsx(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n    return attribute.name.name === \"jsx\";\n  }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n}\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\n\n\nfunction isAngularComponentStyles(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"ArrayExpression\" && name === \"elements\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction isAngularComponentTemplate(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction getAngularComponentObjectExpressionPredicates() {\n  return [function (node, name) {\n    return node.type === \"ObjectExpression\" && name === \"properties\";\n  }, function (node, name) {\n    return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n  }, function (node, name) {\n    return node.type === \"Decorator\" && name === \"expression\";\n  }];\n}\n/**\n * styled-components template literals\n */\n\n\nfunction isStyledComponents(path) {\n  var parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  var tag = parent.tag;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (// styled.foo``\n        isStyledIdentifier(tag.object) || // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (// styled(Component)``\n        isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n        tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n/**\n * JSX element with CSS prop\n */\n\n\nfunction isCssProp(path) {\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\n\n\nfunction isGraphQL(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasLeadingComment(node, function (comment) {\n    return isBlockComment(comment) && comment.value === \" \".concat(languageName, \" \");\n  });\n}\n\nfunction isPathMatch(path, predicateStack) {\n  var stack = path.stack.slice();\n  var name = null;\n  var node = stack.pop();\n\n  var _iterator = _createForOfIteratorHelper(predicateStack),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var predicate = _step.value;\n\n      if (node === undefined) {\n        return false;\n      } // skip index/array\n\n\n      if (typeof name === \"number\") {\n        name = stack.pop();\n        node = stack.pop();\n      }\n\n      if (!predicate(node, name)) {\n        return false;\n      }\n\n      name = stack.pop();\n      node = stack.pop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n}\n/**\n *     - html`...`\n *     - HTML comment block\n */\n\n\nfunction isHtml(path) {\n  var node = path.getValue();\n  return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n  }]);\n} // The counter is needed to distinguish nested embeds.\n\n\nvar htmlTemplateLiteralCounter = 0;\n\nfunction printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n  var node = path.getValue();\n  var counter = htmlTemplateLiteralCounter;\n  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n  var composePlaceholder = function composePlaceholder(index) {\n    return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n  };\n\n  var text = node.quasis.map(function (quasi, index, quasis) {\n    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n  }).join(\"\");\n  var expressionDocs = path.map(print, \"expressions\");\n\n  if (expressionDocs.length === 0 && text.trim().length === 0) {\n    return \"``\";\n  }\n\n  var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n  var contentDoc = mapDoc(stripTrailingHardline(textToDoc(text, {\n    parser: parser\n  })), function (doc) {\n    if (typeof doc !== \"string\") {\n      return doc;\n    }\n\n    var parts = [];\n    var components = doc.split(placeholderRegex);\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (i % 2 === 0) {\n        if (component) {\n          component = uncook(component);\n\n          if (escapeClosingScriptTag) {\n            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n          }\n\n          parts.push(component);\n        }\n\n        continue;\n      }\n\n      var placeholderIndex = +component;\n      parts.push(concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"]));\n    }\n\n    return concat(parts);\n  });\n  return group(concat([\"`\", indent(concat([hardline, group(contentDoc)])), softline, \"`\"]));\n}\n\nmodule.exports = embed;","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","_require","require","isBlockComment","hasLeadingComment","_require2","_require2$builders","builders","indent","join","hardline","softline","literalline","concat","group","dedentToRoot","_require2$utils","utils","mapDoc","stripTrailingHardline","embed","path","print","textToDoc","options","node","getValue","parent","getParentNode","parentParent","type","isCss","isStyledJsx","isStyledComponents","isCssProp","isAngularComponentStyles","some","isIt","rawQuasis","quasis","map","q","raw","placeholderID","text","reduce","prevVal","currVal","idx","doc","parser","transformCssDoc","isGraphQL","expressionDocs","expressions","numQuasis","trim","parts","templateElement","isFirst","isLast","_text","cooked","lines","split","numLines","expressionDoc","startsWithBlankLine","endsWithBlankLine","commentsAndWhitespaceOnly","every","line","_doc","printGraphqlComments","escapeTemplateCharacters","push","htmlParser","isHtml","isAngularComponentTemplate","undefined","printHtmlTemplateLiteral","embeddedInHtml","tag","_text2","replace","_","backslashes","repeat","indentation","getIndentation","hasIndent","printMarkdown","RegExp","__inJsTemplate","str","firstMatchedIndent","match","uncook","cookedValue","currentDoc","forEach","part","assign","quasisDoc","parentNode","isEmpty","newDoc","replacePlaceholders","Error","replaceCounter","atIndex","indexOf","placeholderIndex","startsWith","at","placeholder","rest","atPlaceholderIndex","findIndex","_placeholder","_rest","placeholderMatch","suffix","expression","seenComment","textLine","array","openingElement","attributes","attribute","object","property","isPathMatch","key","getAngularComponentObjectExpressionPredicates","callee","isStyledIdentifier","isStyledExtend","hasLanguageComment","languageName","comment","predicateStack","stack","pop","_iterator","_step","predicate","htmlTemplateLiteralCounter","escapeClosingScriptTag","counter","composePlaceholder","index","quasi","placeholderRegex","contentDoc","components","component","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/language-js/embed.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require(\"./comments\"),\n    isBlockComment = _require.isBlockComment,\n    hasLeadingComment = _require.hasLeadingComment;\n\nvar _require2 = require(\"../doc\"),\n    _require2$builders = _require2.builders,\n    indent = _require2$builders.indent,\n    join = _require2$builders.join,\n    hardline = _require2$builders.hardline,\n    softline = _require2$builders.softline,\n    literalline = _require2$builders.literalline,\n    concat = _require2$builders.concat,\n    group = _require2$builders.group,\n    dedentToRoot = _require2$builders.dedentToRoot,\n    _require2$utils = _require2.utils,\n    mapDoc = _require2$utils.mapDoc,\n    stripTrailingHardline = _require2$utils.stripTrailingHardline;\n\nfunction embed(path, print, textToDoc, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n\n  switch (node.type) {\n    case \"TemplateLiteral\":\n      {\n        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n          return isIt(path);\n        });\n\n        if (isCss) {\n          // Get full template literal with expressions replaced by placeholders\n          var rawQuasis = node.quasis.map(function (q) {\n            return q.value.raw;\n          });\n          var placeholderID = 0;\n          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n            return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n          }, \"\");\n          var doc = textToDoc(text, {\n            parser: \"css\"\n          });\n          return transformCssDoc(doc, path, print);\n        }\n        /*\n         * react-relay and graphql-tag\n         * graphql`...`\n         * graphql.experimental`...`\n         * gql`...`\n         *\n         * This intentionally excludes Relay Classic tags, as Prettier does not\n         * support Relay Classic formatting.\n         */\n\n\n        if (isGraphQL(path)) {\n          var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n          var numQuasis = node.quasis.length;\n\n          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n            return \"``\";\n          }\n\n          var parts = [];\n\n          for (var i = 0; i < numQuasis; i++) {\n            var templateElement = node.quasis[i];\n            var isFirst = i === 0;\n            var isLast = i === numQuasis - 1;\n            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n            // (which would make the `cooked` value be `null` or `undefined`)\n\n            if (typeof _text !== \"string\") {\n              return null;\n            }\n\n            var lines = _text.split(\"\\n\");\n\n            var numLines = lines.length;\n            var expressionDoc = expressionDocs[i];\n            var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n            var commentsAndWhitespaceOnly = lines.every(function (line) {\n              return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n            }); // Bail out if an interpolation occurs within a comment.\n\n            if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n              return null;\n            }\n\n            var _doc = null;\n\n            if (commentsAndWhitespaceOnly) {\n              _doc = printGraphqlComments(lines);\n            } else {\n              _doc = stripTrailingHardline(textToDoc(_text, {\n                parser: \"graphql\"\n              }));\n            }\n\n            if (_doc) {\n              _doc = escapeTemplateCharacters(_doc, false);\n\n              if (!isFirst && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              parts.push(_doc);\n\n              if (!isLast && endsWithBlankLine) {\n                parts.push(\"\");\n              }\n            } else if (!isFirst && !isLast && startsWithBlankLine) {\n              parts.push(\"\");\n            }\n\n            if (expressionDoc) {\n              parts.push(concat([\"${\", expressionDoc, \"}\"]));\n            }\n          }\n\n          return concat([\"`\", indent(concat([hardline, join(hardline, parts)])), hardline, \"`\"]);\n        }\n\n        var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n        if (htmlParser) {\n          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n        }\n\n        break;\n      }\n\n    case \"TemplateElement\":\n      {\n        /**\n         * md`...`\n         * markdown`...`\n         */\n        if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n            return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n          });\n\n          var indentation = getIndentation(_text2);\n          var hasIndent = indentation !== \"\";\n          return concat([hasIndent ? indent(concat([softline, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat([literalline, dedentToRoot(printMarkdown(_text2))]), softline]);\n        }\n\n        break;\n      }\n  }\n\n  function printMarkdown(text) {\n    var doc = textToDoc(text, {\n      parser: \"markdown\",\n      __inJsTemplate: true\n    });\n    return stripTrailingHardline(escapeTemplateCharacters(doc, true));\n  }\n}\n\nfunction getIndentation(str) {\n  var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n}\n\nfunction uncook(cookedValue) {\n  return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n}\n\nfunction escapeTemplateCharacters(doc, raw) {\n  return mapDoc(doc, function (currentDoc) {\n    if (!currentDoc.parts) {\n      return currentDoc;\n    }\n\n    var parts = [];\n    currentDoc.parts.forEach(function (part) {\n      if (typeof part === \"string\") {\n        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n      } else {\n        parts.push(part);\n      }\n    });\n    return Object.assign({}, currentDoc, {\n      parts: parts\n    });\n  });\n}\n\nfunction transformCssDoc(quasisDoc, path, print) {\n  var parentNode = path.getValue();\n  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n  if (isEmpty) {\n    return \"``\";\n  }\n\n  var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n  /* istanbul ignore if */\n\n  if (!newDoc) {\n    throw new Error(\"Couldn't insert all the expressions\");\n  }\n\n  return concat([\"`\", indent(concat([hardline, stripTrailingHardline(newDoc)])), softline, \"`\"]);\n} // Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\n\n\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  var expressions = expressionDocs.slice();\n  var replaceCounter = 0;\n  var newDoc = mapDoc(quasisDoc, function (doc) {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n\n    var parts = doc.parts;\n    var atIndex = parts.indexOf(\"@\");\n    var placeholderIndex = atIndex + 1;\n\n    if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n      // If placeholder is split, join it\n      var at = parts[atIndex];\n      var placeholder = parts[placeholderIndex];\n      var rest = parts.slice(placeholderIndex + 1);\n      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n    }\n\n    var atPlaceholderIndex = parts.findIndex(function (part) {\n      return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n    });\n\n    if (atPlaceholderIndex > -1) {\n      var _placeholder = parts[atPlaceholderIndex];\n\n      var _rest = parts.slice(atPlaceholderIndex + 1);\n\n      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n      // animation: linear ${time}s ease-out;\n\n      var suffix = placeholderMatch[2];\n      var expression = expressions[placeholderID];\n      replaceCounter++;\n      parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n    }\n\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n\nfunction printGraphqlComments(lines) {\n  var parts = [];\n  var seenComment = false;\n  lines.map(function (textLine) {\n    return textLine.trim();\n  }).forEach(function (textLine, i, array) {\n    // Lines are either whitespace only, or a comment (with poential whitespace\n    // around it). Drop whitespace-only lines.\n    if (textLine === \"\") {\n      return;\n    }\n\n    if (array[i - 1] === \"\" && seenComment) {\n      // If a non-first comment is preceded by a blank (whitespace only) line,\n      // add in a blank line.\n      parts.push(concat([hardline, textLine]));\n    } else {\n      parts.push(textLine);\n    }\n\n    seenComment = true;\n  }); // If `lines` was whitespace only, return `null`.\n\n  return parts.length === 0 ? null : join(hardline, parts);\n}\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\n\n\nfunction isStyledJsx(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n    return attribute.name.name === \"jsx\";\n  }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n}\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\n\n\nfunction isAngularComponentStyles(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"ArrayExpression\" && name === \"elements\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction isAngularComponentTemplate(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction getAngularComponentObjectExpressionPredicates() {\n  return [function (node, name) {\n    return node.type === \"ObjectExpression\" && name === \"properties\";\n  }, function (node, name) {\n    return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n  }, function (node, name) {\n    return node.type === \"Decorator\" && name === \"expression\";\n  }];\n}\n/**\n * styled-components template literals\n */\n\n\nfunction isStyledComponents(path) {\n  var parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  var tag = parent.tag;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (// styled.foo``\n        isStyledIdentifier(tag.object) || // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (// styled(Component)``\n        isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n        tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n/**\n * JSX element with CSS prop\n */\n\n\nfunction isCssProp(path) {\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\n\n\nfunction isGraphQL(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasLeadingComment(node, function (comment) {\n    return isBlockComment(comment) && comment.value === \" \".concat(languageName, \" \");\n  });\n}\n\nfunction isPathMatch(path, predicateStack) {\n  var stack = path.stack.slice();\n  var name = null;\n  var node = stack.pop();\n\n  var _iterator = _createForOfIteratorHelper(predicateStack),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var predicate = _step.value;\n\n      if (node === undefined) {\n        return false;\n      } // skip index/array\n\n\n      if (typeof name === \"number\") {\n        name = stack.pop();\n        node = stack.pop();\n      }\n\n      if (!predicate(node, name)) {\n        return false;\n      }\n\n      name = stack.pop();\n      node = stack.pop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n}\n/**\n *     - html`...`\n *     - HTML comment block\n */\n\n\nfunction isHtml(path) {\n  var node = path.getValue();\n  return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n  }]);\n} // The counter is needed to distinguish nested embeds.\n\n\nvar htmlTemplateLiteralCounter = 0;\n\nfunction printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n  var node = path.getValue();\n  var counter = htmlTemplateLiteralCounter;\n  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n  var composePlaceholder = function composePlaceholder(index) {\n    return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n  };\n\n  var text = node.quasis.map(function (quasi, index, quasis) {\n    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n  }).join(\"\");\n  var expressionDocs = path.map(print, \"expressions\");\n\n  if (expressionDocs.length === 0 && text.trim().length === 0) {\n    return \"``\";\n  }\n\n  var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n  var contentDoc = mapDoc(stripTrailingHardline(textToDoc(text, {\n    parser: parser\n  })), function (doc) {\n    if (typeof doc !== \"string\") {\n      return doc;\n    }\n\n    var parts = [];\n    var components = doc.split(placeholderRegex);\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (i % 2 === 0) {\n        if (component) {\n          component = uncook(component);\n\n          if (escapeClosingScriptTag) {\n            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n          }\n\n          parts.push(component);\n        }\n\n        continue;\n      }\n\n      var placeholderIndex = +component;\n      parts.push(concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"]));\n    }\n\n    return concat(parts);\n  });\n  return group(concat([\"`\", indent(concat([hardline, group(contentDoc)])), softline, \"`\"]));\n}\n\nmodule.exports = embed;"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var Account = require(\"ethereumjs-account\").default;\n\nvar RuntimeError = require(\"./utils/runtimeerror\");\n\nvar Transaction = require(\"./utils/transaction\");\n\nvar utils = require(\"ethereumjs-util\");\n\nvar seedrandom = require(\"seedrandom\");\n\nvar bip39 = require(\"bip39\");\n\nvar wallet = require(\"ethereumjs-wallet\");\n\nvar hdkey = require(\"ethereumjs-wallet/hdkey\");\n\nvar async = require(\"async\");\n\nvar BlockchainDouble = require(\"./blockchain_double.js\");\n\nvar ForkedBlockchain = require(\"./forking/forked_blockchain.js\");\n\nvar Web3 = require(\"web3\");\n\nvar fs = require(\"fs\");\n\nvar sigUtil = require(\"eth-sig-util\");\n\nvar _ = require(\"lodash\");\n\nconst {\n  BlockOutOfRangeError\n} = require(\"./utils/errorhelper\");\n\nconst BN = utils.BN;\n\nconst rlp = require(\"rlp\");\n\nconst Common = require(\"ethereumjs-common\").default;\n\nconst ZERO_BUFFER = Buffer.from([0]);\n\nvar to = require(\"./utils/to\");\n\nvar random = require(\"./utils/random\");\n\nvar TXRejectedError = require(\"./utils/txrejectederror\");\n\nfunction StateManager(options, provider) {\n  this.options = options = this._applyDefaultOptions(options || {});\n\n  if (options.fork) {\n    this.blockchain = new ForkedBlockchain(options);\n  } else {\n    this.blockchain = new BlockchainDouble(options);\n  }\n\n  this.vm = this.blockchain.vm;\n  this.stateTrie = this.blockchain.stateTrie;\n  this.accounts = {};\n  this.secure = !!options.secure;\n  this.account_passwords = {};\n  this.personal_accounts = {};\n  this.total_accounts = options.total_accounts;\n  this.coinbase = null;\n  this.latest_filter_id = 1; // This queue manages actions that shouldn't be run in parallel.\n  // The action_processing flag ensures new actions are queued instead of\n  // run immediately.\n\n  this.action_queue = [];\n  this.action_processing = false;\n  this.snapshots = [];\n  this.logger = options.logger;\n  this.net_version = options.network_id;\n  this.mnemonic = options.mnemonic;\n  this.wallet = hdkey.fromMasterSeed(bip39.mnemonicToSeed(this.mnemonic));\n  this.wallet_hdpath = options.hd_path || options.hdPath;\n  this.gasPriceVal = to.rpcQuantityHexString(options.gasPrice);\n  this.is_mining = true;\n  this.blockTime = options.blockTime;\n  this.is_mining_on_interval = !!options.blockTime;\n  this.mining_interval_timeout = null;\n  this._provider = provider;\n}\n\nconst defaultOptions = {\n  forkCacheSize: 1024 * 1024 * 1024,\n  total_accounts: 10,\n  gasPrice: \"0x77359400\",\n  // 2 gwei\n  default_balance_ether: 100,\n  unlocked_accounts: [],\n  hdPath: \"m/44'/60'/0'/0/\"\n};\n\nStateManager.prototype._applyDefaultOptions = function (options) {\n  // do this so that we can use the same seed on our next run and get the same\n  // results without explicitly setting a seed up front\n  if (!options.seed) {\n    options.seed = random.randomAlphaNumericString(10, seedrandom());\n  } // generate a randomized default mnemonic\n\n\n  if (!options.mnemonic) {\n    const randomBytes = random.randomBytes(16, seedrandom(options.seed));\n    options.mnemonic = bip39.entropyToMnemonic(randomBytes.toString(\"hex\"));\n  }\n\n  if (!options.fork && !options.network_id) {\n    options.network_id = new Date().getTime();\n  } // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n\n\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nStateManager.prototype.initialize = function (callback) {\n  var self = this;\n  var accounts = [];\n  const defaultBalanceWei = to.hex(Web3.utils.toWei(self.options.default_balance_ether.toString(), \"ether\"));\n\n  if (self.options.accounts) {\n    accounts = self.options.accounts.map(self.createAccount.bind(self));\n  } else {\n    if (!self.total_accounts) {\n      return callback(new Error(\"Cannot initialize chain: either options.accounts or options.total_accounts must be specified\"));\n    }\n\n    for (var i = 0; i < self.total_accounts; i++) {\n      accounts.push(self.createAccount({\n        index: i,\n        balance: defaultBalanceWei\n      }));\n    }\n  }\n\n  self.coinbase = to.hex(accounts[0].address);\n  self.accounts = {};\n  accounts.forEach(function (data) {\n    self.accounts[data.address] = data;\n    self.personal_accounts[data.address.toLowerCase()] = true;\n  }); // Turn array into object, mostly for speed purposes.\n  // No need for caller to specify private keys.\n\n  self.unlocked_accounts = self.options.unlocked_accounts.reduce(function (obj, address) {\n    // If it doesn't have a hex prefix, must be a number (either a string or number type).\n    if ((address + \"\").indexOf(\"0x\") !== 0) {\n      const idx = parseInt(address);\n      const account = accounts[idx];\n\n      if (!account) {\n        throw new Error(`Account at index ${idx} not found. Max index available is ${accounts.length - 1}.`);\n      }\n\n      address = account.address.toLowerCase();\n    }\n\n    obj[address.toLowerCase()] = true; // can be any value\n\n    return obj;\n  }, {});\n\n  if (!self.secure) {\n    accounts.forEach(function (data) {\n      self.unlocked_accounts[data.address.toLowerCase()] = data;\n    });\n  }\n\n  if (self.options.account_keys_path) {\n    const fileData = {\n      addresses: {},\n      private_keys: {}\n    };\n    accounts.forEach(function (account) {\n      fileData.private_keys[account.address] = account.secretKey.toString(\"hex\");\n      fileData.addresses[account.address] = account;\n    });\n    const json = JSON.stringify(fileData);\n    fs.writeFileSync(self.options.account_keys_path, json, \"utf8\");\n  }\n\n  self.blockchain.initialize(accounts, function (err) {\n    if (err) {\n      return callback(err);\n    } // If the user didn't pass a specific version id in, then use the\n    // forked blockchain's version (if it exists) or create our own.\n\n\n    if (!self.net_version) {\n      self.net_version = self.blockchain.forkVersion;\n    }\n\n    if (self.is_mining_on_interval) {\n      self.mineOnInterval();\n    }\n\n    callback();\n  });\n};\n\nStateManager.prototype._minerCancellationToken = null;\n\nStateManager.prototype.mineOnInterval = function () {\n  // cancel the a previous miner's timeout\n  clearTimeout(this.mining_interval_timeout); // make sure a pending eth_mine doesn't come back and execute mineOnInterval\n  // again...\n\n  if (this._minerCancellationToken !== null) {\n    this._minerCancellationToken.cancelled = true;\n  } // if mining was stopped `mineOnInterval` shouldn't start mining again\n\n\n  if (!this.is_mining) {\n    this.logger.log(\"Warning: mineOnInterval called when miner was stopped\");\n    return;\n  }\n\n  const cancellationToken = {\n    cancelled: false\n  };\n  this._minerCancellationToken = cancellationToken;\n  const timeout = this.mining_interval_timeout = setTimeout(this._provider.send.bind(this._provider), this.blockTime * 1000, {\n    method: \"evm_mine\"\n  }, () => {\n    if (!cancellationToken.cancelled) {\n      this.mineOnInterval.bind(this)();\n    }\n  }); // Ensure this won't keep a node process open.\n\n  if (typeof timeout.unref === \"function\") {\n    timeout.unref();\n  }\n};\n\nStateManager.prototype.createAccount = function (opts, i) {\n  var secretKey;\n\n  if (opts.generate) {\n    secretKey = wallet.generate().getPrivateKey();\n  } else if (opts.secretKey) {\n    secretKey = utils.toBuffer(to.hex(opts.secretKey));\n  } else {\n    var index = typeof opts.index === \"undefined\" ? i : opts.index;\n    var acct = this.wallet.derivePath(this.wallet_hdpath + index); // index is a number\n\n    secretKey = acct.getWallet().getPrivateKey(); // Buffer\n  }\n\n  var publicKey = utils.privateToPublic(secretKey);\n  var address = utils.publicToAddress(publicKey);\n  var account = new Account();\n  account.balance = to.hex(opts.balance);\n  var data = {\n    secretKey: secretKey,\n    publicKey: publicKey,\n    address: to.hex(address).toLowerCase(),\n    account: account\n  };\n  return data;\n};\n\nStateManager.prototype.blockNumber = function (callback) {\n  return this.blockchain.getHeight(callback);\n};\n\nStateManager.prototype.gasPrice = function () {\n  return this.gasPriceVal;\n};\n\nStateManager.prototype.getBalance = function (address, number, callback) {\n  this.blockchain.getBalance(address, number, function (err, balance) {\n    if (balance) {\n      balance = to.rpcQuantityHexString(balance);\n    }\n\n    callback(err, balance);\n  });\n};\n\nStateManager.prototype.getTransactionCount = function (address, number, callback) {\n  this.blockchain.getNonce(address, number, function (err, nonce) {\n    if (nonce) {\n      nonce = to.rpcQuantityHexString(nonce);\n    }\n\n    callback(err, nonce);\n  });\n};\n\nStateManager.prototype.getCode = function (address, number, callback) {\n  this.blockchain.getCode(address, number, function (err, code) {\n    if (code) {\n      code = to.hex(code);\n    }\n\n    callback(err, code);\n  });\n};\n\nStateManager.prototype.queueRawTransaction = function (data, callback) {\n  // a hack until we get chainid and networkId alignment\n  // in the next major (breaking_change) version:\n  // Reason: historically we didn't validate chain ids.\n  let chainId;\n\n  if (Buffer.isBuffer(data)) {\n    const decodedData = rlp.decode(data);\n    let v = decodedData[6];\n\n    if (v !== undefined) {\n      v = utils.bufferToInt(v);\n      chainId = Math.floor((v - 35) / 2);\n\n      if (chainId < 0) {\n        chainId = 0;\n      }\n    }\n  }\n\n  const common = !chainId ? this.blockchain.vm.opts.common : Common.forCustomChain(\"mainnet\", // TODO needs to match chain id\n  {\n    name: \"ganache\",\n    networkId: this.options.network_id || this.blockchain.forkVersion,\n    chainId,\n    comment: \"Local test network\",\n    bootstrapNodes: []\n  }, this.options.hardfork);\n  const tx = new Transaction(data, Transaction.types.signed, common); // use toLowerCase() to properly handle from addresses meant to be validated.\n\n  const from = to.hex(tx.from).toLowerCase();\n\n  this._queueTransaction(\"eth_sendRawTransaction\", tx, from, null, callback);\n};\n\nStateManager.prototype.queueStorage = function (address, position, block, callback) {\n  this.action_queue.push({\n    method: \"eth_getStorageAt\",\n    address: utils.addHexPrefix(address),\n    position: utils.addHexPrefix(position),\n    block: block,\n    callback: callback\n  }); // We know there's work, so get started.\n\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransaction = function (method, txJsonRpc, blockNumber, callback) {\n  // use toLowerCase() to properly handle from addresses meant to be validated.\n  const from = txJsonRpc.from ? to.hex(txJsonRpc.from).toLowerCase() : null;\n\n  if (from == null) {\n    callback(new TXRejectedError(\"from not found; is required\"));\n    return;\n  } // Error checks. It's possible to JSON.stringify a Buffer to JSON.\n  // we actually now handle this \"properly\" (not sure about spec), but for\n  // legacy reasons we don't allow it.\n\n\n  if (txJsonRpc.to && typeof txJsonRpc.to !== \"string\") {\n    return callback(new TXRejectedError(\"Invalid to address\"));\n  }\n\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isKnownAccount = hasOwnProperty.call(this.accounts, from);\n\n  if (method === \"eth_sendTransaction\" && !hasOwnProperty.call(this.unlocked_accounts, from)) {\n    const msg = isKnownAccount ? \"signer account is locked\" : \"sender account not recognized\";\n    return callback(new TXRejectedError(msg));\n  }\n\n  let type = Transaction.types.none;\n\n  if (!isKnownAccount || method === \"eth_call\" || method === \"eth_estimateGas\") {\n    type |= Transaction.types.fake;\n  }\n\n  let tx;\n\n  try {\n    tx = Transaction.fromJSON(txJsonRpc, type, this.blockchain.vm.opts.common);\n\n    this._setTransactionDefaults(tx, method === \"eth_sendTransaction\");\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  this._queueTransaction(method, tx, from, blockNumber, callback);\n};\n\nStateManager.prototype._setTransactionDefaults = function (tx, isTransaction) {\n  if (isTransaction && tx.gasLimit.length === 0) {\n    tx.gasLimit = utils.toBuffer(this.blockchain.defaultTransactionGasLimit);\n  }\n\n  if (tx.gasPrice.length === 0) {\n    tx.gasPrice = utils.toBuffer(this.gasPriceVal);\n  }\n\n  if (tx.value.length === 0) {\n    tx.value = Buffer.from([0]);\n  }\n\n  if (tx.to.length === 0 || tx.to.equals(ZERO_BUFFER)) {\n    tx.to = Buffer.allocUnsafe(0);\n  }\n};\n\nStateManager.prototype._queueTransaction = function (method, tx, from, blockNumber, callback) {\n  if (!(tx instanceof Transaction)) {\n    throw new TXRejectedError(\"tx must be of type Transaction\");\n  } // If the transaction has a higher gas limit than the block gas limit, error.\n\n\n  if ((method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") && to.number(tx.gasLimit) > to.number(this.blockchain.blockGasLimit)) {\n    return callback(new TXRejectedError(\"Exceeds block gas limit\"));\n  }\n\n  this.action_queue.push({\n    method,\n    from,\n    tx,\n    callback,\n    blockNumber\n  }); // We know there's work, so get started.\n\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransactionTrace = function (txHash, params, callback) {\n  this.action_queue.push({\n    method: \"debug_traceTransaction\",\n    hash: to.hex(txHash),\n    params: params,\n    callback: callback\n  }); // We know there's work, so get started.\n\n  this.processNextAction();\n};\n\nStateManager.prototype.processNextAction = function (override) {\n  var self = this;\n\n  if (override !== true) {\n    if (this.action_processing === true || this.action_queue.length === 0) {\n      return;\n    }\n  }\n\n  var queued = this.action_queue.shift(); // Set the flag that we're currently processing something.\n\n  this.action_processing = true;\n\n  var intermediary = function (err, result) {\n    queued.callback(err, result);\n\n    if (self.action_queue.length > 0) {\n      self.processNextAction(true);\n    } else {\n      self.action_processing = false;\n    }\n  };\n\n  if (typeof queued.method === \"function\") {\n    var result = queued.method();\n    return intermediary(null, result);\n  } else if (queued.method === \"eth_getStorageAt\") {\n    this.blockchain.getStorage(queued.address, queued.position, queued.block, function (err, result) {\n      if (err) {\n        return intermediary(err);\n      }\n\n      if (result) {\n        result = utils.rlp.decode(result);\n      }\n\n      result = to.hex(result || 0);\n      intermediary(null, result);\n    });\n  } else if (queued.method === \"debug_traceTransaction\") {\n    this.blockchain.processTransactionTrace(queued.hash, queued.params, intermediary);\n  } else if (queued.method === \"eth_sendTransaction\" || queued.method === \"eth_sendRawTransaction\") {\n    this.processTransaction(queued.from, queued.tx, intermediary);\n  } else if (queued.method === \"eth_call\") {\n    this.processCall(queued.from, queued.tx, queued.blockNumber, intermediary);\n  } else if (queued.method === \"eth_estimateGas\") {\n    this.processGasEstimate(queued.from, queued.tx, queued.blockNumber, intermediary);\n  }\n};\n\nStateManager.prototype.sign = function (address, dataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  var secretKey = account.secretKey;\n  var msg = to.buffer(dataToSign, \"hex\");\n  var msgHash = utils.hashPersonalMessage(msg);\n  var sgn = utils.ecsign(msgHash, Buffer.from(secretKey)); // ethereumjs-utils changed the behavior of toRpcSig so that the `v` value\n  // output by `toRpcSig` is always `sgn.v - 27` (basically `0` or `1`). In\n  // order to avoid a breaking change in Ganache at this time we are calculating\n  // a chain ID that will always a) validate the v, and b) generate an output v\n  // of `0` or `1`, like it used to.\n\n  const v = sgn.v - 27;\n  const chainId = (v - 35) / 2;\n  return utils.toRpcSig(v, sgn.r, sgn.s, chainId);\n};\n\nStateManager.prototype.signTypedData = function (address, typedDataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  if (!typedDataToSign.types) {\n    throw new Error(\"cannot sign data; types missing\");\n  }\n\n  if (!typedDataToSign.types.EIP712Domain) {\n    throw new Error(\"cannot sign data; EIP712Domain definition missing\");\n  }\n\n  if (!typedDataToSign.domain) {\n    throw new Error(\"cannot sign data; domain missing\");\n  }\n\n  if (!typedDataToSign.primaryType) {\n    throw new Error(\"cannot sign data; primaryType missing\");\n  }\n\n  if (!typedDataToSign.message) {\n    throw new Error(\"cannot sign data; message missing\");\n  }\n\n  return sigUtil.signTypedData_v4(account.secretKey, {\n    data: typedDataToSign\n  });\n};\n\nStateManager.prototype.printTransactionReceipt = function (txHash, error, callback) {\n  var self = this;\n  self.blockchain.getTransactionReceipt(txHash, function (err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.latestBlock(function (err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      receipt = receipt.toJSON();\n      self.logger.log(\"\");\n      self.logger.log(\"  Transaction: \" + txHash);\n\n      if (receipt.contractAddress != null) {\n        self.logger.log(\"  Contract created: \" + receipt.contractAddress);\n      }\n\n      self.logger.log(\"  Gas usage: \" + parseInt(receipt.gasUsed, 16));\n      self.logger.log(\"  Block Number: \" + parseInt(receipt.blockNumber, 16));\n      self.logger.log(\"  Block Time: \" + new Date(to.number(block.header.timestamp) * 1000).toString());\n\n      if (error) {\n        self.logger.log(\"  Runtime Error: \" + error.error);\n\n        if (error.reason) {\n          self.logger.log(\"  Revert reason: \" + error.reason);\n        }\n      }\n\n      self.logger.log(\"\");\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.processBlock = function (timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  self.blockchain.processNextBlock(timestamp, function (runtimeError, transactions, vmOutput) {\n    if (runtimeError && runtimeError instanceof RuntimeError === false) {\n      // This is bad. Get out.\n      return callback(runtimeError, transactions, vmOutput);\n    } // TODO: Can we refactor printTransactionReceipt so it's synchronous?\n    // We technically have the raw vm receipts (though they're not full receipts here...).\n\n\n    async.eachSeries(transactions, function (tx, finishedPrinting) {\n      var hash = to.hex(tx.hash());\n      var error = runtimeError == null ? {\n        results: {}\n      } : runtimeError;\n      self.printTransactionReceipt(hash, error.results[hash], finishedPrinting);\n    }, callback(runtimeError, transactions, vmOutput));\n  });\n};\n\nStateManager.prototype.processBlocks = function (totalBlocks, callback) {\n  var self = this;\n\n  if (typeof totalBlocks === \"function\") {\n    callback = totalBlocks;\n    totalBlocks = null;\n  } // Note: VM errors (errors that the VM directly returns) trump all runtime errors.\n\n\n  var runtimeError = null;\n  var amountProcessed = 0;\n  async.whilst(function () {\n    var shouldContinue;\n\n    if (totalBlocks == null) {\n      shouldContinue = self.blockchain.pending_transactions.length > 0;\n    } else {\n      shouldContinue = amountProcessed < totalBlocks;\n    }\n\n    return shouldContinue;\n  }, function (done) {\n    self.processBlock(function (err, transactions, vmOutput) {\n      amountProcessed += 1;\n\n      if (err) {\n        if (err instanceof RuntimeError === false) {\n          // This is bad. Get out.\n          return done(err);\n        } // We must have a RuntimeError. Merge results if we've found\n        // other runtime errors during this execution.\n\n\n        if (runtimeError == null) {\n          runtimeError = err;\n        } else {\n          runtimeError.combine(err);\n        }\n      } // Note we don't quit on runtime errors. We keep processing transactions.\n\n\n      done();\n    });\n  }, function (err) {\n    // Remember: vm errors trump runtime errors\n    callback(err || runtimeError);\n  });\n};\n\nStateManager.prototype.processCall = function (from, tx, blockNumber, callback) {\n  var self = this;\n\n  function next(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.processCall(tx, blockNumber, function (err, results) {\n      if (err) {\n        if (err instanceof BlockOutOfRangeError) {\n          // block doesn't exist\n          return callback(null, null);\n        }\n\n        return callback(err);\n      }\n\n      var result = \"0x\";\n\n      if (!results.error && results.execResult.returnValue) {\n        result = to.hex(results.execResult.returnValue);\n      } else if (results.error) {\n        self.logger.log(`Error processing call: ${results.error}`);\n      }\n\n      return callback(null, result);\n    });\n  } // `eth_call` should never need to validate an existing nonce\n\n\n  if (tx.nonce.length === 0) {\n    self.createTransactionWithCorrectNonce(tx, from, next);\n  } else {\n    next(null, tx);\n  }\n};\n\nStateManager.prototype.processGasEstimate = function (from, tx, blockNumber, callback) {\n  var self = this;\n\n  function next(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.estimateGas(tx, blockNumber, function (err, results) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = \"0x\";\n\n      if (!results.error) {\n        result = to.hex(results.gasEstimate);\n      } else {\n        self.logger.log(`Error calculating gas estimate: ${results.error}`);\n      }\n\n      return callback(null, result);\n    });\n  } // `eth_estimateGas` should never need to validate an existing nonce\n\n\n  if (tx.nonce.length === 0) {\n    self.createTransactionWithCorrectNonce(tx, from, next);\n  } else {\n    next(null, tx);\n  }\n};\n\nStateManager.prototype.processTransaction = function (from, tx, callback) {\n  var self = this;\n  self.createTransactionWithCorrectNonce(tx, from, function (err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.queueTransaction(tx);\n    var txHash = to.hex(tx.hash()); // If we're not currently mining or we're mining on an interval,\n    // only queue the transaction, don't process it.\n\n    if (self.is_mining === false || self.is_mining_on_interval) {\n      return callback(null, txHash);\n    }\n\n    self.processBlocks(function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.getTransactionReceipt = function (hash, callback) {\n  this.blockchain.getTransactionReceipt(hash, function (err, receipt) {\n    if (err && err.notFound) {\n      // Return null if the receipt's not found.\n      return callback(null, null);\n    }\n\n    callback(err, receipt);\n  });\n};\n\nStateManager.prototype.getBlock = function (hashOrNumber, callback) {\n  this.blockchain.getBlock(hashOrNumber, callback);\n};\n\nStateManager.prototype.getLogs = function (filter, callback) {\n  var self = this; // filter.address may be a single address or an array\n  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs\n\n  var expectedAddress = filter.address && (Array.isArray(filter.address) ? filter.address : [filter.address]);\n  expectedAddress = expectedAddress && expectedAddress.map(function (a) {\n    return a.toLowerCase();\n  });\n  var expectedTopics = filter.topics || [];\n  async.parallel({\n    fromBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.fromBlock || \"latest\"),\n    toBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.toBlock || \"latest\"),\n    latestBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, \"latest\"),\n    block: this.blockchain.getBlock.bind(this.blockchain, filter.blockHash || 0)\n  }, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n\n    var fromBlock = results.fromBlock;\n    var toBlock = results.toBlock;\n    var latestBlock = results.latestBlock;\n    var block = results.block;\n\n    if (toBlock > latestBlock) {\n      toBlock = latestBlock;\n    }\n\n    if (filter.blockHash) {\n      fromBlock = to.number(block.header.number);\n      toBlock = to.number(block.header.number);\n    }\n\n    var logs = [];\n    var current = fromBlock;\n    async.whilst(function () {\n      return current <= toBlock;\n    }, function (finished) {\n      self.blockchain.getBlockLogs(current, function (err, blockLogs) {\n        if (err) {\n          return finished(err);\n        } // Filter logs that match the address\n\n\n        var filtered = !expectedAddress ? blockLogs : blockLogs.filter(function (log) {\n          return expectedAddress.indexOf(log.address.toLowerCase()) > -1;\n        }); // Now filter based on topics.\n\n        filtered = filtered.filter(function (log) {\n          var keep = true;\n\n          for (var i = 0; i < expectedTopics.length; i++) {\n            var expectedTopic = expectedTopics[i];\n            var logTopic = log.topics[i];\n\n            if (expectedTopic == null) {\n              continue;\n            }\n\n            var isMatch = Array.isArray(expectedTopic) ? expectedTopic.includes(logTopic) : expectedTopic === logTopic;\n\n            if (i >= log.topics.length || !isMatch) {\n              keep = false;\n              break;\n            }\n          }\n\n          return keep;\n        });\n        logs.push.apply(logs, filtered);\n        current += 1;\n        finished();\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      logs = logs.map(function (log) {\n        return log.toJSON();\n      });\n      callback(err, logs);\n    });\n  });\n}; // Note: Snapshots have 1-based ids.\n\n\nStateManager.prototype.snapshot = function (callback) {\n  var self = this;\n  this.blockchain.getHeight(function (err, blockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.snapshots.push({\n      blockNumber: blockNumber,\n      timeAdjustment: self.blockchain.timeAdjustment\n    });\n    self.logger.log(\"Saved snapshot #\" + self.snapshots.length);\n    callback(null, to.hex(self.snapshots.length));\n  });\n};\n\nStateManager.prototype.revert = function (snapshotId, callback) {\n  var self = this;\n\n  if (snapshotId === null || snapshotId === undefined) {\n    callback(new Error(\"invalid snapshotId\"));\n    return;\n  } // Convert from hex.\n\n\n  try {\n    snapshotId = utils.bufferToInt(snapshotId);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  this.logger.log(\"Reverting to snapshot #\" + snapshotId);\n\n  if (snapshotId > this.snapshots.length || snapshotId <= 0) {\n    // the snapshot doesn't exist now, or it has already been reverted\n    callback(null, false);\n    return false;\n  } // Convert to zero based.\n\n\n  snapshotId = snapshotId - 1;\n  var timeAdjustment = this.snapshots[snapshotId].timeAdjustment; // Loop through each snapshot with a higher id than the current one.\n\n  async.whilst(function () {\n    return self.snapshots.length > snapshotId;\n  }, function (nextSnapshot) {\n    var snapshot = self.snapshots.pop(); // For each snapshot, asynchronously pop off the blocks it represents.\n\n    async.during(function (doneWithTest) {\n      self.blockchain.getHeight(function (err, blockNumber) {\n        if (err) {\n          return doneWithTest(err);\n        }\n\n        doneWithTest(null, blockNumber > snapshot.blockNumber);\n      });\n    }, function (nextBlock) {\n      self.blockchain.popBlock(function (err) {\n        if (err) {\n          return nextBlock(err);\n        }\n\n        nextBlock();\n      });\n    }, nextSnapshot);\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    } // Pending transactions are removed when you revert.\n\n\n    self.blockchain.clearPendingTransactions(); // The time adjustment is restored to its prior state\n\n    self.blockchain.timeAdjustment = timeAdjustment;\n    callback(null, true);\n  });\n};\n\nStateManager.prototype.hasContractCode = function (address, callback) {\n  this.vm.stateManager.getContractCode(address, function (err, result) {\n    if (err != null) {\n      callback(err, false);\n    } else {\n      callback(null, true);\n    }\n  });\n};\n\nStateManager.prototype.startMining = function (callback) {\n  if (this.is_mining) {\n    process.nextTick(callback);\n    this.logger.log(\"Warning: startMining called when miner was already started\");\n    return;\n  }\n\n  this.is_mining = true;\n\n  if (this.is_mining_on_interval) {\n    this.mineOnInterval();\n    process.nextTick(callback);\n  } else {\n    this.processBlocks(callback);\n  }\n};\n\nStateManager.prototype.stopMining = function (callback) {\n  if (this.is_mining) {\n    if (this._minerCancellationToken) {\n      this._minerCancellationToken.cancelled = true;\n      this._minerCancellationToken = null;\n    }\n\n    this.is_mining = false;\n    clearTimeout(this.mining_interval_timeout);\n    this.mining_interval_timeout = null;\n  } else {\n    this.logger.log(\"Warning: stopMining called when miner was already stopped\");\n  }\n\n  callback && process.nextTick(callback);\n};\n\nStateManager.prototype.isUnlocked = function (address) {\n  return this.unlocked_accounts[address.toLowerCase()] != null;\n};\n\nStateManager.prototype.createTransactionWithCorrectNonce = function (tx, from, callback) {\n  // account for transactions waiting in the tx queue\n  this.blockchain.getQueuedNonce(from, (err, expectedNonce) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const validateNonce = (tx, expectedNonce) => {\n      if (tx.validateNonce(expectedNonce)) {\n        return Promise.resolve(tx);\n      } else {\n        const expected = new BN(expectedNonce).toString(10);\n        const actual = new BN(tx.nonce).toString(10);\n        return Promise.reject(new TXRejectedError(`the tx doesn't have the correct nonce. account has nonce of: ${expected} tx has nonce of: ${actual}`));\n      }\n    };\n\n    const done = tx => callback(null, tx);\n\n    if (tx.isSigned()) {\n      validateNonce(tx, expectedNonce).then(done).catch(callback);\n    } else {\n      const sign = tx => {\n        // we need to sign transactions if they haven't been signed already\n        // but we never sign fake transactions\n        if (!tx.isFake() && !tx.isSigned()) {\n          const account = this.accounts[from];\n\n          if (account) {\n            tx.sign(account.secretKey);\n          }\n        }\n\n        return Promise.resolve(tx);\n      }; // Validate the tx's nonce and then sign the transaction.\n      // By signing this transaction now we ensure all future calls to tx.hash()\n      // return the same signed transaction hash. It's sort of an unintuitive\n      // quirk of etheremjs-tx that:\n      //   tx.hash(includeSignature);\n      //   tx.sign(secretKey);\n      //   tx.hash(includeSignature);\n      // will produce different hashes.\n\n\n      if (tx.nonce.length === 0) {\n        // Since this transaction is unsigned and the nonce was not defined\n        // we can go ahead and change the nonce and not worry about\n        // invalidating the tx hash the client may be expecting (automatic nonce\n        // calculation should have been expected by the client in this case).\n        tx.nonce = expectedNonce;\n        sign(tx).then(done);\n      } else {\n        validateNonce(tx, expectedNonce).then(sign).then(done).catch(callback);\n      }\n    }\n  });\n};\n\nmodule.exports = StateManager;","map":{"version":3,"names":["Account","require","default","RuntimeError","Transaction","utils","seedrandom","bip39","wallet","hdkey","async","BlockchainDouble","ForkedBlockchain","Web3","fs","sigUtil","_","BlockOutOfRangeError","BN","rlp","Common","ZERO_BUFFER","Buffer","from","to","random","TXRejectedError","StateManager","options","provider","_applyDefaultOptions","fork","blockchain","vm","stateTrie","accounts","secure","account_passwords","personal_accounts","total_accounts","coinbase","latest_filter_id","action_queue","action_processing","snapshots","logger","net_version","network_id","mnemonic","fromMasterSeed","mnemonicToSeed","wallet_hdpath","hd_path","hdPath","gasPriceVal","rpcQuantityHexString","gasPrice","is_mining","blockTime","is_mining_on_interval","mining_interval_timeout","_provider","defaultOptions","forkCacheSize","default_balance_ether","unlocked_accounts","prototype","seed","randomAlphaNumericString","randomBytes","entropyToMnemonic","toString","Date","getTime","merge","Object","assign","initialize","callback","self","defaultBalanceWei","hex","toWei","map","createAccount","bind","Error","i","push","index","balance","address","forEach","data","toLowerCase","reduce","obj","indexOf","idx","parseInt","account","length","account_keys_path","fileData","addresses","private_keys","secretKey","json","JSON","stringify","writeFileSync","err","forkVersion","mineOnInterval","_minerCancellationToken","clearTimeout","cancelled","log","cancellationToken","timeout","setTimeout","send","method","unref","opts","generate","getPrivateKey","toBuffer","acct","derivePath","getWallet","publicKey","privateToPublic","publicToAddress","blockNumber","getHeight","getBalance","number","getTransactionCount","getNonce","nonce","getCode","code","queueRawTransaction","chainId","isBuffer","decodedData","decode","v","undefined","bufferToInt","Math","floor","common","forCustomChain","name","networkId","comment","bootstrapNodes","hardfork","tx","types","signed","_queueTransaction","queueStorage","position","block","addHexPrefix","processNextAction","queueTransaction","txJsonRpc","hasOwnProperty","isKnownAccount","call","msg","type","none","fake","fromJSON","_setTransactionDefaults","e","isTransaction","gasLimit","defaultTransactionGasLimit","value","equals","allocUnsafe","blockGasLimit","queueTransactionTrace","txHash","params","hash","override","queued","shift","intermediary","result","getStorage","processTransactionTrace","processTransaction","processCall","processGasEstimate","sign","dataToSign","buffer","msgHash","hashPersonalMessage","sgn","ecsign","toRpcSig","r","s","signTypedData","typedDataToSign","EIP712Domain","domain","primaryType","message","signTypedData_v4","printTransactionReceipt","error","getTransactionReceipt","receipt","latestBlock","toJSON","contractAddress","gasUsed","header","timestamp","reason","processBlock","processNextBlock","runtimeError","transactions","vmOutput","eachSeries","finishedPrinting","results","processBlocks","totalBlocks","amountProcessed","whilst","shouldContinue","pending_transactions","done","combine","next","execResult","returnValue","createTransactionWithCorrectNonce","estimateGas","gasEstimate","notFound","getBlock","hashOrNumber","getLogs","filter","expectedAddress","Array","isArray","a","expectedTopics","topics","parallel","fromBlock","getEffectiveBlockNumber","toBlock","blockHash","logs","current","finished","getBlockLogs","blockLogs","filtered","keep","expectedTopic","logTopic","isMatch","includes","apply","snapshot","timeAdjustment","revert","snapshotId","nextSnapshot","pop","during","doneWithTest","nextBlock","popBlock","clearPendingTransactions","hasContractCode","stateManager","getContractCode","startMining","process","nextTick","stopMining","isUnlocked","getQueuedNonce","expectedNonce","validateNonce","Promise","resolve","expected","actual","reject","isSigned","then","catch","isFake","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/statemanager.js"],"sourcesContent":["var Account = require(\"ethereumjs-account\").default;\nvar RuntimeError = require(\"./utils/runtimeerror\");\nvar Transaction = require(\"./utils/transaction\");\nvar utils = require(\"ethereumjs-util\");\nvar seedrandom = require(\"seedrandom\");\nvar bip39 = require(\"bip39\");\nvar wallet = require(\"ethereumjs-wallet\");\nvar hdkey = require(\"ethereumjs-wallet/hdkey\");\nvar async = require(\"async\");\nvar BlockchainDouble = require(\"./blockchain_double.js\");\nvar ForkedBlockchain = require(\"./forking/forked_blockchain.js\");\nvar Web3 = require(\"web3\");\nvar fs = require(\"fs\");\nvar sigUtil = require(\"eth-sig-util\");\nvar _ = require(\"lodash\");\nconst { BlockOutOfRangeError } = require(\"./utils/errorhelper\");\nconst BN = utils.BN;\nconst rlp = require(\"rlp\");\nconst Common = require(\"ethereumjs-common\").default;\n\nconst ZERO_BUFFER = Buffer.from([0]);\n\nvar to = require(\"./utils/to\");\nvar random = require(\"./utils/random\");\nvar TXRejectedError = require(\"./utils/txrejectederror\");\n\nfunction StateManager(options, provider) {\n  this.options = options = this._applyDefaultOptions(options || {});\n\n  if (options.fork) {\n    this.blockchain = new ForkedBlockchain(options);\n  } else {\n    this.blockchain = new BlockchainDouble(options);\n  }\n\n  this.vm = this.blockchain.vm;\n  this.stateTrie = this.blockchain.stateTrie;\n\n  this.accounts = {};\n  this.secure = !!options.secure;\n  this.account_passwords = {};\n  this.personal_accounts = {};\n  this.total_accounts = options.total_accounts;\n  this.coinbase = null;\n\n  this.latest_filter_id = 1;\n\n  // This queue manages actions that shouldn't be run in parallel.\n  // The action_processing flag ensures new actions are queued instead of\n  // run immediately.\n  this.action_queue = [];\n  this.action_processing = false;\n\n  this.snapshots = [];\n  this.logger = options.logger;\n  this.net_version = options.network_id;\n  this.mnemonic = options.mnemonic;\n  this.wallet = hdkey.fromMasterSeed(bip39.mnemonicToSeed(this.mnemonic));\n  this.wallet_hdpath = options.hd_path || options.hdPath;\n\n  this.gasPriceVal = to.rpcQuantityHexString(options.gasPrice);\n\n  this.is_mining = true;\n  this.blockTime = options.blockTime;\n  this.is_mining_on_interval = !!options.blockTime;\n  this.mining_interval_timeout = null;\n\n  this._provider = provider;\n}\n\nconst defaultOptions = {\n  forkCacheSize: 1024 * 1024 * 1024,\n  total_accounts: 10,\n  gasPrice: \"0x77359400\", // 2 gwei\n  default_balance_ether: 100,\n  unlocked_accounts: [],\n  hdPath: \"m/44'/60'/0'/0/\"\n};\n\nStateManager.prototype._applyDefaultOptions = function(options) {\n  // do this so that we can use the same seed on our next run and get the same\n  // results without explicitly setting a seed up front\n  if (!options.seed) {\n    options.seed = random.randomAlphaNumericString(10, seedrandom());\n  }\n\n  // generate a randomized default mnemonic\n  if (!options.mnemonic) {\n    const randomBytes = random.randomBytes(16, seedrandom(options.seed));\n    options.mnemonic = bip39.entropyToMnemonic(randomBytes.toString(\"hex\"));\n  }\n\n  if (!options.fork && !options.network_id) {\n    options.network_id = new Date().getTime();\n  }\n\n  // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nStateManager.prototype.initialize = function(callback) {\n  var self = this;\n\n  var accounts = [];\n\n  const defaultBalanceWei = to.hex(Web3.utils.toWei(self.options.default_balance_ether.toString(), \"ether\"));\n\n  if (self.options.accounts) {\n    accounts = self.options.accounts.map(self.createAccount.bind(self));\n  } else {\n    if (!self.total_accounts) {\n      return callback(\n        new Error(\"Cannot initialize chain: either options.accounts or options.total_accounts must be specified\")\n      );\n    }\n\n    for (var i = 0; i < self.total_accounts; i++) {\n      accounts.push(\n        self.createAccount({\n          index: i,\n          balance: defaultBalanceWei\n        })\n      );\n    }\n  }\n\n  self.coinbase = to.hex(accounts[0].address);\n  self.accounts = {};\n\n  accounts.forEach(function(data) {\n    self.accounts[data.address] = data;\n    self.personal_accounts[data.address.toLowerCase()] = true;\n  });\n\n  // Turn array into object, mostly for speed purposes.\n  // No need for caller to specify private keys.\n  self.unlocked_accounts = self.options.unlocked_accounts.reduce(function(obj, address) {\n    // If it doesn't have a hex prefix, must be a number (either a string or number type).\n    if ((address + \"\").indexOf(\"0x\") !== 0) {\n      const idx = parseInt(address);\n      const account = accounts[idx];\n      if (!account) {\n        throw new Error(`Account at index ${idx} not found. Max index available is ${accounts.length - 1}.`);\n      }\n      address = account.address.toLowerCase();\n    }\n\n    obj[address.toLowerCase()] = true; // can be any value\n    return obj;\n  }, {});\n\n  if (!self.secure) {\n    accounts.forEach(function(data) {\n      self.unlocked_accounts[data.address.toLowerCase()] = data;\n    });\n  }\n\n  if (self.options.account_keys_path) {\n    const fileData = {\n      addresses: {},\n      private_keys: {}\n    };\n    accounts.forEach(function(account) {\n      fileData.private_keys[account.address] = account.secretKey.toString(\"hex\");\n      fileData.addresses[account.address] = account;\n    });\n    const json = JSON.stringify(fileData);\n    fs.writeFileSync(self.options.account_keys_path, json, \"utf8\");\n  }\n\n  self.blockchain.initialize(accounts, function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    // If the user didn't pass a specific version id in, then use the\n    // forked blockchain's version (if it exists) or create our own.\n    if (!self.net_version) {\n      self.net_version = self.blockchain.forkVersion;\n    }\n\n    if (self.is_mining_on_interval) {\n      self.mineOnInterval();\n    }\n    callback();\n  });\n};\n\nStateManager.prototype._minerCancellationToken = null;\nStateManager.prototype.mineOnInterval = function() {\n  // cancel the a previous miner's timeout\n  clearTimeout(this.mining_interval_timeout);\n\n  // make sure a pending eth_mine doesn't come back and execute mineOnInterval\n  // again...\n  if (this._minerCancellationToken !== null) {\n    this._minerCancellationToken.cancelled = true;\n  }\n\n  // if mining was stopped `mineOnInterval` shouldn't start mining again\n  if (!this.is_mining) {\n    this.logger.log(\"Warning: mineOnInterval called when miner was stopped\");\n    return;\n  }\n\n  const cancellationToken = { cancelled: false };\n  this._minerCancellationToken = cancellationToken;\n\n  const timeout = (this.mining_interval_timeout = setTimeout(\n    this._provider.send.bind(this._provider),\n    this.blockTime * 1000,\n    { method: \"evm_mine\" },\n    () => {\n      if (!cancellationToken.cancelled) {\n        this.mineOnInterval.bind(this)();\n      }\n    }\n  ));\n\n  // Ensure this won't keep a node process open.\n  if (typeof timeout.unref === \"function\") {\n    timeout.unref();\n  }\n};\n\nStateManager.prototype.createAccount = function(opts, i) {\n  var secretKey;\n\n  if (opts.generate) {\n    secretKey = wallet.generate().getPrivateKey();\n  } else if (opts.secretKey) {\n    secretKey = utils.toBuffer(to.hex(opts.secretKey));\n  } else {\n    var index = typeof opts.index === \"undefined\" ? i : opts.index;\n    var acct = this.wallet.derivePath(this.wallet_hdpath + index); // index is a number\n    secretKey = acct.getWallet().getPrivateKey(); // Buffer\n  }\n\n  var publicKey = utils.privateToPublic(secretKey);\n  var address = utils.publicToAddress(publicKey);\n\n  var account = new Account();\n\n  account.balance = to.hex(opts.balance);\n\n  var data = {\n    secretKey: secretKey,\n    publicKey: publicKey,\n    address: to.hex(address).toLowerCase(),\n    account: account\n  };\n\n  return data;\n};\n\nStateManager.prototype.blockNumber = function(callback) {\n  return this.blockchain.getHeight(callback);\n};\n\nStateManager.prototype.gasPrice = function() {\n  return this.gasPriceVal;\n};\n\nStateManager.prototype.getBalance = function(address, number, callback) {\n  this.blockchain.getBalance(address, number, function(err, balance) {\n    if (balance) {\n      balance = to.rpcQuantityHexString(balance);\n    }\n    callback(err, balance);\n  });\n};\n\nStateManager.prototype.getTransactionCount = function(address, number, callback) {\n  this.blockchain.getNonce(address, number, function(err, nonce) {\n    if (nonce) {\n      nonce = to.rpcQuantityHexString(nonce);\n    }\n    callback(err, nonce);\n  });\n};\n\nStateManager.prototype.getCode = function(address, number, callback) {\n  this.blockchain.getCode(address, number, function(err, code) {\n    if (code) {\n      code = to.hex(code);\n    }\n    callback(err, code);\n  });\n};\n\nStateManager.prototype.queueRawTransaction = function(data, callback) {\n  // a hack until we get chainid and networkId alignment\n  // in the next major (breaking_change) version:\n  // Reason: historically we didn't validate chain ids.\n  let chainId;\n  if (Buffer.isBuffer(data)) {\n    const decodedData = rlp.decode(data);\n    let v = decodedData[6];\n    if (v !== undefined) {\n      v = utils.bufferToInt(v);\n      chainId = Math.floor((v - 35) / 2);\n      if (chainId < 0) {\n        chainId = 0;\n      }\n    }\n  }\n  const common = !chainId\n    ? this.blockchain.vm.opts.common\n    : Common.forCustomChain(\n      \"mainnet\", // TODO needs to match chain id\n      {\n        name: \"ganache\",\n        networkId: this.options.network_id || this.blockchain.forkVersion,\n        chainId,\n        comment: \"Local test network\",\n        bootstrapNodes: []\n      },\n      this.options.hardfork\n    );\n  const tx = new Transaction(data, Transaction.types.signed, common);\n  // use toLowerCase() to properly handle from addresses meant to be validated.\n  const from = to.hex(tx.from).toLowerCase();\n  this._queueTransaction(\"eth_sendRawTransaction\", tx, from, null, callback);\n};\n\nStateManager.prototype.queueStorage = function(address, position, block, callback) {\n  this.action_queue.push({\n    method: \"eth_getStorageAt\",\n    address: utils.addHexPrefix(address),\n    position: utils.addHexPrefix(position),\n    block: block,\n    callback: callback\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransaction = function(method, txJsonRpc, blockNumber, callback) {\n  // use toLowerCase() to properly handle from addresses meant to be validated.\n  const from = txJsonRpc.from ? to.hex(txJsonRpc.from).toLowerCase() : null;\n\n  if (from == null) {\n    callback(new TXRejectedError(\"from not found; is required\"));\n    return;\n  }\n\n  // Error checks. It's possible to JSON.stringify a Buffer to JSON.\n  // we actually now handle this \"properly\" (not sure about spec), but for\n  // legacy reasons we don't allow it.\n  if (txJsonRpc.to && typeof txJsonRpc.to !== \"string\") {\n    return callback(new TXRejectedError(\"Invalid to address\"));\n  }\n\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isKnownAccount = hasOwnProperty.call(this.accounts, from);\n\n  if (method === \"eth_sendTransaction\" && !hasOwnProperty.call(this.unlocked_accounts, from)) {\n    const msg = isKnownAccount ? \"signer account is locked\" : \"sender account not recognized\";\n    return callback(new TXRejectedError(msg));\n  }\n\n  let type = Transaction.types.none;\n  if (!isKnownAccount || method === \"eth_call\" || method === \"eth_estimateGas\") {\n    type |= Transaction.types.fake;\n  }\n\n  let tx;\n  try {\n    tx = Transaction.fromJSON(txJsonRpc, type, this.blockchain.vm.opts.common);\n    this._setTransactionDefaults(tx, method === \"eth_sendTransaction\");\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  this._queueTransaction(method, tx, from, blockNumber, callback);\n};\n\nStateManager.prototype._setTransactionDefaults = function(tx, isTransaction) {\n  if (isTransaction && tx.gasLimit.length === 0) {\n    tx.gasLimit = utils.toBuffer(this.blockchain.defaultTransactionGasLimit);\n  }\n\n  if (tx.gasPrice.length === 0) {\n    tx.gasPrice = utils.toBuffer(this.gasPriceVal);\n  }\n\n  if (tx.value.length === 0) {\n    tx.value = Buffer.from([0]);\n  }\n\n  if (tx.to.length === 0 || tx.to.equals(ZERO_BUFFER)) {\n    tx.to = Buffer.allocUnsafe(0);\n  }\n};\n\nStateManager.prototype._queueTransaction = function(method, tx, from, blockNumber, callback) {\n  if (!(tx instanceof Transaction)) {\n    throw new TXRejectedError(\"tx must be of type Transaction\");\n  }\n\n  // If the transaction has a higher gas limit than the block gas limit, error.\n  if (\n    (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") &&\n    to.number(tx.gasLimit) > to.number(this.blockchain.blockGasLimit)\n  ) {\n    return callback(new TXRejectedError(\"Exceeds block gas limit\"));\n  }\n\n  this.action_queue.push({\n    method,\n    from,\n    tx,\n    callback,\n    blockNumber\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.queueTransactionTrace = function(txHash, params, callback) {\n  this.action_queue.push({\n    method: \"debug_traceTransaction\",\n    hash: to.hex(txHash),\n    params: params,\n    callback: callback\n  });\n\n  // We know there's work, so get started.\n  this.processNextAction();\n};\n\nStateManager.prototype.processNextAction = function(override) {\n  var self = this;\n\n  if (override !== true) {\n    if (this.action_processing === true || this.action_queue.length === 0) {\n      return;\n    }\n  }\n\n  var queued = this.action_queue.shift();\n\n  // Set the flag that we're currently processing something.\n  this.action_processing = true;\n\n  var intermediary = function(err, result) {\n    queued.callback(err, result);\n\n    if (self.action_queue.length > 0) {\n      self.processNextAction(true);\n    } else {\n      self.action_processing = false;\n    }\n  };\n\n  if (typeof queued.method === \"function\") {\n    var result = queued.method();\n    return intermediary(null, result);\n  } else if (queued.method === \"eth_getStorageAt\") {\n    this.blockchain.getStorage(queued.address, queued.position, queued.block, function(err, result) {\n      if (err) {\n        return intermediary(err);\n      }\n\n      if (result) {\n        result = utils.rlp.decode(result);\n      }\n\n      result = to.hex(result || 0);\n      intermediary(null, result);\n    });\n  } else if (queued.method === \"debug_traceTransaction\") {\n    this.blockchain.processTransactionTrace(queued.hash, queued.params, intermediary);\n  } else if (queued.method === \"eth_sendTransaction\" || queued.method === \"eth_sendRawTransaction\") {\n    this.processTransaction(queued.from, queued.tx, intermediary);\n  } else if (queued.method === \"eth_call\") {\n    this.processCall(queued.from, queued.tx, queued.blockNumber, intermediary);\n  } else if (queued.method === \"eth_estimateGas\") {\n    this.processGasEstimate(queued.from, queued.tx, queued.blockNumber, intermediary);\n  }\n};\n\nStateManager.prototype.sign = function(address, dataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  var secretKey = account.secretKey;\n  var msg = to.buffer(dataToSign, \"hex\");\n  var msgHash = utils.hashPersonalMessage(msg);\n  var sgn = utils.ecsign(msgHash, Buffer.from(secretKey));\n  // ethereumjs-utils changed the behavior of toRpcSig so that the `v` value\n  // output by `toRpcSig` is always `sgn.v - 27` (basically `0` or `1`). In\n  // order to avoid a breaking change in Ganache at this time we are calculating\n  // a chain ID that will always a) validate the v, and b) generate an output v\n  // of `0` or `1`, like it used to.\n  const v = sgn.v - 27;\n  const chainId = (v - 35) / 2;\n  return utils.toRpcSig(v, sgn.r, sgn.s, chainId);\n};\n\nStateManager.prototype.signTypedData = function(address, typedDataToSign) {\n  var account = this.accounts[to.hex(address).toLowerCase()];\n  if (!account) {\n    throw new Error(\"cannot sign data; no private key\");\n  }\n\n  if (!typedDataToSign.types) {\n    throw new Error(\"cannot sign data; types missing\");\n  }\n\n  if (!typedDataToSign.types.EIP712Domain) {\n    throw new Error(\"cannot sign data; EIP712Domain definition missing\");\n  }\n\n  if (!typedDataToSign.domain) {\n    throw new Error(\"cannot sign data; domain missing\");\n  }\n\n  if (!typedDataToSign.primaryType) {\n    throw new Error(\"cannot sign data; primaryType missing\");\n  }\n\n  if (!typedDataToSign.message) {\n    throw new Error(\"cannot sign data; message missing\");\n  }\n\n  return sigUtil.signTypedData_v4(account.secretKey, { data: typedDataToSign });\n};\n\nStateManager.prototype.printTransactionReceipt = function(txHash, error, callback) {\n  var self = this;\n\n  self.blockchain.getTransactionReceipt(txHash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.latestBlock(function(err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      receipt = receipt.toJSON();\n\n      self.logger.log(\"\");\n      self.logger.log(\"  Transaction: \" + txHash);\n\n      if (receipt.contractAddress != null) {\n        self.logger.log(\"  Contract created: \" + receipt.contractAddress);\n      }\n\n      self.logger.log(\"  Gas usage: \" + parseInt(receipt.gasUsed, 16));\n      self.logger.log(\"  Block Number: \" + parseInt(receipt.blockNumber, 16));\n      self.logger.log(\"  Block Time: \" + new Date(to.number(block.header.timestamp) * 1000).toString());\n\n      if (error) {\n        self.logger.log(\"  Runtime Error: \" + error.error);\n        if (error.reason) {\n          self.logger.log(\"  Revert reason: \" + error.reason);\n        }\n      }\n\n      self.logger.log(\"\");\n\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.processBlock = function(timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  self.blockchain.processNextBlock(timestamp, function(runtimeError, transactions, vmOutput) {\n    if (runtimeError && runtimeError instanceof RuntimeError === false) {\n      // This is bad. Get out.\n      return callback(runtimeError, transactions, vmOutput);\n    }\n\n    // TODO: Can we refactor printTransactionReceipt so it's synchronous?\n    // We technically have the raw vm receipts (though they're not full receipts here...).\n    async.eachSeries(\n      transactions,\n      function(tx, finishedPrinting) {\n        var hash = to.hex(tx.hash());\n        var error = runtimeError == null ? { results: {} } : runtimeError;\n        self.printTransactionReceipt(hash, error.results[hash], finishedPrinting);\n      },\n      callback(runtimeError, transactions, vmOutput)\n    );\n  });\n};\n\nStateManager.prototype.processBlocks = function(totalBlocks, callback) {\n  var self = this;\n\n  if (typeof totalBlocks === \"function\") {\n    callback = totalBlocks;\n    totalBlocks = null;\n  }\n\n  // Note: VM errors (errors that the VM directly returns) trump all runtime errors.\n  var runtimeError = null;\n  var amountProcessed = 0;\n\n  async.whilst(\n    function() {\n      var shouldContinue;\n\n      if (totalBlocks == null) {\n        shouldContinue = self.blockchain.pending_transactions.length > 0;\n      } else {\n        shouldContinue = amountProcessed < totalBlocks;\n      }\n\n      return shouldContinue;\n    },\n    function(done) {\n      self.processBlock(function(err, transactions, vmOutput) {\n        amountProcessed += 1;\n\n        if (err) {\n          if (err instanceof RuntimeError === false) {\n            // This is bad. Get out.\n            return done(err);\n          }\n\n          // We must have a RuntimeError. Merge results if we've found\n          // other runtime errors during this execution.\n          if (runtimeError == null) {\n            runtimeError = err;\n          } else {\n            runtimeError.combine(err);\n          }\n        }\n\n        // Note we don't quit on runtime errors. We keep processing transactions.\n        done();\n      });\n    },\n    function(err) {\n      // Remember: vm errors trump runtime errors\n      callback(err || runtimeError);\n    }\n  );\n};\n\nStateManager.prototype.processCall = function(from, tx, blockNumber, callback) {\n  var self = this;\n\n  function next(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.processCall(tx, blockNumber, function(err, results) {\n      if (err) {\n        if (err instanceof BlockOutOfRangeError) {\n          // block doesn't exist\n          return callback(null, null);\n        }\n        return callback(err);\n      }\n\n      var result = \"0x\";\n      if (!results.error && results.execResult.returnValue) {\n        result = to.hex(results.execResult.returnValue);\n      } else if (results.error) {\n        self.logger.log(`Error processing call: ${results.error}`);\n      }\n\n      return callback(null, result);\n    });\n  }\n\n  // `eth_call` should never need to validate an existing nonce\n  if (tx.nonce.length === 0) {\n    self.createTransactionWithCorrectNonce(tx, from, next);\n  } else {\n    next(null, tx);\n  }\n};\n\nStateManager.prototype.processGasEstimate = function(from, tx, blockNumber, callback) {\n  var self = this;\n\n  function next(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.estimateGas(tx, blockNumber, function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n      var result = \"0x\";\n      if (!results.error) {\n        result = to.hex(results.gasEstimate);\n      } else {\n        self.logger.log(`Error calculating gas estimate: ${results.error}`);\n      }\n      return callback(null, result);\n    });\n  }\n\n  // `eth_estimateGas` should never need to validate an existing nonce\n  if (tx.nonce.length === 0) {\n    self.createTransactionWithCorrectNonce(tx, from, next);\n  } else {\n    next(null, tx);\n  }\n};\n\nStateManager.prototype.processTransaction = function(from, tx, callback) {\n  var self = this;\n\n  self.createTransactionWithCorrectNonce(tx, from, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.blockchain.queueTransaction(tx);\n\n    var txHash = to.hex(tx.hash());\n\n    // If we're not currently mining or we're mining on an interval,\n    // only queue the transaction, don't process it.\n    if (self.is_mining === false || self.is_mining_on_interval) {\n      return callback(null, txHash);\n    }\n\n    self.processBlocks(function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, txHash);\n    });\n  });\n};\n\nStateManager.prototype.getTransactionReceipt = function(hash, callback) {\n  this.blockchain.getTransactionReceipt(hash, function(err, receipt) {\n    if (err && err.notFound) {\n      // Return null if the receipt's not found.\n      return callback(null, null);\n    }\n    callback(err, receipt);\n  });\n};\n\nStateManager.prototype.getBlock = function(hashOrNumber, callback) {\n  this.blockchain.getBlock(hashOrNumber, callback);\n};\n\nStateManager.prototype.getLogs = function(filter, callback) {\n  var self = this;\n\n  // filter.address may be a single address or an array\n  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs\n  var expectedAddress = filter.address && (Array.isArray(filter.address) ? filter.address : [filter.address]);\n  expectedAddress =\n    expectedAddress &&\n    expectedAddress.map(function(a) {\n      return a.toLowerCase();\n    });\n  var expectedTopics = filter.topics || [];\n\n  async.parallel(\n    {\n      fromBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.fromBlock || \"latest\"),\n      toBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, filter.toBlock || \"latest\"),\n      latestBlock: this.blockchain.getEffectiveBlockNumber.bind(this.blockchain, \"latest\"),\n      block: this.blockchain.getBlock.bind(this.blockchain, filter.blockHash || 0)\n    },\n    function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n      var fromBlock = results.fromBlock;\n      var toBlock = results.toBlock;\n      var latestBlock = results.latestBlock;\n      var block = results.block;\n\n      if (toBlock > latestBlock) {\n        toBlock = latestBlock;\n      }\n\n      if (filter.blockHash) {\n        fromBlock = to.number(block.header.number);\n        toBlock = to.number(block.header.number);\n      }\n\n      var logs = [];\n      var current = fromBlock;\n\n      async.whilst(\n        function() {\n          return current <= toBlock;\n        },\n        function(finished) {\n          self.blockchain.getBlockLogs(current, function(err, blockLogs) {\n            if (err) {\n              return finished(err);\n            }\n\n            // Filter logs that match the address\n            var filtered = !expectedAddress\n              ? blockLogs\n              : blockLogs.filter(function(log) {\n                return expectedAddress.indexOf(log.address.toLowerCase()) > -1;\n              });\n\n            // Now filter based on topics.\n            filtered = filtered.filter(function(log) {\n              var keep = true;\n              for (var i = 0; i < expectedTopics.length; i++) {\n                var expectedTopic = expectedTopics[i];\n                var logTopic = log.topics[i];\n                if (expectedTopic == null) {\n                  continue;\n                }\n                var isMatch = Array.isArray(expectedTopic)\n                  ? expectedTopic.includes(logTopic)\n                  : expectedTopic === logTopic;\n                if (i >= log.topics.length || !isMatch) {\n                  keep = false;\n                  break;\n                }\n              }\n              return keep;\n            });\n\n            logs.push.apply(logs, filtered);\n\n            current += 1;\n            finished();\n          });\n        },\n        function(err) {\n          if (err) {\n            return callback(err);\n          }\n\n          logs = logs.map(function(log) {\n            return log.toJSON();\n          });\n\n          callback(err, logs);\n        }\n      );\n    }\n  );\n};\n\n// Note: Snapshots have 1-based ids.\nStateManager.prototype.snapshot = function(callback) {\n  var self = this;\n\n  this.blockchain.getHeight(function(err, blockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.snapshots.push({\n      blockNumber: blockNumber,\n      timeAdjustment: self.blockchain.timeAdjustment\n    });\n\n    self.logger.log(\"Saved snapshot #\" + self.snapshots.length);\n\n    callback(null, to.hex(self.snapshots.length));\n  });\n};\n\nStateManager.prototype.revert = function(snapshotId, callback) {\n  var self = this;\n\n  if (snapshotId === null || snapshotId === undefined) {\n    callback(new Error(\"invalid snapshotId\"));\n    return;\n  }\n  // Convert from hex.\n  try {\n    snapshotId = utils.bufferToInt(snapshotId);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  this.logger.log(\"Reverting to snapshot #\" + snapshotId);\n\n  if (snapshotId > this.snapshots.length || snapshotId <= 0) {\n    // the snapshot doesn't exist now, or it has already been reverted\n    callback(null, false);\n    return false;\n  }\n\n  // Convert to zero based.\n  snapshotId = snapshotId - 1;\n  var timeAdjustment = this.snapshots[snapshotId].timeAdjustment;\n\n  // Loop through each snapshot with a higher id than the current one.\n  async.whilst(\n    function() {\n      return self.snapshots.length > snapshotId;\n    },\n    function(nextSnapshot) {\n      var snapshot = self.snapshots.pop();\n\n      // For each snapshot, asynchronously pop off the blocks it represents.\n      async.during(\n        function(doneWithTest) {\n          self.blockchain.getHeight(function(err, blockNumber) {\n            if (err) {\n              return doneWithTest(err);\n            }\n\n            doneWithTest(null, blockNumber > snapshot.blockNumber);\n          });\n        },\n        function(nextBlock) {\n          self.blockchain.popBlock(function(err) {\n            if (err) {\n              return nextBlock(err);\n            }\n            nextBlock();\n          });\n        },\n        nextSnapshot\n      );\n    },\n    function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Pending transactions are removed when you revert.\n      self.blockchain.clearPendingTransactions();\n      // The time adjustment is restored to its prior state\n      self.blockchain.timeAdjustment = timeAdjustment;\n\n      callback(null, true);\n    }\n  );\n};\n\nStateManager.prototype.hasContractCode = function(address, callback) {\n  this.vm.stateManager.getContractCode(address, function(err, result) {\n    if (err != null) {\n      callback(err, false);\n    } else {\n      callback(null, true);\n    }\n  });\n};\n\nStateManager.prototype.startMining = function(callback) {\n  if (this.is_mining) {\n    process.nextTick(callback);\n    this.logger.log(\"Warning: startMining called when miner was already started\");\n    return;\n  }\n\n  this.is_mining = true;\n\n  if (this.is_mining_on_interval) {\n    this.mineOnInterval();\n    process.nextTick(callback);\n  } else {\n    this.processBlocks(callback);\n  }\n};\n\nStateManager.prototype.stopMining = function(callback) {\n  if (this.is_mining) {\n    if (this._minerCancellationToken) {\n      this._minerCancellationToken.cancelled = true;\n      this._minerCancellationToken = null;\n    }\n    this.is_mining = false;\n    clearTimeout(this.mining_interval_timeout);\n    this.mining_interval_timeout = null;\n  } else {\n    this.logger.log(\"Warning: stopMining called when miner was already stopped\");\n  }\n  callback && process.nextTick(callback);\n};\n\nStateManager.prototype.isUnlocked = function(address) {\n  return this.unlocked_accounts[address.toLowerCase()] != null;\n};\n\nStateManager.prototype.createTransactionWithCorrectNonce = function(tx, from, callback) {\n  // account for transactions waiting in the tx queue\n  this.blockchain.getQueuedNonce(from, (err, expectedNonce) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const validateNonce = (tx, expectedNonce) => {\n      if (tx.validateNonce(expectedNonce)) {\n        return Promise.resolve(tx);\n      } else {\n        const expected = new BN(expectedNonce).toString(10);\n        const actual = new BN(tx.nonce).toString(10);\n        return Promise.reject(\n          new TXRejectedError(\n            `the tx doesn't have the correct nonce. account has nonce of: ${expected} tx has nonce of: ${actual}`\n          )\n        );\n      }\n    };\n    const done = (tx) => callback(null, tx);\n\n    if (tx.isSigned()) {\n      validateNonce(tx, expectedNonce)\n        .then(done)\n        .catch(callback);\n    } else {\n      const sign = (tx) => {\n        // we need to sign transactions if they haven't been signed already\n        // but we never sign fake transactions\n        if (!tx.isFake() && !tx.isSigned()) {\n          const account = this.accounts[from];\n          if (account) {\n            tx.sign(account.secretKey);\n          }\n        }\n        return Promise.resolve(tx);\n      };\n\n      // Validate the tx's nonce and then sign the transaction.\n      // By signing this transaction now we ensure all future calls to tx.hash()\n      // return the same signed transaction hash. It's sort of an unintuitive\n      // quirk of etheremjs-tx that:\n      //   tx.hash(includeSignature);\n      //   tx.sign(secretKey);\n      //   tx.hash(includeSignature);\n      // will produce different hashes.\n      if (tx.nonce.length === 0) {\n        // Since this transaction is unsigned and the nonce was not defined\n        // we can go ahead and change the nonce and not worry about\n        // invalidating the tx hash the client may be expecting (automatic nonce\n        // calculation should have been expected by the client in this case).\n        tx.nonce = expectedNonce;\n        sign(tx).then(done);\n      } else {\n        validateNonce(tx, expectedNonce)\n          .then(sign)\n          .then(done)\n          .catch(callback);\n      }\n    }\n  });\n};\nmodule.exports = StateManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
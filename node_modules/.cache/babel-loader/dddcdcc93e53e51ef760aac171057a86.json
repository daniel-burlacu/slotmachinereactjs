{"ast":null,"code":"\"use strict\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n    return false;\n  }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_typeof","obj","assert","require","comments","_require","getParentExportDeclaration","isExportDeclaration","shouldFlatten","getNextNonSpaceNonCommentCharacter","hasNewline","hasNewlineInRange","getLast","getStringWidth","printString","printNumber","hasIgnoreComment","skipWhitespace","hasNodeIgnoreComment","getPenultimate","startsWithNoLookaheadToken","getIndentSize","matchAncestorTypes","getPreferredQuote","_require2","isNextLineEmpty","isNextLineEmptyAfterIndex","getNextNonSpaceNonCommentCharacterIndex","isIdentifierName","keyword","isIdentifierNameES5","embed","clean","insertPragma","handleComments","pathNeedsParens","_require3","printHtmlBinding","isVueEventBindingExpression","preprocess","_require4","getLeftSide","getLeftSidePathName","hasNakedLeftSide","hasNode","hasFlowAnnotationComment","hasFlowShorthandAnnotationComment","needsQuoteProps","WeakMap","_require5","_require5$builders","builders","concat","join","line","hardline","softline","literalline","group","indent","align","conditionalGroup","fill","ifBreak","breakParent","lineSuffixBoundary","addAlignmentToDoc","dedent","_require5$utils","utils","willBreak","isLineNext","isEmpty","removeLines","printDocToString","printer","uid","shouldPrintComma","options","level","trailingComma","genericPrint","path","printPath","args","node","getValue","needsParens","linesWithoutParens","printPathNoParens","parentExportDecl","decorators","type","locStart","ignoreDecorators","shouldBreak","hasNewlineBetweenOrAfterDecorators","separator","each","decoratorPath","decorator","expression","callee","push","unshift","declaration","prefix","parts","_node","trailingComments","value","trimLeft","printed","originalText","locEnd","printDecorators","print","map","hasPrettierIgnore","hasJsxIgnoreComment","parent","getParentNode","isJSXNode","index","children","indexOf","prevSibling","candidate","isMeaningfulJSXText","find","comment","trim","printTernaryOperator","operatorOptions","testNode","testNodePropertyName","consequentNode","consequentNodePropertyName","alternateNode","alternateNodePropertyName","jsxMode","forceNoIndent","conditionalNodeType","currentParent","previousParent","firstNonConditionalParent","lastConditionalParent","shouldCheckJsx","conditionalExpressionChainContainsJSX","wrap","doc","isNull","part","useTabs","Math","max","tabWidth","maybeGroup","breakNested","breakClosingParen","computed","testDoc","beforeParts","afterParts","getTypeScriptMappedTypeModifier","tokenNode","semi","htmlBinding","program","interpreter","programPath","directives","childPath","bodyPath","printStatementSequence","printDanglingComments","body","directive","nodeStr","parser","isTheOnlyJSXElementInMarkdown","printAssignment","left","operator","right","_parent","parentParent","isInsideParenthesis","_parts","printBinaryishExpressions","shouldNotIndent","shouldIndentIfInlining","samePrecedenceSubExpression","isBinaryish","shouldInlineLogicalExpression","hasJSX","rest","groupId","chain","id","jsxPart","shouldBreakAfterCast","castGroup","exprContents","_parent2","firstNonMemberParent","shouldInline","object","property","printMemberLookup","printBindExpressionCallee","printOptionalToken","printTypeAnnotation","printFunctionDeclaration","async","shouldPrintParamsWithoutParens","printFunctionParams","expandLastArg","expandFirstArg","printReturnType","dangling","nextCharacter","substr","hasLeadingOwnLineComment","isTemplateOnItsOwnLine","shouldAddSoftLine","printTrailingComma","shouldAddParens","accessibility","printMethod","delegate","argument","importKind","local","imported","exported","printExportDeclaration","exportKind","standalones","grouped","specifiers","specifierPath","some","bracketSpacing","source","naked","hasContent","hasDirectives","_parent3","_parentParent","hasDanglingComments","finalizer","returnArgumentHasLeadingComment","isNew","optional","arguments","isTestCall","printFunctionTypeParameters","isIdentifierWithFlowAnnotation","isMemberish","printMemberChain","substring","printArgumentsList","isNodeStartingWithDeclare","printTypeScriptModifiers","typeParameters","identity","method","propertiesField","isTypeAnnotation","fields","firstProperty","field","sort","a","b","_parent4","isFlowInterfaceLikeBody","getName","properties","leftBrace","exact","rightBrace","propsAndLoc","forEach","loc","separatorParts","props","prop","result","shift","inexact","lastElem","canHaveTrailingSeparator","content","parentParentParent","shouldHugArguments","params","shouldHugType","typeAnnotation","kind","shorthand","printedLeft","printPropertyKey","key","printObjectMethod","elements","_lastElem","canHaveTrailingComma","needsForcedTrailingComma","printArrayItems","_parent5","_parts2","p","printRegex","extra","raw","rawValue","regex","grandParent","isTypeScriptDirective","reverse","parentNode","isParentForLoop","hasValue","declarations","decl","init","firstVariable","declare","_printed","printAssignmentRight","adjustClause","con","consequent","opening","alternate","commentOnOwnLine","hasTrailingComment","trailing","isBlockComment","needsHardlineAfterDanglingComment","elseOnSameLine","_body","_dangling","printedComments","update","isAwait","clause","doBody","label","handler","param","hasComments","leading","backwards","cases","casePath","caseNode","filter","cons","consequentPath","res","isStringLiteral","rawText","_final","replace","quote","jsxSingleQuote","_escape","RegExp","printComments","_parent6","preventInline","_shouldInline","elem","printJSXElement","maybeWrapJSXElementInParens","_n","nameHasComments","selfClosing","attributes","includes","lastAttrHasTrailingComments","bracketSameLine","jsxBracketSameLine","_shouldBreak","attr","hasComment","hasOwnLineComment","every","isOpeningFragment","Error","requiresHardline","readonly","variance","getFlowVariance","printClass","split","expressions","_parentNode","isJestEachTemplateLiteral","_printed2","printJestEachTemplateLiteral","isSimple","isSimpleTemplateLiteral","assign","printWidth","Infinity","formatted","quasi","indentSize","_printed3","aligned","endsWith","JSON","stringify","typesField","printFlowDeclaration","predicate","supertype","impltype","_parent7","_parentParent2","_parentParentParent","isArrowFunctionTypeAnnotation","needsColon","isObjectTypePropertyAFunction","returnType","types","wasIndented","_i","isObjectType","_parent8","shouldIndent","shouldHug","_printed4","typePath","printedType","shouldAddStartLine","code","hasParens","_grandParent","getNode","greatGrandParent","greatGreatGrandParent","_variance","_variance2","modifier","proto","isGetterOrSetter","isFunctionNotation","strictEqual","_printed5","commentSyntax","range","match","_value","commentStart","lastIndexOf","_commentSyntax","printTypeParameters","_parent9","constraint","_variance3","bound","_grandParent2","filepath","initializer","_parent10","parameters","isTypeOf","qualifier","isType","_shouldBreak2","modifiers","members","isExport","_parent11","isExternalModule","isLiteral","parentIsDeclaration","bodyIsDeclaration","textBetweenNodeAndItsId","isGlobalDeclaration","trimRight","hasNgSideEffect","isNgForOf","alias","_parentNode2","shouldNotPrintColon","undefined","bodyNode","isClass","stmtPath","stmt","stmtPrinted","text","stmtNeedsASIProtection","needsSemi","classPropMayCauseASIProblems","nextChild","classChildNeedsASIProtection","isLastStatement","quoteProps","has","objectHasStringProp","isStringPropSafeToCoerceToIdentifier","set","get","keyPath","generator","ok","valuePath","couldGroupArg","arg","shouldGroupLastArg","lastArg","penultimateArg","hasLeadingComment","shouldGroupFirstArg","firstArg","secondArg","isSimpleFlowType","flowTypeAnnotations","jestEachTriggerRegex","tag","headerNames","quasis","headerName","stringifiedExpressions","endOfLine","tableBody","hasLineBreak","cells","row","correspondingExpression","maxColumnCount","reduce","maxColumnWidths","table","cell","repeat","expr","ancestor","functionCompositionFunctionNames","Set","ordinaryMethodNames","isFunctionCompositionFunction","hasEmptyLineInObjectArgInArrowFunction","anyArgEmptyLine","hasEmptyLineFollowingFirstArg","lastArgIndex","printedArguments","argPath","maybeTrailingComma","allArgsBrokenOut","shouldGroupFirst","shouldGroupLast","printedExpanded","somePrintedArgumentsWillBreak","simpleConcat","isDefinite","definite","isFunctionDeclarationIdentifier","isFlowAnnotationComment","fun","typeArguments","expandArg","printTypeParams","paramsField","isParametersInTestCall","shouldHugParameters","shouldExpandParameters","typeParams","lastParam","hasNotParameterDecorator","isFlowShorthandWithOneArg","isTypeAnnotationAFunction","arrowParens","canPrintParamsWithoutParens","objMethod","isDefault","defaultSpecifiers","namespaceSpecifiers","specifierType","isNamespaceFollowed","isDefaultFollowed","canBreak","paramsKey","grandparent","isParameterInTestCall","typeName","partsGroup","superClass","isNumericLiteral","printedNodes","shouldInsertEmptyLineAfter","nextCharIndex","nextChar","charAt","rec","groups","currentGroup","hasSeenCallExpression","isFactory","isShort","shouldNotWrap","isExpression","hasComputed","firstNode","lastNode","shouldMerge","printGroup","printedGroup","tuple","printIndentedGroup","printedGroups","oneLine","cutoff","flatGroups","lastNodeBeforeIndent","shouldHaveEmptyLineBeforeIndent","expanded","callExpressions","_ref","isCallOrOptionalCallExpression","lastGroupDoc","lastGroupNode","isFunctionOrArrowExpression","isEmptyJSXElement","child","jsxWhitespaceChars","containsNonJsxWhitespaceRegex","matchJsxWhitespaceRegex","Boolean","getConditionalChainContents","nonConditionalExpressions","recurse","isJSXWhitespaceExpression","separatorNoWhitespace","isFacebookTranslationTag","childNode","nextNode","closingElement","separatorWithWhitespace","printJSXChildren","jsxWhitespace","words","next","endWhitespace","pop","word","_next","_next2","printedChild","_next3","directlyFollowedByMeaningfulText","firstWord","openingLines","closingLines","containsTag","containsMultipleExpressions","containsMultipleAttributes","openingElement","forcedBreak","rawJsxWhitespace","singleQuote","containsText","isPairOfEmptyStrings","isPairOfHardlines","isLineFollowedByJSXWhitespace","isJSXWhitespaceFollowedByLine","isDoubleJSXWhitespace","isPairOfHardOrSoftLines","splice","multilineChildren","multiLineElem","NO_WRAP_PARENTS","ArrayExpression","JSXAttribute","JSXElement","JSXExpressionContainer","JSXFragment","ExpressionStatement","CallExpression","OptionalCallExpression","ConditionalExpression","JsExpressionRoot","isNested","lineBeforeOperator","rightSuffix","shouldGroup","leftNode","rightNode","printedRight","isMemberExpressionChain","forceSpace","isFlowOrTypeScriptDirectiveLiteral","isDirectiveLiteral","flags","pattern","start","end","exprNeedsASIProtection","maybeASIProblem","apply","isAsync","isGenerator","leftMost","newLeftMost","sameLocStart","nodeA","nodeB","startsWith","voidCount","objectCount","templateLiteralHasNewLines","template","printedElements","lastDanglingComment","unitTestRe","isAngularTestWrapper","isUnitTestSetUp","isSkipOrOnlyBlock","isTemplateLiteral","isFunctionOrArrowExpressionWithBody","unitTestSetUpRe","parentParser","willPrintOwnComments","leadingComments","canAttachComment","printComment","commentPath","isIndentableBlockComment","printIndentableBlockComment","isInsideFlowComment","lines","x","module","exports","massageAstNode","ownLine","handleOwnLineComment","handleEndOfLineComment","remaining","handleRemainingComment"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/language-js/printer-estree.js"],"sourcesContent":["\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n      return false;\n    }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
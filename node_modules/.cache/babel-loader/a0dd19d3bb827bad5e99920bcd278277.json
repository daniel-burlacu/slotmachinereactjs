{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar diff = require(\"diff\");\n\nvar normalizeOptions = require(\"./options\").normalize;\n\nvar massageAST = require(\"./massage-ast\");\n\nvar comments = require(\"./comments\");\n\nvar parser = require(\"./parser\");\n\nvar printAstToDoc = require(\"./ast-to-doc\");\n\nvar _require = require(\"../common/end-of-line\"),\n    guessEndOfLine = _require.guessEndOfLine,\n    convertEndOfLineToChars = _require.convertEndOfLineToChars;\n\nvar rangeUtil = require(\"./range-util\");\n\nvar privateUtil = require(\"../common/util\");\n\nvar _require2 = require(\"../doc\"),\n    mapDoc = _require2.utils.mapDoc,\n    _printDocToString = _require2.printer.printDocToString,\n    printDocToDebug = _require2.debug.printDocToDebug;\n\nvar UTF8BOM = 0xfeff;\nvar CURSOR = Symbol(\"cursor\");\nvar PLACEHOLDERS = {\n  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n};\n\nfunction ensureAllCommentsPrinted(astComments) {\n  if (!astComments) {\n    return;\n  }\n\n  for (var i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(function (comment) {\n    if (!comment.printed) {\n      throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n    }\n\n    delete comment.printed;\n  });\n}\n\nfunction attachComments(text, ast, opts) {\n  var astComments = ast.comments;\n\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n\n  ast.tokens = [];\n  opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n  return astComments;\n}\n\nfunction coreFormat(text, opts, addAlignmentSize) {\n  if (!text || !text.trim().length) {\n    return {\n      formatted: \"\",\n      cursorOffset: 0\n    };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n\n  if (opts.cursorOffset >= 0) {\n    var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  var astComments = attachComments(text, ast, opts);\n  var doc = printAstToDoc(ast, opts, addAlignmentSize);\n  var eol = convertEndOfLineToChars(opts.endOfLine);\n\n  var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc(doc, function (currentDoc) {\n    return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n  }), opts);\n\n  ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n  if (addAlignmentSize > 0) {\n    var trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    var oldCursorNodeStart;\n    var oldCursorNodeText;\n    var cursorOffsetRelativeToOldCursorNode;\n    var newCursorNodeStart;\n    var newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n      };\n    } // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n\n    var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n    var cursorOffset = newCursorNodeStart;\n\n    var _iterator = _createForOfIteratorHelper(cursorNodeDiff),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n\n        if (entry.removed) {\n          if (entry.value.indexOf(CURSOR) > -1) {\n            break;\n          }\n        } else {\n          cursorOffset += entry.count;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      formatted: result.formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  return {\n    formatted: result.formatted\n  };\n}\n\nfunction formatRange(text, opts) {\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n  var range = rangeUtil.calculateRange(text, opts, ast);\n  var rangeStart = range.rangeStart;\n  var rangeEnd = range.rangeEnd;\n  var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n  var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  var indentString = text.slice(rangeStart2, rangeStart);\n  var alignmentSize = privateUtil.getAlignmentSize(indentString, opts.tabWidth);\n  var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n    rangeStart: 0,\n    rangeEnd: Infinity,\n    // track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n  }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n\n  var rangeTrimmed = rangeResult.formatted.trimRight();\n  var rangeLeft = text.slice(0, rangeStart);\n  var rangeRight = text.slice(rangeEnd);\n  var cursorOffset = opts.cursorOffset;\n\n  if (opts.cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n  } else if (rangeResult.cursorOffset !== undefined) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  } // keep the cursor as it was if it was before the start of the range\n\n\n  var formatted;\n\n  if (opts.endOfLine === \"lf\") {\n    formatted = rangeLeft + rangeTrimmed + rangeRight;\n  } else {\n    var eol = convertEndOfLineToChars(opts.endOfLine);\n\n    if (cursorOffset >= 0) {\n      var parts = [rangeLeft, rangeTrimmed, rangeRight];\n      var partIndex = 0;\n      var partOffset = cursorOffset;\n\n      while (partIndex < parts.length) {\n        var part = parts[partIndex];\n\n        if (partOffset < part.length) {\n          parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n          break;\n        }\n\n        partIndex++;\n        partOffset -= part.length;\n      }\n\n      var newRangeLeft = parts[0],\n          newRangeTrimmed = parts[1],\n          newRangeRight = parts[2];\n      formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n        cursorOffset = index;\n        return \"\";\n      });\n    } else {\n      formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n    }\n  }\n\n  return {\n    formatted: formatted,\n    cursorOffset: cursorOffset\n  };\n}\n\nfunction format(text, opts) {\n  var selectedParser = parser.resolveParser(opts);\n  var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n  if (opts.requirePragma && !hasPragma) {\n    return {\n      formatted: text\n    };\n  }\n\n  if (opts.endOfLine === \"auto\") {\n    opts.endOfLine = guessEndOfLine(text);\n  }\n\n  var hasCursor = opts.cursorOffset >= 0;\n  var hasRangeStart = opts.rangeStart > 0;\n  var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n  if (text.indexOf(\"\\r\") !== -1) {\n    var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n      return opts[aKey] - opts[bKey];\n    });\n\n    for (var i = offsetKeys.length - 1; i >= 0; i--) {\n      var key = offsetKeys[i];\n      text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n    }\n\n    text = text.replace(/\\r\\n?/g, \"\\n\");\n\n    var _loop = function _loop(_i) {\n      var key = offsetKeys[_i];\n      text = text.replace(PLACEHOLDERS[key], function (_, index) {\n        opts[key] = index;\n        return \"\";\n      });\n    };\n\n    for (var _i = 0; _i < offsetKeys.length; _i++) {\n      _loop(_i);\n    }\n  }\n\n  var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n  if (hasUnicodeBOM) {\n    text = text.substring(1);\n\n    if (hasCursor) {\n      opts.cursorOffset++;\n    }\n\n    if (hasRangeStart) {\n      opts.rangeStart++;\n    }\n\n    if (hasRangeEnd) {\n      opts.rangeEnd++;\n    }\n  }\n\n  if (!hasCursor) {\n    opts.cursorOffset = -1;\n  }\n\n  if (opts.rangeStart < 0) {\n    opts.rangeStart = 0;\n  }\n\n  if (opts.rangeEnd > text.length) {\n    opts.rangeEnd = text.length;\n  }\n\n  var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n  if (hasUnicodeBOM) {\n    result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n    if (hasCursor) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: function formatWithCursor(text, opts) {\n    opts = normalizeOptions(opts);\n    return format(text, opts);\n  },\n  parse: function parse(text, opts, massage) {\n    opts = normalizeOptions(opts);\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    var parsed = parser.parse(text, opts);\n\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, opts);\n    }\n\n    return parsed;\n  },\n  formatAST: function formatAST(ast, opts) {\n    opts = normalizeOptions(opts);\n    var doc = printAstToDoc(ast, opts);\n    return _printDocToString(doc, opts);\n  },\n  // Doesn't handle shebang for now\n  formatDoc: function formatDoc(doc, opts) {\n    var debug = printDocToDebug(doc);\n    opts = normalizeOptions(Object.assign({}, opts, {\n      parser: \"babel\"\n    }));\n    return format(debug, opts).formatted;\n  },\n  printToDoc: function printToDoc(text, opts) {\n    opts = normalizeOptions(opts);\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    attachComments(text, ast, opts);\n    return printAstToDoc(ast, opts);\n  },\n  printDocToString: function printDocToString(doc, opts) {\n    return _printDocToString(doc, normalizeOptions(opts));\n  }\n};","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","diff","require","normalizeOptions","normalize","massageAST","comments","parser","printAstToDoc","_require","guessEndOfLine","convertEndOfLineToChars","rangeUtil","privateUtil","_require2","mapDoc","utils","_printDocToString","printer","printDocToString","printDocToDebug","debug","UTF8BOM","CURSOR","PLACEHOLDERS","cursorOffset","rangeStart","rangeEnd","ensureAllCommentsPrinted","astComments","trim","forEach","comment","printed","Error","attachComments","text","ast","opts","attach","tokens","originalText","trimRight","coreFormat","addAlignmentSize","formatted","parsed","parse","nodeResult","findNodeAtOffset","node","cursorNode","doc","eol","endOfLine","result","currentDoc","indexOf","replace","trimmed","cursorNodeStart","undefined","oldCursorNodeStart","oldCursorNodeText","cursorOffsetRelativeToOldCursorNode","newCursorNodeStart","newCursorNodeText","cursorNodeText","locStart","locEnd","oldCursorNodeCharArray","split","splice","newCursorNodeCharArray","cursorNodeDiff","diffArrays","_iterator","_step","entry","removed","count","formatRange","range","calculateRange","rangeString","rangeStart2","Math","min","lastIndexOf","indentString","alignmentSize","getAlignmentSize","tabWidth","rangeResult","assign","Infinity","rangeTrimmed","rangeLeft","rangeRight","parts","partIndex","partOffset","part","newRangeLeft","newRangeTrimmed","newRangeRight","_","index","format","selectedParser","resolveParser","hasPragma","requirePragma","hasCursor","hasRangeStart","hasRangeEnd","offsetKeys","filter","Boolean","sort","aKey","bKey","key","_loop","_i","hasUnicodeBOM","charCodeAt","substring","insertPragma","String","fromCharCode","module","exports","formatWithCursor","massage","formatAST","formatDoc","printToDoc"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/main/core.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar diff = require(\"diff\");\n\nvar normalizeOptions = require(\"./options\").normalize;\n\nvar massageAST = require(\"./massage-ast\");\n\nvar comments = require(\"./comments\");\n\nvar parser = require(\"./parser\");\n\nvar printAstToDoc = require(\"./ast-to-doc\");\n\nvar _require = require(\"../common/end-of-line\"),\n    guessEndOfLine = _require.guessEndOfLine,\n    convertEndOfLineToChars = _require.convertEndOfLineToChars;\n\nvar rangeUtil = require(\"./range-util\");\n\nvar privateUtil = require(\"../common/util\");\n\nvar _require2 = require(\"../doc\"),\n    mapDoc = _require2.utils.mapDoc,\n    _printDocToString = _require2.printer.printDocToString,\n    printDocToDebug = _require2.debug.printDocToDebug;\n\nvar UTF8BOM = 0xfeff;\nvar CURSOR = Symbol(\"cursor\");\nvar PLACEHOLDERS = {\n  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n};\n\nfunction ensureAllCommentsPrinted(astComments) {\n  if (!astComments) {\n    return;\n  }\n\n  for (var i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(function (comment) {\n    if (!comment.printed) {\n      throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n    }\n\n    delete comment.printed;\n  });\n}\n\nfunction attachComments(text, ast, opts) {\n  var astComments = ast.comments;\n\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n\n  ast.tokens = [];\n  opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n  return astComments;\n}\n\nfunction coreFormat(text, opts, addAlignmentSize) {\n  if (!text || !text.trim().length) {\n    return {\n      formatted: \"\",\n      cursorOffset: 0\n    };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n\n  if (opts.cursorOffset >= 0) {\n    var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  var astComments = attachComments(text, ast, opts);\n  var doc = printAstToDoc(ast, opts, addAlignmentSize);\n  var eol = convertEndOfLineToChars(opts.endOfLine);\n\n  var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc(doc, function (currentDoc) {\n    return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n  }), opts);\n\n  ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n  if (addAlignmentSize > 0) {\n    var trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    var oldCursorNodeStart;\n    var oldCursorNodeText;\n    var cursorOffsetRelativeToOldCursorNode;\n    var newCursorNodeStart;\n    var newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n      };\n    } // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n\n    var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n    var cursorOffset = newCursorNodeStart;\n\n    var _iterator = _createForOfIteratorHelper(cursorNodeDiff),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n\n        if (entry.removed) {\n          if (entry.value.indexOf(CURSOR) > -1) {\n            break;\n          }\n        } else {\n          cursorOffset += entry.count;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      formatted: result.formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  return {\n    formatted: result.formatted\n  };\n}\n\nfunction formatRange(text, opts) {\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n  var range = rangeUtil.calculateRange(text, opts, ast);\n  var rangeStart = range.rangeStart;\n  var rangeEnd = range.rangeEnd;\n  var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n  var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  var indentString = text.slice(rangeStart2, rangeStart);\n  var alignmentSize = privateUtil.getAlignmentSize(indentString, opts.tabWidth);\n  var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n    rangeStart: 0,\n    rangeEnd: Infinity,\n    // track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n  }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n\n  var rangeTrimmed = rangeResult.formatted.trimRight();\n  var rangeLeft = text.slice(0, rangeStart);\n  var rangeRight = text.slice(rangeEnd);\n  var cursorOffset = opts.cursorOffset;\n\n  if (opts.cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n  } else if (rangeResult.cursorOffset !== undefined) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  } // keep the cursor as it was if it was before the start of the range\n\n\n  var formatted;\n\n  if (opts.endOfLine === \"lf\") {\n    formatted = rangeLeft + rangeTrimmed + rangeRight;\n  } else {\n    var eol = convertEndOfLineToChars(opts.endOfLine);\n\n    if (cursorOffset >= 0) {\n      var parts = [rangeLeft, rangeTrimmed, rangeRight];\n      var partIndex = 0;\n      var partOffset = cursorOffset;\n\n      while (partIndex < parts.length) {\n        var part = parts[partIndex];\n\n        if (partOffset < part.length) {\n          parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n          break;\n        }\n\n        partIndex++;\n        partOffset -= part.length;\n      }\n\n      var newRangeLeft = parts[0],\n          newRangeTrimmed = parts[1],\n          newRangeRight = parts[2];\n      formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n        cursorOffset = index;\n        return \"\";\n      });\n    } else {\n      formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n    }\n  }\n\n  return {\n    formatted: formatted,\n    cursorOffset: cursorOffset\n  };\n}\n\nfunction format(text, opts) {\n  var selectedParser = parser.resolveParser(opts);\n  var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n  if (opts.requirePragma && !hasPragma) {\n    return {\n      formatted: text\n    };\n  }\n\n  if (opts.endOfLine === \"auto\") {\n    opts.endOfLine = guessEndOfLine(text);\n  }\n\n  var hasCursor = opts.cursorOffset >= 0;\n  var hasRangeStart = opts.rangeStart > 0;\n  var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n  if (text.indexOf(\"\\r\") !== -1) {\n    var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n      return opts[aKey] - opts[bKey];\n    });\n\n    for (var i = offsetKeys.length - 1; i >= 0; i--) {\n      var key = offsetKeys[i];\n      text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n    }\n\n    text = text.replace(/\\r\\n?/g, \"\\n\");\n\n    var _loop = function _loop(_i) {\n      var key = offsetKeys[_i];\n      text = text.replace(PLACEHOLDERS[key], function (_, index) {\n        opts[key] = index;\n        return \"\";\n      });\n    };\n\n    for (var _i = 0; _i < offsetKeys.length; _i++) {\n      _loop(_i);\n    }\n  }\n\n  var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n  if (hasUnicodeBOM) {\n    text = text.substring(1);\n\n    if (hasCursor) {\n      opts.cursorOffset++;\n    }\n\n    if (hasRangeStart) {\n      opts.rangeStart++;\n    }\n\n    if (hasRangeEnd) {\n      opts.rangeEnd++;\n    }\n  }\n\n  if (!hasCursor) {\n    opts.cursorOffset = -1;\n  }\n\n  if (opts.rangeStart < 0) {\n    opts.rangeStart = 0;\n  }\n\n  if (opts.rangeEnd > text.length) {\n    opts.rangeEnd = text.length;\n  }\n\n  var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n  if (hasUnicodeBOM) {\n    result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n    if (hasCursor) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: function formatWithCursor(text, opts) {\n    opts = normalizeOptions(opts);\n    return format(text, opts);\n  },\n  parse: function parse(text, opts, massage) {\n    opts = normalizeOptions(opts);\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    var parsed = parser.parse(text, opts);\n\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, opts);\n    }\n\n    return parsed;\n  },\n  formatAST: function formatAST(ast, opts) {\n    opts = normalizeOptions(opts);\n    var doc = printAstToDoc(ast, opts);\n    return _printDocToString(doc, opts);\n  },\n  // Doesn't handle shebang for now\n  formatDoc: function formatDoc(doc, opts) {\n    var debug = printDocToDebug(doc);\n    opts = normalizeOptions(Object.assign({}, opts, {\n      parser: \"babel\"\n    }));\n    return format(debug, opts).formatted;\n  },\n  printToDoc: function printToDoc(text, opts) {\n    opts = normalizeOptions(opts);\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    attachComments(text, ast, opts);\n    return printAstToDoc(ast, opts);\n  },\n  printDocToString: function printDocToString(doc, opts) {\n    return _printDocToString(doc, normalizeOptions(opts));\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
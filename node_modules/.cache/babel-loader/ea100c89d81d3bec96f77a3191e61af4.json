{"ast":null,"code":"var BlockchainDouble = require(\"../blockchain_double.js\");\n\nvar Account = require(\"ethereumjs-account\").default;\n\nvar Block = require(\"ethereumjs-block\");\n\nvar Log = require(\"../utils/log.js\");\n\nvar Receipt = require(\"../utils/receipt.js\");\n\nvar utils = require(\"ethereumjs-util\");\n\nvar ForkedStorageTrie = require(\"./forked_storage_trie.js\");\n\nvar Web3 = require(\"web3\");\n\nvar to = require(\"../utils/to.js\");\n\nvar Transaction = require(\"../utils/transaction\");\n\nvar async = require(\"async\");\n\nvar LRUCache = require(\"lru-cache\");\n\nconst Sublevel = require(\"level-sublevel\");\n\nconst BN = utils.BN;\n\nvar inherits = require(\"util\").inherits;\n\ninherits(ForkedBlockchain, BlockchainDouble);\nconst httpReg = /^https?:/i;\nconst protocolReg = /^[A-Za-z][A-Za-z0-9+\\-.]*:/;\nconst validProtocolReg = /^(?:http|ws)s?:/i;\nconst blockNumberReg = /@([0-9]+)$/;\n\nfunction cloneWithoutId(obj) {\n  return Object.assign({}, obj, {\n    id: null\n  });\n}\n\nfunction ForkedBlockchain(options) {\n  this.options = options || {};\n\n  if (options.fork == null || typeof options.fork === \"string\" && options.fork.trim().length === 0) {\n    throw new Error(\"ForkedBlockchain must be passed a fork parameter.\");\n  }\n\n  this.forkVersion = null;\n\n  if (typeof options.fork === \"string\") {\n    const blockNumber = blockNumberReg.exec(options.fork);\n\n    if (blockNumber) {\n      options.fork = options.fork.slice(0, blockNumber.index);\n      options.fork_block_number = parseInt(blockNumber[1], 10);\n    }\n\n    let fork;\n\n    if (!protocolReg.test(options.fork)) {\n      // we don't have a protocol at all, assume ws\n      options.fork = \"ws://\" + options.fork;\n      fork = new Web3.providers.WebsocketProvider(options.fork);\n    } else if (validProtocolReg.test(options.fork)) {\n      if (httpReg.test(options.fork)) {\n        fork = new Web3.providers.HttpProvider(options.fork);\n      } else {\n        fork = new Web3.providers.WebsocketProvider(options.fork);\n      }\n    } else {\n      throw new Error(`Invalid scheme for fork url: ${options.fork}. Supported schemes are: http, https, ws, and wss.`);\n    }\n\n    this.fork = fork;\n  } else {\n    this.fork = options.fork;\n  }\n\n  this.forkBlockNumber = options.fork_block_number;\n  this.forkCacheSize = parseInt(options.forkCacheSize); // if forkCacheSize is `0`, it means it is \"off\"\n\n  if (!isNaN(this.forkCacheSize) && this.forkCacheSize !== 0) {\n    const send = this.fork.send;\n    const cache = new LRUCache({\n      // `-1` means `Infinity`, which is represented by `0` in LRUCache's options\n      max: this.forkCacheSize === -1 ? 0 : this.forkCacheSize,\n      length: (bufValue, strKey) => {\n        // compute the rough byte size of the stored key + value\n        return Buffer.byteLength(bufValue) + Buffer.byteLength(strKey, \"utf8\");\n      }\n    }); // Patch the `send` method of the underlying fork provider. We can\n    // simply cache every non-error result because all requests to the\n    // fork should be deterministic.\n\n    const pendingRequests = new Map();\n\n    this.fork.send = (payload, callback) => {\n      let payloads;\n      const sendArray = Array.isArray(payload);\n\n      if (sendArray) {\n        payloads = payload;\n      } else {\n        payloads = [payload];\n      }\n\n      Promise.all(payloads.map(async payload => {\n        const key = JSON.stringify(cloneWithoutId(payload));\n        let pendingRequest = pendingRequests.get(key); // if a request is in flight just wait for it instead of sending another\n        // note: web3 actually polls on `.send`, resending the `payload`, so don't wait\n        // if the new `payload` is the same as the `pendingRequest`.\n\n        if (pendingRequest && pendingRequest.payload !== payload) {\n          await pendingRequest.promise;\n        }\n\n        const cachedItem = cache.get(key);\n\n        if (cachedItem) {\n          const result = JSON.parse(cachedItem.toString());\n          result.id = payload.id;\n          return Promise.resolve({\n            error: null,\n            result\n          });\n        } else {\n          const promise = new Promise(resolve => {\n            send.call(this.fork, payload, (error, result) => {\n              if (!error) {\n                cache.set(key, Buffer.from(JSON.stringify(cloneWithoutId(result))));\n              }\n\n              resolve({\n                error,\n                result\n              });\n            });\n          });\n          pendingRequest = {\n            payload,\n            promise\n          };\n          pendingRequests.set(key, pendingRequest); // Node 8 doesn't have Promise.finally\n\n          promise.catch(() => {}).then(() => {\n            pendingRequests.delete(key);\n          });\n          return promise;\n        }\n      })).then(errResults => {\n        if (!sendArray) {\n          const errResult = errResults[0];\n          callback(errResult.error, errResult.result);\n        } else {\n          let hasError = false;\n          const errors = [];\n          const results = [];\n          errResults.forEach(_ref => {\n            let {\n              error,\n              result\n            } = _ref;\n\n            if (error) {\n              hasError = true;\n            }\n\n            errors.push(error);\n            results.push(result);\n          });\n          callback(hasError ? errors : null, results);\n        }\n      });\n    };\n  }\n\n  this.time = options.time;\n  this.storageTrieCache = {};\n  BlockchainDouble.call(this, options);\n\n  this.createVMFromStateTrie = function () {\n    var vm = BlockchainDouble.prototype.createVMFromStateTrie.apply(this, arguments);\n    this.patchVM(vm);\n    return vm;\n  };\n\n  this.web3 = new Web3(this.fork);\n  this._touchedKeys = [];\n}\n\nForkedBlockchain.prototype.initialize = async function (accounts, callback) {\n  try {\n    const forkVersion = await new Promise((resolve, reject) => {\n      this.web3.eth.net.getId((err, version) => {\n        if (err) {\n          if (this.options.network_id) {\n            resolve(this.options.network_id);\n          } else {\n            Error.captureStackTrace(err);\n            err.message = `The fork provider errored when checking net_version: ${err.message}`;\n            reject(err);\n          }\n        } else {\n          resolve(version);\n        }\n      });\n    });\n    this.forkVersion = forkVersion;\n    const forkBlock = this.forkBlock = await new Promise((resolve, reject) => {\n      const queriedBlock = this.forkBlockNumber || \"latest\";\n      this.web3.eth.getBlock(queriedBlock, (err, json) => {\n        if (err) {\n          Error.captureStackTrace(err);\n          err.message = `The fork provider errored when checking for block '${queriedBlock}': ${err.message}`;\n          reject(err);\n        } else {\n          resolve(json);\n        }\n      });\n    }); // If no start time was passed, set the time to where we forked from.\n    // We only want to do this if a block was explicitly passed. If a block\n    // number wasn't passed, then we're using the last block and the current time.\n\n    if (!this.time && this.forkBlockNumber) {\n      this.time = this.options.time = new Date(to.number(forkBlock.timestamp) * 1000);\n      this.setTime(this.time);\n    }\n\n    this.forkBlockNumber = this.options.fork_block_number = forkBlock.number;\n    this.forkBlockHash = forkBlock.hash; // Fetch the nonce for all the accounts before we prime them in our state manager.\n    // This is necessary to prevent conflicting contract deployments.\n\n    const nonces = await Promise.all(accounts.map(account => {\n      return new Promise((resolve, reject) => {\n        this.web3.eth.getTransactionCount(account.address, this.forkBlockNumber, (err, nonce) => {\n          if (err) {\n            Error.captureStackTrace(err);\n            err.message = `The fork provider errored when checking the nonce for account ${account.address}: ${err.message}`;\n            reject(err);\n          } else {\n            resolve(nonce);\n          }\n        });\n      });\n    }));\n    nonces.forEach((nonce, index) => {\n      accounts[index].account.nonce = nonce;\n    });\n    BlockchainDouble.prototype.initialize.call(this, accounts, callback);\n  } catch (err) {\n    callback(err);\n  }\n};\n\nForkedBlockchain.prototype.patchVM = function (vm) {\n  const trie = vm.stateManager._trie;\n  const lookupAccount = this.getLookupAccount(trie); // Unfortunately forking requires a bit of monkey patching, but it gets the job done.\n\n  vm.stateManager._cache._lookupAccount = lookupAccount;\n  vm.stateManager._lookupStorageTrie = this.getLookupStorageTrie(trie, lookupAccount);\n};\n/**\n * @param db\n * @param root\n * @param options Allows overriding the options passed to the ForkedStorageTrie,\n * like `forkBlockNumber` (required for tracing transactions)\n */\n\n\nForkedBlockchain.prototype.createStateTrie = function (db, root, options) {\n  options = Object.assign({\n    fork: this.fork,\n    forkBlockNumber: this.forkBlockNumber,\n    blockchain: this\n  }, options); // never allow the forkBlockNumber to go beyond our root forkBlockNumber\n\n  if (options.forkBlockNumber > this.forkBlockNumber) {\n    options.forkBlockNumber = this.forkBlockNumber;\n  }\n\n  return new ForkedStorageTrie(db, root, options);\n};\n\nForkedBlockchain.prototype.createGenesisBlock = function (callback) {\n  const forkBlock = this.forkBlock;\n  this.createBlock(function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    block.header.number = forkBlock.number + 1;\n    block.header.parentHash = forkBlock.hash;\n    callback(null, block);\n  });\n};\n\nForkedBlockchain.prototype.getLookupStorageTrie = function (stateTrie, lookupAccount) {\n  lookupAccount = lookupAccount || this.getLookupAccount(stateTrie);\n  return (address, callback) => {\n    const storageTrie = stateTrie.copy();\n    storageTrie.address = address;\n    lookupAccount(address, (err, account) => {\n      if (err) {\n        return callback(err);\n      }\n\n      storageTrie.root = account.stateRoot;\n      callback(null, storageTrie);\n    });\n  };\n};\n\nForkedBlockchain.prototype.isFallbackBlock = function (value, callback) {\n  var self = this;\n  self.getEffectiveBlockNumber(value, function (err, number) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, number <= to.number(self.forkBlockNumber));\n  });\n};\n\nForkedBlockchain.prototype.isBlockHash = function (value) {\n  const isHash = typeof value === \"string\" && value.indexOf(\"0x\") === 0 && value.length > 42;\n  return isHash || Buffer.isBuffer(value) && value.byteLength > 20;\n};\n\nForkedBlockchain.prototype.isFallbackBlockHash = function (value, callback) {\n  var self = this;\n\n  if (!this.isBlockHash(value)) {\n    return callback(null, false);\n  }\n\n  if (Buffer.isBuffer(value)) {\n    value = to.hex(value);\n  }\n\n  self.data.blockHashes.get(value, function (err, blockIndex) {\n    if (err) {\n      if (err.notFound) {\n        // If the block isn't found in our database, then it must be a fallback block.\n        return callback(null, true);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(null, false);\n  });\n};\n\nForkedBlockchain.prototype.getFallbackBlock = function (numberOrHash, cb) {\n  var self = this;\n\n  if (Buffer.isBuffer(numberOrHash)) {\n    // When tracing a transaction the VM sometimes ask for a block numbers as\n    // buffers instead of numbers.\n    numberOrHash = to.rpcDataHexString(numberOrHash);\n  }\n\n  if (typeof numberOrHash === \"string\" && numberOrHash.length !== 66) {\n    numberOrHash = to.number(numberOrHash);\n  }\n\n  self.web3.eth.getBlock(numberOrHash, true, function (err, json) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (json == null) {\n      return cb(new Error(\"Block not found\"));\n    }\n\n    var block = new Block();\n    block.header.parentHash = utils.toBuffer(json.parentHash);\n    block.header.uncleHash = utils.toBuffer(json.sha3Uncles);\n    block.header.coinbase = utils.toBuffer(json.miner);\n    block.header.stateRoot = utils.toBuffer(json.stateRoot); // Should we include the following three?\n\n    block.header.transactionsTrie = utils.toBuffer(json.transactionsRoot);\n    block.header.receiptTrie = utils.toBuffer(json.receiptsRoot);\n    block.header.bloom = utils.toBuffer(json.logsBloom);\n    block.header.difficulty = utils.toBuffer(\"0x\" + json.totalDifficulty.toString(16)); // BigNumber\n\n    block.header.number = utils.toBuffer(json.number);\n    block.header.gasLimit = utils.toBuffer(json.gasLimit);\n    block.header.gasUsed = utils.toBuffer(json.gasUsed);\n    block.header.timestamp = utils.toBuffer(json.timestamp);\n    block.header.extraData = utils.toBuffer(json.extraData);\n    (json.transactions || []).forEach(function (txJson, index) {\n      block.transactions.push(Transaction.fromJSON(txJson, Transaction.types.real, null, self.forkVersion, self.options.hardfork));\n    }); // Fake block. Let's do the worst.\n    // TODO: Attempt to fill out all block data so as to produce the same hash! (can we?)\n\n    block.hash = function () {\n      return utils.toBuffer(json.hash);\n    };\n\n    cb(null, block);\n  });\n};\n\nForkedBlockchain.prototype.getBlock = function (number, callback) {\n  let checkFn;\n  const isBlockHash = this.isBlockHash(number);\n\n  if (isBlockHash) {\n    checkFn = this.isFallbackBlockHash;\n  } else {\n    checkFn = this.isFallbackBlock;\n  }\n\n  checkFn.call(this, number, (err, isFallback) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (isFallback) {\n      return this.getFallbackBlock(number, callback);\n    }\n\n    const getBlock = BlockchainDouble.prototype.getBlock.bind(this);\n\n    if (isBlockHash) {\n      getBlock(number, callback);\n    } else {\n      this.getRelativeBlockNumber(number, (err, number) => {\n        if (err) {\n          return callback(err);\n        }\n\n        getBlock(number, callback);\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.getStorage = function (address, key, number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, (err, blockNumber) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (blockNumber > self.forkBlockNumber) {\n      // we should have this block\n      self.getBlock(blockNumber, function (err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        const trie = self.stateTrie; // Manipulate the state root in place to maintain checkpoints\n\n        const currentStateRoot = trie.root;\n        self.stateTrie.root = block.header.stateRoot;\n        self.getLookupStorageTrie(self.stateTrie)(address, (err, trie) => {\n          if (err) {\n            return callback(err);\n          }\n\n          trie.get(utils.setLengthLeft(utils.toBuffer(key), 32), function (err, value) {\n            // Finally, put the stateRoot back for good\n            trie.root = currentStateRoot;\n\n            if (err != null) {\n              return callback(err);\n            }\n\n            callback(null, value);\n          });\n        });\n      });\n    } else {\n      // we're looking for something prior to forking, so let's\n      // hit eth_getStorageAt\n      self.web3.eth.getStorageAt(to.rpcDataHexString(address), to.rpcDataHexString(key), blockNumber, function (err, value) {\n        if (err) {\n          return callback(err);\n        }\n\n        value = utils.rlp.encode(value);\n        callback(null, value);\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.getCode = function (address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  if (!number) {\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    number = effective;\n    self.stateTrie.getTouchedAt(address, (err, touchedAt) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof touchedAt !== \"undefined\" && touchedAt <= number) {\n        BlockchainDouble.prototype.getCode.call(self, address, number, callback);\n      } else {\n        if (number > to.number(self.forkBlockNumber)) {\n          number = \"latest\";\n        }\n\n        self.fetchCodeFromFallback(address, number, function (err, code) {\n          if (code) {\n            code = utils.toBuffer(code);\n          }\n\n          callback(err, code);\n        });\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getLookupAccount = function (trie) {\n  return (address, callback) => {\n    // If the account doesn't exist in our state trie, get it off the wire.\n    trie.keyExists(address, (err, exists) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (exists) {\n        trie.get(address, (err, data) => {\n          if (err) {\n            return callback(err);\n          }\n\n          const account = new Account(data);\n          callback(null, account);\n        });\n      } else {\n        this.fetchAccountFromFallback(address, to.number(trie.forkBlockNumber), callback);\n      }\n    });\n  };\n};\n\nForkedBlockchain.prototype.getAccount = function (address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    number = effective; // If the account doesn't exist in our state trie, get it off the wire.\n\n    self.stateTrie.keyExists(address, function (err, exists) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (exists && number > to.number(self.forkBlockNumber)) {\n        BlockchainDouble.prototype.getAccount.call(self, address, number, function (err, acc) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, acc);\n        });\n      } else {\n        self.fetchAccountFromFallback(address, number, callback);\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransaction = function (hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransaction.call(this, hash, function (err, tx) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (tx != null) {\n      return callback(null, tx);\n    }\n\n    self.web3.eth.getTransaction(hash, function (err, result) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (result) {\n        result = Transaction.fromJSON(result, Transaction.types.signed, null, self.forkVersion, self.options.hardfork);\n      }\n\n      callback(null, result);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransactionReceipt = function (hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransactionReceipt.call(this, hash, function (err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (receipt) {\n      return callback(null, receipt);\n    }\n\n    self.web3.eth.getTransactionReceipt(hash, function (err, receiptJson) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!receiptJson) {\n        return callback();\n      }\n\n      async.parallel({\n        tx: self.getTransaction.bind(self, hash),\n        block: self.getBlock.bind(self, receiptJson.blockNumber)\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        var logs = receiptJson.logs.map(function (log) {\n          log.block = result.block;\n          return new Log(log);\n        });\n        var receipt = new Receipt(result.tx, result.block, logs, receiptJson.gasUsed, receiptJson.cumulativeGasUsed, receiptJson.contractAddress, receiptJson.status, to.hex(receiptJson.logsBloom));\n        callback(null, receipt);\n      });\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchAccountFromFallback = function (address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n  async.parallel({\n    code: this.fetchCodeFromFallback.bind(this, address, blockNumber),\n    balance: this.fetchBalanceFromFallback.bind(this, address, blockNumber),\n    nonce: this.fetchNonceFromFallback.bind(this, address, blockNumber)\n  }, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n\n    var code = results.code;\n    var balance = results.balance;\n    var nonce = results.nonce;\n    var account = new Account({\n      nonce: nonce,\n      balance: balance\n    }); // This puts the code on the trie, keyed by the hash of the code.\n    // It does not actually link an account to code in the trie.\n\n    account.setCode(self.stateTrie, utils.toBuffer(code), function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, account);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchCodeFromFallback = function (address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address); // Allow an optional blockNumber\n\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function (err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getCode(address, safeBlockNumber, function (err, code) {\n      if (err) {\n        return callback(err);\n      }\n\n      code = \"0x\" + utils.toBuffer(code).toString(\"hex\");\n      callback(null, code);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchBalanceFromFallback = function (address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address); // Allow an optional blockNumber\n\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function (err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getBalance(address, safeBlockNumber, function (err, balance) {\n      if (err) {\n        return callback(err);\n      }\n\n      balance = \"0x\" + new BN(balance).toString(16);\n      callback(null, balance);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchNonceFromFallback = function (address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address); // Allow an optional blockNumber\n\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function (err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getTransactionCount(address, safeBlockNumber, function (err, nonce) {\n      if (err) {\n        return callback(err);\n      }\n\n      nonce = \"0x\" + self.web3.utils.toBN(nonce).toString(16);\n      callback(null, nonce);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getHeight = function (callback) {\n  this.latestBlock(function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, to.number(block.header.number));\n  });\n};\n\nForkedBlockchain.prototype.getRelativeBlockNumber = function (number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, effective - to.number(self.forkBlockNumber) - 1);\n  });\n};\n\nForkedBlockchain.prototype.getSafeFallbackBlockNumber = function (blockNumber, callback) {\n  var forkBlockNumber = to.number(this.forkBlockNumber);\n\n  if (blockNumber == null) {\n    return callback(null, forkBlockNumber);\n  }\n\n  this.getEffectiveBlockNumber(blockNumber, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (effective > forkBlockNumber) {\n      effective = forkBlockNumber;\n    }\n\n    callback(null, effective);\n  });\n};\n\nForkedBlockchain.prototype.getBlockLogs = function (number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.getRelativeBlockNumber(effective, function (err, relative) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (relative < 0) {\n        self.getBlock(number, function (err, block) {\n          if (err) {\n            return callback(err);\n          }\n\n          self.web3.currentProvider.send({\n            jsonrpc: \"2.0\",\n            method: \"eth_getLogs\",\n            params: [{\n              fromBlock: to.hex(number),\n              toBlock: to.hex(number)\n            }],\n            id: new Date().getTime()\n          }, function (err, res) {\n            if (err) {\n              return callback(err);\n            }\n\n            var logs = res.result.map(function (log) {\n              // To make this result masquerade as the right information.\n              log.block = block;\n              return new Log(log);\n            });\n            callback(null, logs);\n          });\n        });\n      } else {\n        BlockchainDouble.prototype.getBlockLogs.call(self, relative, callback);\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getQueuedNonce = function (address, callback) {\n  var nonce = null;\n  var addressBuffer = to.buffer(address);\n  this.pending_transactions.forEach(function (tx) {\n    if (!tx.from.equals(addressBuffer)) {\n      return;\n    }\n\n    var pendingNonce = new BN(tx.nonce); // If this is the first queued nonce for this address we found,\n    // or it's higher than the previous highest, note it.\n\n    if (nonce === null || pendingNonce.gt(nonce)) {\n      nonce = pendingNonce;\n    }\n  }); // If we found a queued transaction nonce, return one higher\n  // than the highest we found\n\n  if (nonce != null) {\n    return callback(null, nonce.iaddn(1).toArrayLike(Buffer));\n  }\n\n  this.getLookupAccount(this.stateTrie)(addressBuffer, function (err, account) {\n    if (err) {\n      return callback(err);\n    } // nonces are initialized as an empty buffer, which isn't what we want.\n\n\n    callback(null, account.nonce.length === 0 ? Buffer.from([0]) : account.nonce);\n  });\n};\n\nForkedBlockchain.prototype.processCall = function (tx, blockNumber, callback) {\n  const self = this;\n  this.getEffectiveBlockNumber(blockNumber, function (err, effectiveBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (effectiveBlockNumber > self.forkBlockNumber) {\n      BlockchainDouble.prototype.processCall.call(self, tx, blockNumber, callback);\n    } else {\n      self.web3.eth.call({\n        from: to.rpcDataHexString(tx.from),\n        to: to.nullableRpcDataHexString(tx.to),\n        data: to.rpcDataHexString(tx.data)\n      }, effectiveBlockNumber, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, {\n          execResult: {\n            returnValue: result\n          }\n        });\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.processBlock = async function (vm, block, commit, callback) {\n  const self = this;\n  self._touchedKeys = [];\n  BlockchainDouble.prototype.processBlock.call(self, vm, block, commit, callback);\n};\n\nForkedBlockchain.prototype.putBlock = function (block, logs, receipts, callback) {\n  const self = this;\n  const touched = Sublevel(self.data.trie_db).sublevel(\"touched\");\n  const blockKey = `block-${to.number(block.header.number)}`;\n  BlockchainDouble.prototype.putBlock.call(self, block, logs, receipts, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    touched.put(blockKey, JSON.stringify(self._touchedKeys), err => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, result);\n    });\n  });\n};\n\nForkedBlockchain.prototype.popBlock = function (callback) {\n  const self = this;\n  const touched = Sublevel(this.data.trie_db).sublevel(\"touched\");\n  this.data.blocks.last(function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (block == null) {\n      return callback(null, null);\n    }\n\n    const blockKey = `block-${to.number(block.header.number)}`;\n    touched.get(blockKey, function (err, value) {\n      if (err) {\n        return callback(err);\n      }\n\n      const touchedKeys = value ? JSON.parse(value) : [];\n      async.eachSeries(touchedKeys, function (touchedKey, finished) {\n        touched.del(touchedKey, finished);\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        touched.del(blockKey, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          BlockchainDouble.prototype.popBlock.call(self, callback);\n        });\n      });\n    });\n  });\n};\n\nForkedBlockchain.prototype.close = function (callback) {\n  if (this.fork.disconnect) {\n    this.fork.disconnect();\n  }\n\n  BlockchainDouble.prototype.close.call(this, callback);\n};\n\nmodule.exports = ForkedBlockchain;","map":{"version":3,"names":["BlockchainDouble","require","Account","default","Block","Log","Receipt","utils","ForkedStorageTrie","Web3","to","Transaction","async","LRUCache","Sublevel","BN","inherits","ForkedBlockchain","httpReg","protocolReg","validProtocolReg","blockNumberReg","cloneWithoutId","obj","Object","assign","id","options","fork","trim","length","Error","forkVersion","blockNumber","exec","slice","index","fork_block_number","parseInt","test","providers","WebsocketProvider","HttpProvider","forkBlockNumber","forkCacheSize","isNaN","send","cache","max","bufValue","strKey","Buffer","byteLength","pendingRequests","Map","payload","callback","payloads","sendArray","Array","isArray","Promise","all","map","key","JSON","stringify","pendingRequest","get","promise","cachedItem","result","parse","toString","resolve","error","call","set","from","catch","then","delete","errResults","errResult","hasError","errors","results","forEach","push","time","storageTrieCache","createVMFromStateTrie","vm","prototype","apply","arguments","patchVM","web3","_touchedKeys","initialize","accounts","reject","eth","net","getId","err","version","network_id","captureStackTrace","message","forkBlock","queriedBlock","getBlock","json","Date","number","timestamp","setTime","forkBlockHash","hash","nonces","account","getTransactionCount","address","nonce","trie","stateManager","_trie","lookupAccount","getLookupAccount","_cache","_lookupAccount","_lookupStorageTrie","getLookupStorageTrie","createStateTrie","db","root","blockchain","createGenesisBlock","createBlock","block","header","parentHash","stateTrie","storageTrie","copy","stateRoot","isFallbackBlock","value","self","getEffectiveBlockNumber","isBlockHash","isHash","indexOf","isBuffer","isFallbackBlockHash","hex","data","blockHashes","blockIndex","notFound","getFallbackBlock","numberOrHash","cb","rpcDataHexString","toBuffer","uncleHash","sha3Uncles","coinbase","miner","transactionsTrie","transactionsRoot","receiptTrie","receiptsRoot","bloom","logsBloom","difficulty","totalDifficulty","gasLimit","gasUsed","extraData","transactions","txJson","fromJSON","types","real","hardfork","checkFn","isFallback","bind","getRelativeBlockNumber","getStorage","currentStateRoot","setLengthLeft","getStorageAt","rlp","encode","getCode","effective","getTouchedAt","touchedAt","fetchCodeFromFallback","code","keyExists","exists","fetchAccountFromFallback","getAccount","acc","getTransaction","tx","signed","getTransactionReceipt","receipt","receiptJson","parallel","logs","log","cumulativeGasUsed","contractAddress","status","balance","fetchBalanceFromFallback","fetchNonceFromFallback","setCode","getSafeFallbackBlockNumber","safeBlockNumber","getBalance","toBN","getHeight","latestBlock","getBlockLogs","relative","currentProvider","jsonrpc","method","params","fromBlock","toBlock","getTime","res","getQueuedNonce","addressBuffer","buffer","pending_transactions","equals","pendingNonce","gt","iaddn","toArrayLike","processCall","effectiveBlockNumber","nullableRpcDataHexString","execResult","returnValue","processBlock","commit","putBlock","receipts","touched","trie_db","sublevel","blockKey","put","popBlock","blocks","last","touchedKeys","eachSeries","touchedKey","finished","del","close","disconnect","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/forking/forked_blockchain.js"],"sourcesContent":["var BlockchainDouble = require(\"../blockchain_double.js\");\nvar Account = require(\"ethereumjs-account\").default;\nvar Block = require(\"ethereumjs-block\");\nvar Log = require(\"../utils/log.js\");\nvar Receipt = require(\"../utils/receipt.js\");\nvar utils = require(\"ethereumjs-util\");\nvar ForkedStorageTrie = require(\"./forked_storage_trie.js\");\nvar Web3 = require(\"web3\");\nvar to = require(\"../utils/to.js\");\nvar Transaction = require(\"../utils/transaction\");\nvar async = require(\"async\");\nvar LRUCache = require(\"lru-cache\");\nconst Sublevel = require(\"level-sublevel\");\nconst BN = utils.BN;\n\nvar inherits = require(\"util\").inherits;\n\ninherits(ForkedBlockchain, BlockchainDouble);\n\nconst httpReg = /^https?:/i;\nconst protocolReg = /^[A-Za-z][A-Za-z0-9+\\-.]*:/;\nconst validProtocolReg = /^(?:http|ws)s?:/i;\nconst blockNumberReg = /@([0-9]+)$/;\n\nfunction cloneWithoutId(obj) {\n  return Object.assign({}, obj, { id: null });\n}\n\nfunction ForkedBlockchain(options) {\n  this.options = options || {};\n\n  if (options.fork == null || (typeof options.fork === \"string\" && options.fork.trim().length === 0)) {\n    throw new Error(\"ForkedBlockchain must be passed a fork parameter.\");\n  }\n\n  this.forkVersion = null;\n\n  if (typeof options.fork === \"string\") {\n    const blockNumber = blockNumberReg.exec(options.fork);\n\n    if (blockNumber) {\n      options.fork = options.fork.slice(0, blockNumber.index);\n      options.fork_block_number = parseInt(blockNumber[1], 10);\n    }\n\n    let fork;\n    if (!protocolReg.test(options.fork)) {\n      // we don't have a protocol at all, assume ws\n      options.fork = \"ws://\" + options.fork;\n      fork = new Web3.providers.WebsocketProvider(options.fork);\n    } else if (validProtocolReg.test(options.fork)) {\n      if (httpReg.test(options.fork)) {\n        fork = new Web3.providers.HttpProvider(options.fork);\n      } else {\n        fork = new Web3.providers.WebsocketProvider(options.fork);\n      }\n    } else {\n      throw new Error(`Invalid scheme for fork url: ${options.fork}. Supported schemes are: http, https, ws, and wss.`);\n    }\n\n    this.fork = fork;\n  } else {\n    this.fork = options.fork;\n  }\n\n  this.forkBlockNumber = options.fork_block_number;\n  this.forkCacheSize = parseInt(options.forkCacheSize);\n\n  // if forkCacheSize is `0`, it means it is \"off\"\n  if (!isNaN(this.forkCacheSize) && this.forkCacheSize !== 0) {\n    const send = this.fork.send;\n    const cache = new LRUCache({\n      // `-1` means `Infinity`, which is represented by `0` in LRUCache's options\n      max: this.forkCacheSize === -1 ? 0 : this.forkCacheSize,\n      length: (bufValue, strKey) => {\n        // compute the rough byte size of the stored key + value\n        return Buffer.byteLength(bufValue) + Buffer.byteLength(strKey, \"utf8\");\n      }\n    });\n\n    // Patch the `send` method of the underlying fork provider. We can\n    // simply cache every non-error result because all requests to the\n    // fork should be deterministic.\n    const pendingRequests = new Map();\n    this.fork.send = (payload, callback) => {\n      let payloads;\n      const sendArray = Array.isArray(payload);\n      if (sendArray) {\n        payloads = payload;\n      } else {\n        payloads = [payload];\n      }\n      Promise.all(\n        payloads.map(async(payload) => {\n          const key = JSON.stringify(cloneWithoutId(payload));\n          let pendingRequest = pendingRequests.get(key);\n          // if a request is in flight just wait for it instead of sending another\n          // note: web3 actually polls on `.send`, resending the `payload`, so don't wait\n          // if the new `payload` is the same as the `pendingRequest`.\n          if (pendingRequest && pendingRequest.payload !== payload) {\n            await pendingRequest.promise;\n          }\n\n          const cachedItem = cache.get(key);\n          if (cachedItem) {\n            const result = JSON.parse(cachedItem.toString());\n            result.id = payload.id;\n            return Promise.resolve({ error: null, result });\n          } else {\n            const promise = new Promise((resolve) => {\n              send.call(this.fork, payload, (error, result) => {\n                if (!error) {\n                  cache.set(key, Buffer.from(JSON.stringify(cloneWithoutId(result))));\n                }\n                resolve({ error, result });\n              });\n            });\n            pendingRequest = {\n              payload,\n              promise\n            };\n\n            pendingRequests.set(key, pendingRequest);\n            // Node 8 doesn't have Promise.finally\n            promise\n              .catch(() => {})\n              .then(() => {\n                pendingRequests.delete(key);\n              });\n            return promise;\n          }\n        })\n      ).then((errResults) => {\n        if (!sendArray) {\n          const errResult = errResults[0];\n          callback(errResult.error, errResult.result);\n        } else {\n          let hasError = false;\n          const errors = [];\n          const results = [];\n          errResults.forEach(({ error, result }) => {\n            if (error) {\n              hasError = true;\n            }\n            errors.push(error);\n            results.push(result);\n          });\n          callback(hasError ? errors : null, results);\n        }\n      });\n    };\n  }\n\n  this.time = options.time;\n  this.storageTrieCache = {};\n\n  BlockchainDouble.call(this, options);\n\n  this.createVMFromStateTrie = function() {\n    var vm = BlockchainDouble.prototype.createVMFromStateTrie.apply(this, arguments);\n    this.patchVM(vm);\n    return vm;\n  };\n\n  this.web3 = new Web3(this.fork);\n  this._touchedKeys = [];\n}\n\nForkedBlockchain.prototype.initialize = async function(accounts, callback) {\n  try {\n    const forkVersion = await new Promise((resolve, reject) => {\n      this.web3.eth.net.getId((err, version) => {\n        if (err) {\n          if (this.options.network_id) {\n            resolve(this.options.network_id);\n          } else {\n            Error.captureStackTrace(err);\n            err.message = `The fork provider errored when checking net_version: ${err.message}`;\n            reject(err);\n          }\n        } else {\n          resolve(version);\n        }\n      });\n    });\n\n    this.forkVersion = forkVersion;\n\n    const forkBlock = (this.forkBlock = await new Promise((resolve, reject) => {\n      const queriedBlock = this.forkBlockNumber || \"latest\";\n      this.web3.eth.getBlock(queriedBlock, (err, json) => {\n        if (err) {\n          Error.captureStackTrace(err);\n          err.message =\n            `The fork provider errored when checking for block '${\n              queriedBlock\n            }': ${err.message}`;\n          reject(err);\n        } else {\n          resolve(json);\n        }\n      });\n    }));\n\n    // If no start time was passed, set the time to where we forked from.\n    // We only want to do this if a block was explicitly passed. If a block\n    // number wasn't passed, then we're using the last block and the current time.\n    if (!this.time && this.forkBlockNumber) {\n      this.time = this.options.time = new Date(to.number(forkBlock.timestamp) * 1000);\n      this.setTime(this.time);\n    }\n\n    this.forkBlockNumber = this.options.fork_block_number = forkBlock.number;\n    this.forkBlockHash = forkBlock.hash;\n\n    // Fetch the nonce for all the accounts before we prime them in our state manager.\n    // This is necessary to prevent conflicting contract deployments.\n    const nonces = await Promise.all(\n      accounts.map((account) => {\n        return new Promise((resolve, reject) => {\n          this.web3.eth.getTransactionCount(account.address, this.forkBlockNumber, (err, nonce) => {\n            if (err) {\n              Error.captureStackTrace(err);\n              err.message =\n                `The fork provider errored when checking the nonce for account ${\n                  account.address\n                }: ${err.message}`;\n              reject(err);\n            } else {\n              resolve(nonce);\n            }\n          });\n        });\n      })\n    );\n\n    nonces.forEach((nonce, index) => {\n      accounts[index].account.nonce = nonce;\n    });\n\n    BlockchainDouble.prototype.initialize.call(this, accounts, callback);\n  } catch (err) {\n    callback(err);\n  }\n};\n\nForkedBlockchain.prototype.patchVM = function(vm) {\n  const trie = vm.stateManager._trie;\n  const lookupAccount = this.getLookupAccount(trie);\n  // Unfortunately forking requires a bit of monkey patching, but it gets the job done.\n  vm.stateManager._cache._lookupAccount = lookupAccount;\n  vm.stateManager._lookupStorageTrie = this.getLookupStorageTrie(trie, lookupAccount);\n};\n\n/**\n * @param db\n * @param root\n * @param options Allows overriding the options passed to the ForkedStorageTrie,\n * like `forkBlockNumber` (required for tracing transactions)\n */\nForkedBlockchain.prototype.createStateTrie = function(db, root, options) {\n  options = Object.assign(\n    {\n      fork: this.fork,\n      forkBlockNumber: this.forkBlockNumber,\n      blockchain: this\n    },\n    options\n  );\n  // never allow the forkBlockNumber to go beyond our root forkBlockNumber\n  if (options.forkBlockNumber > this.forkBlockNumber) {\n    options.forkBlockNumber = this.forkBlockNumber;\n  }\n  return new ForkedStorageTrie(db, root, options);\n};\n\nForkedBlockchain.prototype.createGenesisBlock = function(callback) {\n  const forkBlock = this.forkBlock;\n\n  this.createBlock(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    block.header.number = forkBlock.number + 1;\n    block.header.parentHash = forkBlock.hash;\n\n    callback(null, block);\n  });\n};\n\nForkedBlockchain.prototype.getLookupStorageTrie = function(stateTrie, lookupAccount) {\n  lookupAccount = lookupAccount || this.getLookupAccount(stateTrie);\n  return (address, callback) => {\n    const storageTrie = stateTrie.copy();\n    storageTrie.address = address;\n    lookupAccount(address, (err, account) => {\n      if (err) {\n        return callback(err);\n      }\n\n      storageTrie.root = account.stateRoot;\n      callback(null, storageTrie);\n    });\n  };\n};\n\nForkedBlockchain.prototype.isFallbackBlock = function(value, callback) {\n  var self = this;\n\n  self.getEffectiveBlockNumber(value, function(err, number) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, number <= to.number(self.forkBlockNumber));\n  });\n};\n\nForkedBlockchain.prototype.isBlockHash = function(value) {\n  const isHash = typeof value === \"string\" && value.indexOf(\"0x\") === 0 && value.length > 42;\n  return isHash || (Buffer.isBuffer(value) && value.byteLength > 20);\n};\n\nForkedBlockchain.prototype.isFallbackBlockHash = function(value, callback) {\n  var self = this;\n\n  if (!this.isBlockHash(value)) {\n    return callback(null, false);\n  }\n\n  if (Buffer.isBuffer(value)) {\n    value = to.hex(value);\n  }\n\n  self.data.blockHashes.get(value, function(err, blockIndex) {\n    if (err) {\n      if (err.notFound) {\n        // If the block isn't found in our database, then it must be a fallback block.\n        return callback(null, true);\n      } else {\n        return callback(err);\n      }\n    }\n    callback(null, false);\n  });\n};\n\nForkedBlockchain.prototype.getFallbackBlock = function(numberOrHash, cb) {\n  var self = this;\n\n  if (Buffer.isBuffer(numberOrHash)) {\n    // When tracing a transaction the VM sometimes ask for a block numbers as\n    // buffers instead of numbers.\n    numberOrHash = to.rpcDataHexString(numberOrHash);\n  }\n  if (typeof numberOrHash === \"string\" && numberOrHash.length !== 66) {\n    numberOrHash = to.number(numberOrHash);\n  }\n\n  self.web3.eth.getBlock(numberOrHash, true, function(err, json) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (json == null) {\n      return cb(new Error(\"Block not found\"));\n    }\n\n    var block = new Block();\n\n    block.header.parentHash = utils.toBuffer(json.parentHash);\n    block.header.uncleHash = utils.toBuffer(json.sha3Uncles);\n    block.header.coinbase = utils.toBuffer(json.miner);\n    block.header.stateRoot = utils.toBuffer(json.stateRoot); // Should we include the following three?\n    block.header.transactionsTrie = utils.toBuffer(json.transactionsRoot);\n    block.header.receiptTrie = utils.toBuffer(json.receiptsRoot);\n    block.header.bloom = utils.toBuffer(json.logsBloom);\n    block.header.difficulty = utils.toBuffer(\"0x\" + json.totalDifficulty.toString(16)); // BigNumber\n    block.header.number = utils.toBuffer(json.number);\n    block.header.gasLimit = utils.toBuffer(json.gasLimit);\n    block.header.gasUsed = utils.toBuffer(json.gasUsed);\n    block.header.timestamp = utils.toBuffer(json.timestamp);\n    block.header.extraData = utils.toBuffer(json.extraData);\n\n    (json.transactions || []).forEach(function(txJson, index) {\n      block.transactions.push(\n        Transaction.fromJSON(txJson, Transaction.types.real, null, self.forkVersion, self.options.hardfork)\n      );\n    });\n\n    // Fake block. Let's do the worst.\n    // TODO: Attempt to fill out all block data so as to produce the same hash! (can we?)\n    block.hash = function() {\n      return utils.toBuffer(json.hash);\n    };\n\n    cb(null, block);\n  });\n};\n\nForkedBlockchain.prototype.getBlock = function(number, callback) {\n  let checkFn;\n  const isBlockHash = this.isBlockHash(number);\n  if (isBlockHash) {\n    checkFn = this.isFallbackBlockHash;\n  } else {\n    checkFn = this.isFallbackBlock;\n  }\n  checkFn.call(this, number, (err, isFallback) => {\n    if (err) {\n      return callback(err);\n    }\n    if (isFallback) {\n      return this.getFallbackBlock(number, callback);\n    }\n\n    const getBlock = BlockchainDouble.prototype.getBlock.bind(this);\n    if (isBlockHash) {\n      getBlock(number, callback);\n    } else {\n      this.getRelativeBlockNumber(number, (err, number) => {\n        if (err) {\n          return callback(err);\n        }\n        getBlock(number, callback);\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.getStorage = function(address, key, number, callback) {\n  var self = this;\n\n  this.getEffectiveBlockNumber(number, (err, blockNumber) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (blockNumber > self.forkBlockNumber) {\n      // we should have this block\n\n      self.getBlock(blockNumber, function(err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        const trie = self.stateTrie;\n\n        // Manipulate the state root in place to maintain checkpoints\n        const currentStateRoot = trie.root;\n        self.stateTrie.root = block.header.stateRoot;\n\n        self.getLookupStorageTrie(self.stateTrie)(address, (err, trie) => {\n          if (err) {\n            return callback(err);\n          }\n\n          trie.get(utils.setLengthLeft(utils.toBuffer(key), 32), function(err, value) {\n            // Finally, put the stateRoot back for good\n            trie.root = currentStateRoot;\n\n            if (err != null) {\n              return callback(err);\n            }\n\n            callback(null, value);\n          });\n        });\n      });\n    } else {\n      // we're looking for something prior to forking, so let's\n      // hit eth_getStorageAt\n      self.web3.eth.getStorageAt(to.rpcDataHexString(address), to.rpcDataHexString(key), blockNumber, function(\n        err,\n        value\n      ) {\n        if (err) {\n          return callback(err);\n        }\n\n        value = utils.rlp.encode(value);\n\n        callback(null, value);\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.getCode = function(address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  if (!number) {\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    number = effective;\n\n    self.stateTrie.getTouchedAt(address, (err, touchedAt) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof touchedAt !== \"undefined\" && touchedAt <= number) {\n        BlockchainDouble.prototype.getCode.call(self, address, number, callback);\n      } else {\n        if (number > to.number(self.forkBlockNumber)) {\n          number = \"latest\";\n        }\n\n        self.fetchCodeFromFallback(address, number, function(err, code) {\n          if (code) {\n            code = utils.toBuffer(code);\n          }\n          callback(err, code);\n        });\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getLookupAccount = function(trie) {\n  return (address, callback) => {\n    // If the account doesn't exist in our state trie, get it off the wire.\n    trie.keyExists(address, (err, exists) => {\n      if (err) {\n        return callback(err);\n      }\n      if (exists) {\n        trie.get(address, (err, data) => {\n          if (err) {\n            return callback(err);\n          }\n          const account = new Account(data);\n          callback(null, account);\n        });\n      } else {\n        this.fetchAccountFromFallback(address, to.number(trie.forkBlockNumber), callback);\n      }\n    });\n  };\n};\n\nForkedBlockchain.prototype.getAccount = function(address, number, callback) {\n  var self = this;\n\n  if (typeof number === \"function\") {\n    callback = number;\n    number = \"latest\";\n  }\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    number = effective;\n\n    // If the account doesn't exist in our state trie, get it off the wire.\n    self.stateTrie.keyExists(address, function(err, exists) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (exists && number > to.number(self.forkBlockNumber)) {\n        BlockchainDouble.prototype.getAccount.call(self, address, number, function(err, acc) {\n          if (err) {\n            return callback(err);\n          }\n          callback(null, acc);\n        });\n      } else {\n        self.fetchAccountFromFallback(address, number, callback);\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransaction = function(hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransaction.call(this, hash, function(err, tx) {\n    if (err) {\n      return callback(err);\n    }\n    if (tx != null) {\n      return callback(null, tx);\n    }\n\n    self.web3.eth.getTransaction(hash, function(err, result) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (result) {\n        result = Transaction.fromJSON(result, Transaction.types.signed, null, self.forkVersion, self.options.hardfork);\n      }\n\n      callback(null, result);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getTransactionReceipt = function(hash, callback) {\n  var self = this;\n  BlockchainDouble.prototype.getTransactionReceipt.call(this, hash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n    if (receipt) {\n      return callback(null, receipt);\n    }\n\n    self.web3.eth.getTransactionReceipt(hash, function(err, receiptJson) {\n      if (err) {\n        return callback(err);\n      }\n      if (!receiptJson) {\n        return callback();\n      }\n\n      async.parallel(\n        {\n          tx: self.getTransaction.bind(self, hash),\n          block: self.getBlock.bind(self, receiptJson.blockNumber)\n        },\n        function(err, result) {\n          if (err) {\n            return callback(err);\n          }\n\n          var logs = receiptJson.logs.map(function(log) {\n            log.block = result.block;\n            return new Log(log);\n          });\n\n          var receipt = new Receipt(\n            result.tx,\n            result.block,\n            logs,\n            receiptJson.gasUsed,\n            receiptJson.cumulativeGasUsed,\n            receiptJson.contractAddress,\n            receiptJson.status,\n            to.hex(receiptJson.logsBloom)\n          );\n\n          callback(null, receipt);\n        }\n      );\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchAccountFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  async.parallel(\n    {\n      code: this.fetchCodeFromFallback.bind(this, address, blockNumber),\n      balance: this.fetchBalanceFromFallback.bind(this, address, blockNumber),\n      nonce: this.fetchNonceFromFallback.bind(this, address, blockNumber)\n    },\n    function(err, results) {\n      if (err) {\n        return callback(err);\n      }\n\n      var code = results.code;\n      var balance = results.balance;\n      var nonce = results.nonce;\n\n      var account = new Account({\n        nonce: nonce,\n        balance: balance\n      });\n\n      // This puts the code on the trie, keyed by the hash of the code.\n      // It does not actually link an account to code in the trie.\n      account.setCode(self.stateTrie, utils.toBuffer(code), function(err) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, account);\n      });\n    }\n  );\n};\n\nForkedBlockchain.prototype.fetchCodeFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getCode(address, safeBlockNumber, function(err, code) {\n      if (err) {\n        return callback(err);\n      }\n\n      code = \"0x\" + utils.toBuffer(code).toString(\"hex\");\n      callback(null, code);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchBalanceFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getBalance(address, safeBlockNumber, function(err, balance) {\n      if (err) {\n        return callback(err);\n      }\n\n      balance = \"0x\" + new BN(balance).toString(16);\n      callback(null, balance);\n    });\n  });\n};\n\nForkedBlockchain.prototype.fetchNonceFromFallback = function(address, blockNumber, callback) {\n  var self = this;\n  address = to.hex(address);\n\n  // Allow an optional blockNumber\n  if (typeof blockNumber === \"function\") {\n    callback = blockNumber;\n    blockNumber = this.forkBlockNumber;\n  }\n\n  this.getSafeFallbackBlockNumber(blockNumber, function(err, safeBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.web3.eth.getTransactionCount(address, safeBlockNumber, function(err, nonce) {\n      if (err) {\n        return callback(err);\n      }\n\n      nonce = \"0x\" + self.web3.utils.toBN(nonce).toString(16);\n      callback(null, nonce);\n    });\n  });\n};\n\nForkedBlockchain.prototype.getHeight = function(callback) {\n  this.latestBlock(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, to.number(block.header.number));\n  });\n};\n\nForkedBlockchain.prototype.getRelativeBlockNumber = function(number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, effective - to.number(self.forkBlockNumber) - 1);\n  });\n};\n\nForkedBlockchain.prototype.getSafeFallbackBlockNumber = function(blockNumber, callback) {\n  var forkBlockNumber = to.number(this.forkBlockNumber);\n\n  if (blockNumber == null) {\n    return callback(null, forkBlockNumber);\n  }\n\n  this.getEffectiveBlockNumber(blockNumber, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    if (effective > forkBlockNumber) {\n      effective = forkBlockNumber;\n    }\n\n    callback(null, effective);\n  });\n};\n\nForkedBlockchain.prototype.getBlockLogs = function(number, callback) {\n  var self = this;\n\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.getRelativeBlockNumber(effective, function(err, relative) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (relative < 0) {\n        self.getBlock(number, function(err, block) {\n          if (err) {\n            return callback(err);\n          }\n\n          self.web3.currentProvider.send(\n            {\n              jsonrpc: \"2.0\",\n              method: \"eth_getLogs\",\n              params: [\n                {\n                  fromBlock: to.hex(number),\n                  toBlock: to.hex(number)\n                }\n              ],\n              id: new Date().getTime()\n            },\n            function(err, res) {\n              if (err) {\n                return callback(err);\n              }\n\n              var logs = res.result.map(function(log) {\n                // To make this result masquerade as the right information.\n                log.block = block;\n                return new Log(log);\n              });\n\n              callback(null, logs);\n            }\n          );\n        });\n      } else {\n        BlockchainDouble.prototype.getBlockLogs.call(self, relative, callback);\n      }\n    });\n  });\n};\n\nForkedBlockchain.prototype.getQueuedNonce = function(address, callback) {\n  var nonce = null;\n  var addressBuffer = to.buffer(address);\n  this.pending_transactions.forEach(function(tx) {\n    if (!tx.from.equals(addressBuffer)) {\n      return;\n    }\n\n    var pendingNonce = new BN(tx.nonce);\n    // If this is the first queued nonce for this address we found,\n    // or it's higher than the previous highest, note it.\n    if (nonce === null || pendingNonce.gt(nonce)) {\n      nonce = pendingNonce;\n    }\n  });\n\n  // If we found a queued transaction nonce, return one higher\n  // than the highest we found\n  if (nonce != null) {\n    return callback(null, nonce.iaddn(1).toArrayLike(Buffer));\n  }\n  this.getLookupAccount(this.stateTrie)(addressBuffer, function(err, account) {\n    if (err) {\n      return callback(err);\n    }\n\n    // nonces are initialized as an empty buffer, which isn't what we want.\n    callback(null, account.nonce.length === 0 ? Buffer.from([0]) : account.nonce);\n  });\n};\n\nForkedBlockchain.prototype.processCall = function(tx, blockNumber, callback) {\n  const self = this;\n\n  this.getEffectiveBlockNumber(blockNumber, function(err, effectiveBlockNumber) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (effectiveBlockNumber > self.forkBlockNumber) {\n      BlockchainDouble.prototype.processCall.call(self, tx, blockNumber, callback);\n    } else {\n      self.web3.eth.call({\n        from: to.rpcDataHexString(tx.from),\n        to: to.nullableRpcDataHexString(tx.to),\n        data: to.rpcDataHexString(tx.data)\n      }, effectiveBlockNumber, function(err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, {\n          execResult: {\n            returnValue: result\n          }\n        });\n      });\n    }\n  });\n};\n\nForkedBlockchain.prototype.processBlock = async function(vm, block, commit, callback) {\n  const self = this;\n\n  self._touchedKeys = [];\n  BlockchainDouble.prototype.processBlock.call(self, vm, block, commit, callback);\n};\n\nForkedBlockchain.prototype.putBlock = function(block, logs, receipts, callback) {\n  const self = this;\n  const touched = Sublevel(self.data.trie_db).sublevel(\"touched\");\n  const blockKey = `block-${to.number(block.header.number)}`;\n\n  BlockchainDouble.prototype.putBlock.call(self, block, logs, receipts, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    touched.put(blockKey, JSON.stringify(self._touchedKeys), (err) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, result);\n    });\n  });\n};\n\nForkedBlockchain.prototype.popBlock = function(callback) {\n  const self = this;\n  const touched = Sublevel(this.data.trie_db).sublevel(\"touched\");\n\n  this.data.blocks.last(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n    if (block == null) {\n      return callback(null, null);\n    }\n\n    const blockKey = `block-${to.number(block.header.number)}`;\n    touched.get(blockKey, function(err, value) {\n      if (err) {\n        return callback(err);\n      }\n\n      const touchedKeys = value ? JSON.parse(value) : [];\n      async.eachSeries(\n        touchedKeys,\n        function(touchedKey, finished) {\n          touched.del(touchedKey, finished);\n        },\n        function(err) {\n          if (err) {\n            return callback(err);\n          }\n\n          touched.del(blockKey, function(err) {\n            if (err) {\n              return callback(err);\n            }\n\n            BlockchainDouble.prototype.popBlock.call(self, callback);\n          });\n        }\n      );\n    });\n  });\n};\n\nForkedBlockchain.prototype.close = function(callback) {\n  if (this.fork.disconnect) {\n    this.fork.disconnect();\n  }\n  BlockchainDouble.prototype.close.call(this, callback);\n};\n\nmodule.exports = ForkedBlockchain;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\");\n\nvar _require$builders = require(\"../doc\").builders,\n    concat = _require$builders.concat,\n    hardline = _require$builders.hardline,\n    breakParent = _require$builders.breakParent,\n    indent = _require$builders.indent,\n    lineSuffix = _require$builders.lineSuffix,\n    join = _require$builders.join,\n    cursor = _require$builders.cursor;\n\nvar _require = require(\"../common/util\"),\n    hasNewline = _require.hasNewline,\n    skipNewline = _require.skipNewline,\n    isPreviousLineEmpty = _require.isPreviousLineEmpty;\n\nvar _require2 = require(\"../common/util-shared\"),\n    addLeadingComment = _require2.addLeadingComment,\n    addDanglingComment = _require2.addDanglingComment,\n    addTrailingComment = _require2.addTrailingComment;\n\nvar childNodesCacheKey = Symbol(\"child-nodes\");\n\nfunction getSortedChildNodes(node, options, resultArray) {\n  if (!node) {\n    return;\n  }\n\n  var printer = options.printer,\n      locStart = options.locStart,\n      locEnd = options.locEnd;\n\n  if (resultArray) {\n    if (node && printer.canAttachComment && printer.canAttachComment(node)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i;\n\n      for (i = resultArray.length - 1; i >= 0; --i) {\n        if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return;\n    }\n  } else if (node[childNodesCacheKey]) {\n    return node[childNodesCacheKey];\n  }\n\n  var childNodes;\n\n  if (printer.getCommentChildNodes) {\n    childNodes = printer.getCommentChildNodes(node);\n  } else if (node && _typeof(node) === \"object\") {\n    childNodes = Object.keys(node).filter(function (n) {\n      return n !== \"enclosingNode\" && n !== \"precedingNode\" && n !== \"followingNode\";\n    }).map(function (n) {\n      return node[n];\n    });\n  }\n\n  if (!childNodes) {\n    return;\n  }\n\n  if (!resultArray) {\n    Object.defineProperty(node, childNodesCacheKey, {\n      value: resultArray = [],\n      enumerable: false\n    });\n  }\n\n  childNodes.forEach(function (childNode) {\n    getSortedChildNodes(childNode, options, resultArray);\n  });\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, options) {\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  var childNodes = getSortedChildNodes(node, options);\n  var precedingNode;\n  var followingNode; // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes.length;\n\n  while (left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {\n      // The comment is completely contained by this child node.\n      comment.enclosingNode = child;\n      decorateComment(child, comment, options);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    /* istanbul ignore next */\n\n\n    throw new Error(\"Comment location overlaps with node location\");\n  } // We don't want comments inside of different expressions inside of the same\n  // template literal to move to another expression.\n\n\n  if (comment.enclosingNode && comment.enclosingNode.type === \"TemplateLiteral\") {\n    var quasis = comment.enclosingNode.quasis;\n    var commentIndex = findExpressionIndexForComment(quasis, comment, options);\n\n    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n      precedingNode = null;\n    }\n\n    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n      followingNode = null;\n    }\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, text, options) {\n  if (!Array.isArray(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  comments.forEach(function (comment, i) {\n    if (options.parser === \"json\" || options.parser === \"json5\" || options.parser === \"__js_expression\" || options.parser === \"__vue_expression\") {\n      if (locStart(comment) - locStart(ast) <= 0) {\n        addLeadingComment(ast, comment);\n        return;\n      }\n\n      if (locEnd(comment) - locEnd(ast) >= 0) {\n        addTrailingComment(ast, comment);\n        return;\n      }\n    }\n\n    decorateComment(ast, comment, options);\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n    var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {\n      return false;\n    };\n    var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {\n      return false;\n    };\n    var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {\n      return false;\n    };\n    var isLastComment = comments.length - 1 === i;\n\n    if (hasNewline(text, locStart(comment), {\n      backwards: true\n    })) {\n      // If a comment exists on its own line, prefer a leading comment.\n      // We also need to check if it's the first line of the file.\n      if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (followingNode) {\n        // Always a leading comment.\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else if (hasNewline(text, locEnd(comment))) {\n      if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode) {\n        // There is content before this comment on the same line, but\n        // none after it, so prefer a trailing comment of the previous node.\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else {\n      if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode && followingNode) {\n        // Otherwise, text exists both before and after the comment on\n        // the same line. If there is both a preceding and following\n        // node, use a tie-breaking algorithm to determine if it should\n        // be attached to the next or previous node. In the last case,\n        // simply attach the right node;\n        var tieCount = tiesToBreak.length;\n\n        if (tieCount > 0) {\n          var lastTie = tiesToBreak[tieCount - 1];\n\n          if (lastTie.followingNode !== comment.followingNode) {\n            breakTies(tiesToBreak, text, options);\n          }\n        }\n\n        tiesToBreak.push(comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    }\n  });\n  breakTies(tiesToBreak, text, options);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nfunction breakTies(tiesToBreak, text, options) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var _tiesToBreak$ = tiesToBreak[0],\n      precedingNode = _tiesToBreak$.precedingNode,\n      followingNode = _tiesToBreak$.followingNode;\n  var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from followingNode by an unbroken series of\n  // gaps (or other comments). Gaps should only contain whitespace or open\n  // parentheses.\n\n  var indexOfFirstLeadingComment;\n\n  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert.strictEqual(comment.precedingNode, precedingNode);\n    assert.strictEqual(comment.followingNode, followingNode);\n    var gap = text.slice(options.locEnd(comment), gapEndPos).trim();\n\n    if (gap === \"\" || /^\\(+$/.test(gap)) {\n      gapEndPos = options.locStart(comment);\n    } else {\n      // The gap string contained something other than whitespace or open\n      // parentheses.\n      break;\n    }\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n  comment.printed = true;\n  return options.printer.printComment(commentPath, options);\n}\n\nfunction findExpressionIndexForComment(quasis, comment, options) {\n  var startPos = options.locStart(comment) - 1;\n\n  for (var i = 1; i < quasis.length; ++i) {\n    if (startPos < getQuasiRange(quasis[i]).start) {\n      return i - 1;\n    }\n  } // We haven't found it, it probably means that some of the locations are off.\n  // Let's just return the first one.\n\n  /* istanbul ignore next */\n\n\n  return 0;\n}\n\nfunction getQuasiRange(expr) {\n  if (expr.start !== undefined) {\n    // Babel\n    return {\n      start: expr.start,\n      end: expr.end\n    };\n  } // Flow\n\n\n  return {\n    start: expr.range[0],\n    end: expr.range[1]\n  };\n}\n\nfunction printLeadingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the\n  // same line or not.\n\n  if (isBlock) {\n    return concat([contents, hasNewline(options.originalText, options.locEnd(comment)) ? hardline : \" \"]);\n  }\n\n  return concat([contents, hardline]);\n}\n\nfunction printTrailingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break\n  // when the parentParentNode is a ClassDeclaration/-Expression\n  // And the parentNode is in the superClass property\n\n  var parentNode = commentPath.getNode(1);\n  var parentParentNode = commentPath.getNode(2);\n  var isParentSuperClass = parentParentNode && (parentParentNode.type === \"ClassDeclaration\" || parentParentNode.type === \"ClassExpression\") && parentParentNode.superClass === parentNode;\n\n  if (hasNewline(options.originalText, options.locStart(comment), {\n    backwards: true\n  })) {\n    // This allows comments at the end of nested structures:\n    // {\n    //   x: 1,\n    //   y: 2\n    //   // A comment\n    // }\n    // Those kinds of comments are almost always leading comments, but\n    // here it doesn't go \"outside\" the block and turns it into a\n    // trailing comment for `2`. We can simulate the above by checking\n    // if this a comment on its own line; normal trailing comments are\n    // always at the end of another expression.\n    var isLineBeforeEmpty = isPreviousLineEmpty(options.originalText, comment, options.locStart);\n    return lineSuffix(concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents]));\n  } else if (isBlock || isParentSuperClass) {\n    // Trailing block comments never need a newline\n    return concat([\" \", contents]);\n  }\n\n  return concat([lineSuffix(concat([\" \", contents])), !isBlock ? breakParent : \"\"]);\n}\n\nfunction printDanglingComments(path, options, sameIndent, filter) {\n  var parts = [];\n  var node = path.getValue();\n\n  if (!node || !node.comments) {\n    return \"\";\n  }\n\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n\n    if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {\n      parts.push(printComment(commentPath, options));\n    }\n  }, \"comments\");\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  if (sameIndent) {\n    return join(hardline, parts);\n  }\n\n  return indent(concat([hardline, join(hardline, parts)]));\n}\n\nfunction prependCursorPlaceholder(path, options, printed) {\n  if (path.getNode() === options.cursorNode && path.getValue()) {\n    return concat([cursor, printed, cursor]);\n  }\n\n  return printed;\n}\n\nfunction printComments(path, print, options, needsSemi) {\n  var value = path.getValue();\n  var printed = print(path);\n  var comments = value && value.comments;\n\n  if (!comments || comments.length === 0) {\n    return prependCursorPlaceholder(path, options, printed);\n  }\n\n  var leadingParts = [];\n  var trailingParts = [needsSemi ? \";\" : \"\", printed];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = comment.leading,\n        trailing = comment.trailing;\n\n    if (leading) {\n      var contents = printLeadingComment(commentPath, print, options);\n\n      if (!contents) {\n        return;\n      }\n\n      leadingParts.push(contents);\n      var text = options.originalText;\n\n      if (hasNewline(text, skipNewline(text, options.locEnd(comment)))) {\n        leadingParts.push(hardline);\n      }\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print, options));\n    }\n  }, \"comments\");\n  return prependCursorPlaceholder(path, options, concat(leadingParts.concat(trailingParts)));\n}\n\nmodule.exports = {\n  attach: attach,\n  printComments: printComments,\n  printDanglingComments: printDanglingComments,\n  getSortedChildNodes: getSortedChildNodes\n};","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","assert","require","_require$builders","builders","concat","hardline","breakParent","indent","lineSuffix","join","cursor","_require","hasNewline","skipNewline","isPreviousLineEmpty","_require2","addLeadingComment","addDanglingComment","addTrailingComment","childNodesCacheKey","getSortedChildNodes","node","options","resultArray","printer","locStart","locEnd","canAttachComment","i","length","splice","childNodes","getCommentChildNodes","Object","keys","filter","n","map","defineProperty","value","enumerable","forEach","childNode","decorateComment","comment","precedingNode","followingNode","left","right","middle","child","enclosingNode","Error","type","quasis","commentIndex","findExpressionIndexForComment","attach","comments","ast","text","Array","isArray","tiesToBreak","parser","pluginHandleOwnLineComment","handleComments","ownLine","pluginHandleEndOfLineComment","endOfLine","pluginHandleRemainingComment","remaining","isLastComment","backwards","tieCount","lastTie","breakTies","push","_tiesToBreak$","gapEndPos","indexOfFirstLeadingComment","strictEqual","gap","slice","trim","test","printComment","commentPath","getValue","printed","startPos","getQuasiRange","start","expr","undefined","end","range","printLeadingComment","print","contents","isBlock","isBlockComment","originalText","printTrailingComment","parentNode","getNode","parentParentNode","isParentSuperClass","superClass","isLineBeforeEmpty","printDanglingComments","path","sameIndent","parts","each","leading","trailing","prependCursorPlaceholder","cursorNode","printComments","needsSemi","leadingParts","trailingParts","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/main/comments.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\");\n\nvar _require$builders = require(\"../doc\").builders,\n    concat = _require$builders.concat,\n    hardline = _require$builders.hardline,\n    breakParent = _require$builders.breakParent,\n    indent = _require$builders.indent,\n    lineSuffix = _require$builders.lineSuffix,\n    join = _require$builders.join,\n    cursor = _require$builders.cursor;\n\nvar _require = require(\"../common/util\"),\n    hasNewline = _require.hasNewline,\n    skipNewline = _require.skipNewline,\n    isPreviousLineEmpty = _require.isPreviousLineEmpty;\n\nvar _require2 = require(\"../common/util-shared\"),\n    addLeadingComment = _require2.addLeadingComment,\n    addDanglingComment = _require2.addDanglingComment,\n    addTrailingComment = _require2.addTrailingComment;\n\nvar childNodesCacheKey = Symbol(\"child-nodes\");\n\nfunction getSortedChildNodes(node, options, resultArray) {\n  if (!node) {\n    return;\n  }\n\n  var printer = options.printer,\n      locStart = options.locStart,\n      locEnd = options.locEnd;\n\n  if (resultArray) {\n    if (node && printer.canAttachComment && printer.canAttachComment(node)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i;\n\n      for (i = resultArray.length - 1; i >= 0; --i) {\n        if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return;\n    }\n  } else if (node[childNodesCacheKey]) {\n    return node[childNodesCacheKey];\n  }\n\n  var childNodes;\n\n  if (printer.getCommentChildNodes) {\n    childNodes = printer.getCommentChildNodes(node);\n  } else if (node && _typeof(node) === \"object\") {\n    childNodes = Object.keys(node).filter(function (n) {\n      return n !== \"enclosingNode\" && n !== \"precedingNode\" && n !== \"followingNode\";\n    }).map(function (n) {\n      return node[n];\n    });\n  }\n\n  if (!childNodes) {\n    return;\n  }\n\n  if (!resultArray) {\n    Object.defineProperty(node, childNodesCacheKey, {\n      value: resultArray = [],\n      enumerable: false\n    });\n  }\n\n  childNodes.forEach(function (childNode) {\n    getSortedChildNodes(childNode, options, resultArray);\n  });\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, options) {\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  var childNodes = getSortedChildNodes(node, options);\n  var precedingNode;\n  var followingNode; // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes.length;\n\n  while (left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {\n      // The comment is completely contained by this child node.\n      comment.enclosingNode = child;\n      decorateComment(child, comment, options);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    /* istanbul ignore next */\n\n\n    throw new Error(\"Comment location overlaps with node location\");\n  } // We don't want comments inside of different expressions inside of the same\n  // template literal to move to another expression.\n\n\n  if (comment.enclosingNode && comment.enclosingNode.type === \"TemplateLiteral\") {\n    var quasis = comment.enclosingNode.quasis;\n    var commentIndex = findExpressionIndexForComment(quasis, comment, options);\n\n    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n      precedingNode = null;\n    }\n\n    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n      followingNode = null;\n    }\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, text, options) {\n  if (!Array.isArray(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  var locStart = options.locStart,\n      locEnd = options.locEnd;\n  comments.forEach(function (comment, i) {\n    if (options.parser === \"json\" || options.parser === \"json5\" || options.parser === \"__js_expression\" || options.parser === \"__vue_expression\") {\n      if (locStart(comment) - locStart(ast) <= 0) {\n        addLeadingComment(ast, comment);\n        return;\n      }\n\n      if (locEnd(comment) - locEnd(ast) >= 0) {\n        addTrailingComment(ast, comment);\n        return;\n      }\n    }\n\n    decorateComment(ast, comment, options);\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n    var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {\n      return false;\n    };\n    var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {\n      return false;\n    };\n    var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {\n      return false;\n    };\n    var isLastComment = comments.length - 1 === i;\n\n    if (hasNewline(text, locStart(comment), {\n      backwards: true\n    })) {\n      // If a comment exists on its own line, prefer a leading comment.\n      // We also need to check if it's the first line of the file.\n      if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (followingNode) {\n        // Always a leading comment.\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else if (hasNewline(text, locEnd(comment))) {\n      if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode) {\n        // There is content before this comment on the same line, but\n        // none after it, so prefer a trailing comment of the previous node.\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    } else {\n      if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) {// We're good\n      } else if (precedingNode && followingNode) {\n        // Otherwise, text exists both before and after the comment on\n        // the same line. If there is both a preceding and following\n        // node, use a tie-breaking algorithm to determine if it should\n        // be attached to the next or previous node. In the last case,\n        // simply attach the right node;\n        var tieCount = tiesToBreak.length;\n\n        if (tieCount > 0) {\n          var lastTie = tiesToBreak[tieCount - 1];\n\n          if (lastTie.followingNode !== comment.followingNode) {\n            breakTies(tiesToBreak, text, options);\n          }\n        }\n\n        tiesToBreak.push(comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        // There are no nodes, let's attach it to the root of the ast\n\n        /* istanbul ignore next */\n        addDanglingComment(ast, comment);\n      }\n    }\n  });\n  breakTies(tiesToBreak, text, options);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nfunction breakTies(tiesToBreak, text, options) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var _tiesToBreak$ = tiesToBreak[0],\n      precedingNode = _tiesToBreak$.precedingNode,\n      followingNode = _tiesToBreak$.followingNode;\n  var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from followingNode by an unbroken series of\n  // gaps (or other comments). Gaps should only contain whitespace or open\n  // parentheses.\n\n  var indexOfFirstLeadingComment;\n\n  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert.strictEqual(comment.precedingNode, precedingNode);\n    assert.strictEqual(comment.followingNode, followingNode);\n    var gap = text.slice(options.locEnd(comment), gapEndPos).trim();\n\n    if (gap === \"\" || /^\\(+$/.test(gap)) {\n      gapEndPos = options.locStart(comment);\n    } else {\n      // The gap string contained something other than whitespace or open\n      // parentheses.\n      break;\n    }\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n  comment.printed = true;\n  return options.printer.printComment(commentPath, options);\n}\n\nfunction findExpressionIndexForComment(quasis, comment, options) {\n  var startPos = options.locStart(comment) - 1;\n\n  for (var i = 1; i < quasis.length; ++i) {\n    if (startPos < getQuasiRange(quasis[i]).start) {\n      return i - 1;\n    }\n  } // We haven't found it, it probably means that some of the locations are off.\n  // Let's just return the first one.\n\n  /* istanbul ignore next */\n\n\n  return 0;\n}\n\nfunction getQuasiRange(expr) {\n  if (expr.start !== undefined) {\n    // Babel\n    return {\n      start: expr.start,\n      end: expr.end\n    };\n  } // Flow\n\n\n  return {\n    start: expr.range[0],\n    end: expr.range[1]\n  };\n}\n\nfunction printLeadingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the\n  // same line or not.\n\n  if (isBlock) {\n    return concat([contents, hasNewline(options.originalText, options.locEnd(comment)) ? hardline : \" \"]);\n  }\n\n  return concat([contents, hardline]);\n}\n\nfunction printTrailingComment(commentPath, print, options) {\n  var comment = commentPath.getValue();\n  var contents = printComment(commentPath, options);\n\n  if (!contents) {\n    return \"\";\n  }\n\n  var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break\n  // when the parentParentNode is a ClassDeclaration/-Expression\n  // And the parentNode is in the superClass property\n\n  var parentNode = commentPath.getNode(1);\n  var parentParentNode = commentPath.getNode(2);\n  var isParentSuperClass = parentParentNode && (parentParentNode.type === \"ClassDeclaration\" || parentParentNode.type === \"ClassExpression\") && parentParentNode.superClass === parentNode;\n\n  if (hasNewline(options.originalText, options.locStart(comment), {\n    backwards: true\n  })) {\n    // This allows comments at the end of nested structures:\n    // {\n    //   x: 1,\n    //   y: 2\n    //   // A comment\n    // }\n    // Those kinds of comments are almost always leading comments, but\n    // here it doesn't go \"outside\" the block and turns it into a\n    // trailing comment for `2`. We can simulate the above by checking\n    // if this a comment on its own line; normal trailing comments are\n    // always at the end of another expression.\n    var isLineBeforeEmpty = isPreviousLineEmpty(options.originalText, comment, options.locStart);\n    return lineSuffix(concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents]));\n  } else if (isBlock || isParentSuperClass) {\n    // Trailing block comments never need a newline\n    return concat([\" \", contents]);\n  }\n\n  return concat([lineSuffix(concat([\" \", contents])), !isBlock ? breakParent : \"\"]);\n}\n\nfunction printDanglingComments(path, options, sameIndent, filter) {\n  var parts = [];\n  var node = path.getValue();\n\n  if (!node || !node.comments) {\n    return \"\";\n  }\n\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n\n    if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {\n      parts.push(printComment(commentPath, options));\n    }\n  }, \"comments\");\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  if (sameIndent) {\n    return join(hardline, parts);\n  }\n\n  return indent(concat([hardline, join(hardline, parts)]));\n}\n\nfunction prependCursorPlaceholder(path, options, printed) {\n  if (path.getNode() === options.cursorNode && path.getValue()) {\n    return concat([cursor, printed, cursor]);\n  }\n\n  return printed;\n}\n\nfunction printComments(path, print, options, needsSemi) {\n  var value = path.getValue();\n  var printed = print(path);\n  var comments = value && value.comments;\n\n  if (!comments || comments.length === 0) {\n    return prependCursorPlaceholder(path, options, printed);\n  }\n\n  var leadingParts = [];\n  var trailingParts = [needsSemi ? \";\" : \"\", printed];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = comment.leading,\n        trailing = comment.trailing;\n\n    if (leading) {\n      var contents = printLeadingComment(commentPath, print, options);\n\n      if (!contents) {\n        return;\n      }\n\n      leadingParts.push(contents);\n      var text = options.originalText;\n\n      if (hasNewline(text, skipNewline(text, options.locEnd(comment)))) {\n        leadingParts.push(hardline);\n      }\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print, options));\n    }\n  }, \"comments\");\n  return prependCursorPlaceholder(path, options, concat(leadingParts.concat(trailingParts)));\n}\n\nmodule.exports = {\n  attach: attach,\n  printComments: printComments,\n  printDanglingComments: printDanglingComments,\n  getSortedChildNodes: getSortedChildNodes\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
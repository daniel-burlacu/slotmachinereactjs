{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs_1 = require(\"@resolver-engine/fs\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"resolverengine:ethpmresolver\"); // 1st group - package name\n// 2nd group - contract path\n\nconst FILE_LOCATION_REGEX = /^([^/]+)\\/(.+)$/;\nconst prefixTruffle = \"installed_contracts\";\nconst prefix0x = \"contracts\";\n\nfunction EthPmResolver() {\n  const backtrackT = fs_1.resolvers.BacktrackFsResolver(prefixTruffle);\n  const backtrack0x = fs_1.resolvers.BacktrackFsResolver(prefix0x);\n  return function ethpm(what, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fileMatch = what.match(FILE_LOCATION_REGEX);\n\n      if (!fileMatch) {\n        return null;\n      }\n\n      let result = yield backtrackT(what, ctx);\n\n      if (result) {\n        debug(\"Resolved %s to %s\", what, result);\n        return result;\n      }\n\n      result = yield backtrack0x(what, ctx);\n\n      if (result) {\n        debug(\"Resolved %s to %s\", what, result);\n        return result;\n      }\n\n      return null;\n    });\n  };\n}\n\nexports.EthPmResolver = EthPmResolver;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA,MAAMA,KAAK,GAAGC,gBAAM,8BAAN,CAAd,C,CAEA;AACA;;AACA,MAAMC,mBAAmB,GAAG,iBAA5B;AAEA,MAAMC,aAAa,GAAG,qBAAtB;AACA,MAAMC,QAAQ,GAAG,WAAjB;;AAEA,SAAgBC,aAAhB,GAA6B;EAC3B,MAAMC,UAAU,GAAGC,eAAUC,mBAAV,CAA8BL,aAA9B,CAAnB;EACA,MAAMM,WAAW,GAAGF,eAAUC,mBAAV,CAA8BJ,QAA9B,CAApB;EAEA,OAAO,SAAeM,KAAf,CAAqBC,IAArB,EAAmCC,GAAnC,EAA+C;;MACpD,MAAMC,SAAS,GAAGF,IAAI,CAACG,KAAL,CAAWZ,mBAAX,CAAlB;;MACA,IAAI,CAACW,SAAL,EAAgB;QACd,OAAO,IAAP;MACD;;MAED,IAAIE,MAAM,GAAG,MAAMT,UAAU,CAACK,IAAD,EAAOC,GAAP,CAA7B;;MACA,IAAIG,MAAJ,EAAY;QACVf,KAAK,CAAC,mBAAD,EAAsBW,IAAtB,EAA4BI,MAA5B,CAAL;QACA,OAAOA,MAAP;MACD;;MAEDA,MAAM,GAAG,MAAMN,WAAW,CAACE,IAAD,EAAOC,GAAP,CAA1B;;MACA,IAAIG,MAAJ,EAAY;QACVf,KAAK,CAAC,mBAAD,EAAsBW,IAAtB,EAA4BI,MAA5B,CAAL;QACA,OAAOA,MAAP;MACD;;MAED,OAAO,IAAP;IACD;EAAA,CAnBD;AAoBD;;AAxBDC","names":["debug","debug_1","FILE_LOCATION_REGEX","prefixTruffle","prefix0x","EthPmResolver","backtrackT","fs_1","BacktrackFsResolver","backtrack0x","ethpm","what","ctx","fileMatch","match","result","exports"],"sources":["F:\\Games\\slotmachinereact\\node_modules\\@resolver-engine\\imports-fs\\src\\resolvers\\ethpmresolver.ts"],"sourcesContent":["import { Context, SubResolver } from \"@resolver-engine/core\";\nimport { resolvers } from \"@resolver-engine/fs\";\nimport Debug from \"debug\";\nconst debug = Debug(\"resolverengine:ethpmresolver\");\n\n// 1st group - package name\n// 2nd group - contract path\nconst FILE_LOCATION_REGEX = /^([^/]+)\\/(.+)$/;\n\nconst prefixTruffle = \"installed_contracts\";\nconst prefix0x = \"contracts\";\n\nexport function EthPmResolver(): SubResolver {\n  const backtrackT = resolvers.BacktrackFsResolver(prefixTruffle);\n  const backtrack0x = resolvers.BacktrackFsResolver(prefix0x);\n\n  return async function ethpm(what: string, ctx: Context): Promise<string | null> {\n    const fileMatch = what.match(FILE_LOCATION_REGEX);\n    if (!fileMatch) {\n      return null;\n    }\n\n    let result = await backtrackT(what, ctx);\n    if (result) {\n      debug(\"Resolved %s to %s\", what, result);\n      return result;\n    }\n\n    result = await backtrack0x(what, ctx);\n    if (result) {\n      debug(\"Resolved %s to %s\", what, result);\n      return result;\n    }\n\n    return null;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}
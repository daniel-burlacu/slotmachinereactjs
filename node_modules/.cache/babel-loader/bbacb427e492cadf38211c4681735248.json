{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nvar assert = require(\"assert\");\n\nvar BN = require(\"bn.js\");\n\nvar rlp = require(\"rlp\");\n\nvar ethjs_util_1 = require(\"ethjs-util\");\n\nvar constants_1 = require(\"./constants\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar types_1 = require(\"./types\");\n\nvar _a = require('ethereum-cryptography/secp256k1'),\n    privateKeyVerify = _a.privateKeyVerify,\n    publicKeyCreate = _a.publicKeyCreate,\n    publicKeyVerify = _a.publicKeyVerify,\n    publicKeyConvert = _a.publicKeyConvert;\n\nvar Account =\n/** @class */\nfunction () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new BN(0);\n    }\n\n    if (balance === void 0) {\n      balance = new BN(0);\n    }\n\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n        balance = accountData.balance,\n        stateRoot = accountData.stateRoot,\n        codeHash = accountData.codeHash;\n    return new Account(nonce ? new BN(bytes_1.toBuffer(nonce)) : undefined, balance ? new BN(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n  };\n\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  };\n\n  Account.fromValuesArray = function (values) {\n    var nonce = values[0],\n        balance = values[1],\n        stateRoot = values[2],\n        codeHash = values[3];\n    return new Account(nonce ? new BN(nonce) : undefined, balance ? new BN(balance) : undefined, stateRoot, codeHash);\n  };\n\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new BN(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new BN(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  Account.prototype.raw = function () {\n    return [types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  Account.prototype.serialize = function () {\n    return rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nexports.isValidAddress = function (hexAddress) {\n  helpers_1.assertIsHexString(hexAddress);\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\n\n\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  helpers_1.assertIsHexString(hexAddress);\n  var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccakFromString(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\n\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(nonce);\n  var nonceBN = new BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(salt);\n  helpers_1.assertIsBuffer(initCode);\n  assert(from.length === 20);\n  assert(salt.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n  return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1));\n  }\n\n  assert(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToPublic = function (privateKey) {\n  helpers_1.assertIsBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\n\n\nexports.isZeroAddress = function (hexAddress) {\n  helpers_1.assertIsHexString(hexAddress);\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === hexAddress;\n};","map":{"version":3,"mappings":"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","names":["require","privateKeyVerify","publicKeyCreate","publicKeyVerify","publicKeyConvert","nonce","balance","stateRoot","codeHash","BN","constants_1","_validate","Account","accountData","bytes_1","undefined","serialized","values","rlp","decode","Array","isArray","Error","fromValuesArray","lt","length","types_1","encode","raw","equals","isZero","exports","hexAddress","helpers_1","test","eip1191ChainId","address","ethjs_util_1","toLowerCase","prefix","toString","hash","hash_1","ret","i","parseInt","toUpperCase","from","nonceBN","slice","Buffer","toArray","salt","initCode","assert","concat","privateKey","publicKey","sanitize","pubKey","addressLength","addr","zeroAddr"],"sources":["../src/account.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
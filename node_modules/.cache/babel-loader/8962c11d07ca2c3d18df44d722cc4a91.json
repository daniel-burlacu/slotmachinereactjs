{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst _c = fs.constants && os.constants ? {\n  fs: fs.constants,\n  os: os.constants\n} : process.binding('constants');\n\nconst rimraf = require('rimraf');\n/*\n * The working inner variables.\n */\n\n\nconst // the random characters to choose from\nRANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n      TEMPLATE_PATTERN = /XXXXXX/,\n      DEFAULT_TRIES = 3,\n      CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n      EBADF = _c.EBADF || _c.os.errno.EBADF,\n      ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n      DIR_MODE = 448\n/* 0o700 */\n,\n      FILE_MODE = 384\n/* 0o600 */\n,\n      EXIT = 'exit',\n      SIGINT = 'SIGINT',\n      // this will hold the objects need to be removed on exit\n_removeObjects = [];\nvar _gracefulCleanup = false;\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\n\nfunction _randomChars(howMany) {\n  var value = [],\n      rnd = null; // make sure that we do not fail because we ran out of entropy\n\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\n\n\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\n\n\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n  /* istanbul ignore else */\n\n\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\n\n\nfunction _generateTmpName(opts) {\n  const tmpDir = _getTmpDir(); // fail early on missing tmp dir\n\n\n  if (isBlank(opts.dir) && isBlank(tmpDir)) {\n    throw new Error('No tmp dir specified');\n  }\n  /* istanbul ignore else */\n\n\n  if (!isBlank(opts.name)) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  } // mkstemps like template\n  // opts.template has already been guarded in tmpName() below\n\n  /* istanbul ignore else */\n\n\n  if (opts.template) {\n    var template = opts.template; // make sure that we prepend the tmp path if none was given\n\n    /* istanbul ignore else */\n\n    if (path.basename(template) === template) template = path.join(opts.dir || tmpDir, template);\n    return template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  } // prefix and postfix\n\n\n  const name = [isBlank(opts.prefix) ? 'tmp-' : opts.prefix, process.pid, _randomChars(12), opts.postfix ? opts.postfix : ''].join('');\n  return path.join(opts.dir || tmpDir, name);\n}\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\n\n\nfunction tmpName(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1],\n      tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n  /* istanbul ignore else */\n\n\n  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));\n  /* istanbul ignore else */\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts); // check whether the path exists then retry if needed\n\n\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\n\n\nfunction tmpNameSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0],\n      tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n  /* istanbul ignore else */\n\n\n  if (isNaN(tries) || tries < 0) throw new Error('Invalid tries');\n  /* istanbul ignore else */\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\n\n\nfunction file(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create and open the file\n\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          /* istanbul ignore else */\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n\n            return cb(err);\n          }\n\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      /* istanbul ignore else */\n\n\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\n\n\nfunction fileSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\n\n\nfunction dir(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create the directory\n\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\n\n\nfunction dirSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\n\n\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n\n    next();\n  };\n\n  if (0 <= fdPath[0]) fs.close(fdPath[0], function (err) {\n    fs.unlink(fdPath[1], _handler);\n  });else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\n\n\nfunction _removeFileSync(fdPath) {\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!isEBADF(e) && !isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!isENOENT(e)) throw e;\n    }\n  }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\n\n\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);\n\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return removeCallback;\n}\n/**\n * Simple wrapper for rimraf.\n *\n * @param {string} dirPath\n * @param {Function} next\n * @private\n */\n\n\nfunction _rimrafRemoveDirWrapper(dirPath, next) {\n  rimraf(dirPath, next);\n}\n/**\n * Simple wrapper for rimraf.sync.\n *\n * @param {string} dirPath\n * @private\n */\n\n\nfunction _rimrafRemoveDirSyncWrapper(dirPath, next) {\n  try {\n    return next(null, rimraf.sync(dirPath));\n  } catch (err) {\n    return next(err);\n  }\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\n\n\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);\n\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);\n\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\n\n\nfunction _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {\n  var called = false;\n  return function _cleanupCallback(next) {\n    next = next || function () {};\n\n    if (!called) {\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n\n\n      if (index >= 0) _removeObjects.splice(index, 1);\n      called = true; // sync?\n\n      if (removeFunction.length === 1) {\n        try {\n          removeFunction(arg);\n          return next(null);\n        } catch (err) {\n          // if no next is provided and since we are\n          // in silent cleanup mode on process exit,\n          // we will ignore the error\n          return next(err);\n        }\n      } else return removeFunction(arg, next);\n    } else return next(new Error('cleanup callback has already been called'));\n  };\n}\n/**\n * The garbage collector.\n *\n * @private\n */\n\n\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return; // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {// already removed?\n    }\n  }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\n\n\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\n\n\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {string|number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {number} negated\n *   error.errno n/a\n */\n\n\nfunction isExpectedError(error, code, errno) {\n  return error.code === code || error.code === errno;\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\n\n\nfunction isBlank(s) {\n  return s === null || s === undefined || !s.trim();\n}\n/**\n * Sets the graceful cleanup.\n */\n\n\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @returns {string} the currently configured tmp dir\n */\n\n\nfunction _getTmpDir() {\n  return os.tmpdir();\n}\n/**\n * If there are multiple different versions of tmp in place, make sure that\n * we recognize the old listeners.\n *\n * @param {Function} listener\n * @private\n * @returns {Boolean} true whether listener is a legacy listener\n */\n\n\nfunction _is_legacy_listener(listener) {\n  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown') && listener.toString().indexOf('_garbageCollector();') > -1;\n}\n/**\n * Safely install SIGINT listener.\n *\n * NOTE: this will only work on OSX and Linux.\n *\n * @private\n */\n\n\nfunction _safely_install_sigint_listener() {\n  const listeners = process.listeners(SIGINT);\n  const existingListeners = [];\n\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n\n    if (lstnr.name === '_tmp$sigint_listener') {\n      existingListeners.push(lstnr);\n      process.removeListener(SIGINT, lstnr);\n    }\n  }\n\n  process.on(SIGINT, function _tmp$sigint_listener(doExit) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](false);\n      } catch (err) {// ignore\n      }\n    }\n\n    try {\n      // force the garbage collector even it is called again in the exit listener\n      _garbageCollector();\n    } finally {\n      if (!!doExit) {\n        process.exit(0);\n      }\n    }\n  });\n}\n/**\n * Safely install process exit listener.\n *\n * @private\n */\n\n\nfunction _safely_install_exit_listener() {\n  const listeners = process.listeners(EXIT); // collect any existing listeners\n\n  const existingListeners = [];\n\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    // TODO: remove support for legacy listeners once release 1.0.0 is out\n\n    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {\n      // we must forget about the uncaughtException listener, hopefully it is ours\n      if (lstnr.name !== '_uncaughtExceptionThrown') {\n        existingListeners.push(lstnr);\n      }\n\n      process.removeListener(EXIT, lstnr);\n    }\n  } // TODO: what was the data parameter good for?\n\n\n  process.addListener(EXIT, function _tmp$safe_listener(data) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](data);\n      } catch (err) {// ignore\n      }\n    }\n\n    _garbageCollector();\n  });\n}\n\n_safely_install_exit_listener();\n\n_safely_install_sigint_listener();\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n// exporting all the needed methods\n// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\n\n\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;","map":{"version":3,"names":["fs","require","os","path","crypto","_c","constants","process","binding","rimraf","RANDOM_CHARS","TEMPLATE_PATTERN","DEFAULT_TRIES","CREATE_FLAGS","O_CREAT","O_EXCL","O_RDWR","EBADF","errno","ENOENT","DIR_MODE","FILE_MODE","EXIT","SIGINT","_removeObjects","_gracefulCleanup","_randomChars","howMany","value","rnd","randomBytes","e","pseudoRandomBytes","i","push","length","join","_isUndefined","obj","_parseArguments","options","callback","_generateTmpName","opts","tmpDir","_getTmpDir","isBlank","dir","Error","name","template","basename","replace","prefix","pid","postfix","tmpName","args","cb","tries","isNaN","match","_getUniqueName","stat","err","tmpNameSync","statSync","file","_tmpNameCreated","open","mode","_fileCreated","fd","discardDescriptor","close","_discardCallback","unlinkSync","isENOENT","undefined","_prepareTmpFileRemoveCallback","detachDescriptor","fileSync","discardOrDetachDescriptor","openSync","closeSync","removeCallback","mkdir","_dirCreated","_prepareTmpDirRemoveCallback","dirSync","mkdirSync","_removeFileAsync","fdPath","next","_handler","unlink","_removeFileSync","isEBADF","removeCallbackSync","_prepareRemoveCallback","keep","unshift","_rimrafRemoveDirWrapper","dirPath","_rimrafRemoveDirSyncWrapper","sync","removeFunction","unsafeCleanup","rmdir","bind","removeFunctionSync","rmdirSync","arg","cleanupCallbackSync","called","_cleanupCallback","toRemove","index","indexOf","splice","_garbageCollector","error","isExpectedError","code","s","trim","setGracefulCleanup","tmpdir","_is_legacy_listener","listener","toString","_safely_install_sigint_listener","listeners","existingListeners","lstnr","removeListener","on","_tmp$sigint_listener","doExit","exit","_safely_install_exit_listener","addListener","_tmp$safe_listener","data","Object","defineProperty","module","exports","enumerable","configurable","get"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/tmp/lib/tmp.js"],"sourcesContent":["/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = fs.constants && os.constants ?\n  { fs: fs.constants, os: os.constants } :\n  process.binding('constants');\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 448 /* 0o700 */,\n  FILE_MODE = 384 /* 0o600 */,\n\n  EXIT = 'exit',\n\n  SIGINT = 'SIGINT',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [];\n\nvar\n  _gracefulCleanup = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = _getTmpDir();\n\n  // fail early on missing tmp dir\n  if (isBlank(opts.dir) && isBlank(tmpDir)) {\n    throw new Error('No tmp dir specified');\n  }\n\n  /* istanbul ignore else */\n  if (!isBlank(opts.name)) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  }\n\n  // mkstemps like template\n  // opts.template has already been guarded in tmpName() below\n  /* istanbul ignore else */\n  if (opts.template) {\n    var template = opts.template;\n    // make sure that we prepend the tmp path if none was given\n    /* istanbul ignore else */\n    if (path.basename(template) === template)\n      template = path.join(opts.dir || tmpDir, template);\n    return template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    (isBlank(opts.prefix) ? 'tmp-' : opts.prefix),\n    process.pid,\n    _randomChars(12),\n    (opts.postfix ? opts.postfix : '')\n  ].join('');\n\n  return path.join(opts.dir || tmpDir, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          /* istanbul ignore else */\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n            return cb(err);\n          }\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      /* istanbul ignore else */\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  }\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function (err) {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!isEBADF(e) && !isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!isENOENT(e)) throw e;\n    }\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Simple wrapper for rimraf.\n *\n * @param {string} dirPath\n * @param {Function} next\n * @private\n */\nfunction _rimrafRemoveDirWrapper(dirPath, next) {\n  rimraf(dirPath, next);\n}\n\n/**\n * Simple wrapper for rimraf.sync.\n *\n * @param {string} dirPath\n * @private\n */\nfunction _rimrafRemoveDirSyncWrapper(dirPath, next) {\n  try {\n    return next(null, rimraf.sync(dirPath));\n  } catch (err) {\n    return next(err);\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {\n  var called = false;\n\n  return function _cleanupCallback(next) {\n    next = next || function () {};\n    if (!called) {\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      // sync?\n      if (removeFunction.length === 1) {\n        try {\n          removeFunction(arg);\n          return next(null);\n        }\n        catch (err) {\n          // if no next is provided and since we are\n          // in silent cleanup mode on process exit,\n          // we will ignore the error\n          return next(err);\n        }\n      } else return removeFunction(arg, next);\n    } else return next(new Error('cleanup callback has already been called'));\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {string|number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {number} negated\n *   error.errno n/a\n */\nfunction isExpectedError(error, code, errno) {\n  return error.code === code || error.code === errno;\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction isBlank(s) {\n  return s === null || s === undefined || !s.trim();\n}\n\n/**\n * Sets the graceful cleanup.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir() {\n  return os.tmpdir();\n}\n\n/**\n * If there are multiple different versions of tmp in place, make sure that\n * we recognize the old listeners.\n *\n * @param {Function} listener\n * @private\n * @returns {Boolean} true whether listener is a legacy listener\n */\nfunction _is_legacy_listener(listener) {\n  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown')\n    && listener.toString().indexOf('_garbageCollector();') > -1;\n}\n\n/**\n * Safely install SIGINT listener.\n *\n * NOTE: this will only work on OSX and Linux.\n *\n * @private\n */\nfunction _safely_install_sigint_listener() {\n\n  const listeners = process.listeners(SIGINT);\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    if (lstnr.name === '_tmp$sigint_listener') {\n      existingListeners.push(lstnr);\n      process.removeListener(SIGINT, lstnr);\n    }\n  }\n  process.on(SIGINT, function _tmp$sigint_listener(doExit) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](false);\n      } catch (err) {\n        // ignore\n      }\n    }\n    try {\n      // force the garbage collector even it is called again in the exit listener\n      _garbageCollector();\n    } finally {\n      if (!!doExit) {\n        process.exit(0);\n      }\n    }\n  });\n}\n\n/**\n * Safely install process exit listener.\n *\n * @private\n */\nfunction _safely_install_exit_listener() {\n  const listeners = process.listeners(EXIT);\n\n  // collect any existing listeners\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    // TODO: remove support for legacy listeners once release 1.0.0 is out\n    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {\n      // we must forget about the uncaughtException listener, hopefully it is ours\n      if (lstnr.name !== '_uncaughtExceptionThrown') {\n        existingListeners.push(lstnr);\n      }\n      process.removeListener(EXIT, lstnr);\n    }\n  }\n  // TODO: what was the data parameter good for?\n  process.addListener(EXIT, function _tmp$safe_listener(data) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](data);\n      } catch (err) {\n        // ignore\n      }\n    }\n    _garbageCollector();\n  });\n}\n\n_safely_install_exit_listener();\n_safely_install_sigint_listener();\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// make sourcemaps work!\nrequire(\"source-map-support/register\");\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst SubscriptionSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nconst RequestFunnel = require(\"./subproviders/requestfunnel\");\n\nconst DelayedBlockFilter = require(\"./subproviders/delayedblockfilter\");\n\nconst GethDefaults = require(\"./subproviders/gethdefaults\");\n\nconst GethApiDouble = require(\"./subproviders/geth_api_double\");\n\nconst BlockTracker = require(\"./block_tracker\");\n\nconst RuntimeError = require(\"./utils/runtimeerror\");\n\nconst EventEmitter = require(\"events\");\n\nconst _ = require(\"lodash\");\n\nfunction Provider(options) {\n  const self = this;\n  EventEmitter.call(this);\n  this.options = options = self._applyDefaultOptions(options || {});\n  const gethApiDouble = new GethApiDouble(options, this);\n  this.engine = new ProviderEngine({\n    blockTracker: new BlockTracker({\n      blockchain: gethApiDouble.state.blockchain\n    })\n  });\n  const subscriptionSubprovider = new SubscriptionSubprovider();\n  this.engine.manager = gethApiDouble;\n  this.engine.addProvider(new RequestFunnel());\n  this.engine.addProvider(new DelayedBlockFilter());\n  this.engine.addProvider(subscriptionSubprovider);\n  this.engine.addProvider(new GethDefaults());\n  this.engine.addProvider(gethApiDouble);\n  this.engine.setMaxListeners(100);\n  this.engine.start();\n  this.manager = gethApiDouble;\n  this.sendAsync = this.send.bind(this);\n  this.send = this.send.bind(this);\n  this.close = this.close.bind(this);\n  this._queueRequest = this._queueRequest.bind(this);\n  this._processRequestQueue = this._processRequestQueue.bind(this);\n  subscriptionSubprovider.on(\"data\", function (err, notification) {\n    self.emit(\"data\", err, notification);\n  });\n}\n\nconst defaultOptions = {\n  _chainId: 1,\n  _chainIdRpc: 1337,\n  vmErrorsOnRPCResponse: true,\n  verbose: false,\n  asyncRequestProcessing: false,\n  logger: {\n    log: function () {}\n  }\n};\nProvider.prototype = Object.create(EventEmitter.prototype);\nProvider.prototype.constructor = Provider;\n\nProvider.prototype._applyDefaultOptions = function (options) {\n  return _.merge({}, defaultOptions, options);\n};\n\nProvider.prototype.send = function (payload, callback) {\n  if (typeof callback !== \"function\") {\n    throw new Error(\"No callback provided to provider's send function. As of web3 1.0, provider.send \" + \"is no longer synchronous and must be passed a callback as its final argument.\");\n  }\n\n  const self = this;\n\n  const externalize = function (payload) {\n    return _.cloneDeep(payload);\n  };\n\n  if (Array.isArray(payload)) {\n    payload = payload.map(externalize);\n  } else {\n    payload = externalize(payload);\n  }\n\n  const intermediary = function (err, result) {\n    // clone result so that we can mutate the response without worrying about\n    // that messing up assumptions the calling logic might have about us\n    // mutating things\n    result = _.cloneDeep(result);\n    let response;\n\n    if (Array.isArray(result)) {\n      response = [];\n\n      for (let i = 0; i < result.length; i++) {\n        response.push(self.reportErrorInResponse(payload[i], err, result[i]));\n      }\n    } else {\n      response = self.reportErrorInResponse(payload, err, result);\n    }\n\n    if (self.options.verbose) {\n      self.options.logger.log(\" <   \" + JSON.stringify(response, null, 2).split(\"\\n\").join(\"\\n <   \"));\n    }\n\n    process.nextTick(() => callback(response.error ? err : null, response));\n  };\n\n  if (self.options.verbose) {\n    self.options.logger.log(\"   > \" + JSON.stringify(payload, null, 2).split(\"\\n\").join(\"\\n   > \"));\n  }\n\n  if (self.options.asyncRequestProcessing) {\n    self.engine.sendAsync(payload, intermediary);\n  } else {\n    self._queueRequest(payload, intermediary);\n  }\n};\n\nProvider.prototype.close = function (callback) {\n  // This is a little gross reaching, but...\n  this.manager.state.stopMining();\n  this.manager.state.blockchain.close(callback);\n  this.engine.stop();\n};\n\nProvider.prototype._queueRequest = function (payload, intermediary) {\n  if (!this._requestQueue) {\n    this._requestQueue = [];\n  }\n\n  this._requestQueue.push({\n    payload: payload,\n    callback: intermediary\n  });\n\n  setImmediate(this._processRequestQueue);\n};\n\nProvider.prototype._processRequestQueue = function () {\n  const self = this;\n\n  if (self._requestInProgress) {\n    return;\n  }\n\n  self._requestInProgress = true;\n\n  const args = self._requestQueue.shift();\n\n  if (args) {\n    self.engine.sendAsync(args.payload, (err, result) => {\n      if (self._requestQueue.length > 0) {\n        setImmediate(self._processRequestQueue);\n      }\n\n      args.callback(err, result);\n      self._requestInProgress = false;\n    });\n  } else {\n    // still need to free the lock\n    self._requestInProgress = false;\n\n    if (self._requestQueue.length > 0) {\n      setImmediate(self._processRequestQueue);\n    }\n  }\n};\n\nProvider.prototype.cleanUpErrorObject = function (err, response) {\n  // Our response should already have an error field at this point, if it\n  // doesn't, this was likely intentional. If not, this is the wrong place to\n  // fix that problem.\n  if (!err || !response.error) {\n    return response;\n  }\n\n  const errorObject = {\n    error: {\n      data: {}\n    }\n  };\n\n  if (err.message) {\n    // clean up the error reporting done by the provider engine so the error message isn't lost in the stack trace noise\n    errorObject.error.message = err.message;\n    errorObject.error.data.stack = err.stack;\n    errorObject.error.data.name = err.name;\n\n    if (\"code\" in err) {\n      errorObject.error.code = err.code;\n    }\n  } else if (!response.error) {\n    errorObject.error = {\n      message: err.toString()\n    };\n  }\n\n  return _.merge(response, errorObject);\n}; // helper set of RPC methods which execute code and respond with a transaction hash as their result\n\n\nconst transactionMethods = new Set([\"eth_sendTransaction\", \"eth_sendRawTransaction\", \"personal_sendTransaction\"]);\n\nProvider.prototype._isTransactionRequest = function (request) {\n  return transactionMethods.has(request.method);\n};\n\nProvider.prototype.reportErrorInResponse = function (request, err, response) {\n  const self = this;\n\n  if (!err) {\n    return response;\n  } // TODO: for next major release: move reporting of tx hash on error to error\n  // field to prevent poorly-written clients which assume that the existence of\n  // the \"result\" field implies no errors from breaking.\n\n\n  if (self._isTransactionRequest(request)) {\n    if (err instanceof RuntimeError) {\n      // Make sure we always return the transaction hash on failed transactions so\n      // the caller can get their tx receipt. This breaks JSONRPC 2.0, but it's how\n      // we've always done it.\n      response.result = err.hashes[0];\n\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        delete response.error;\n      }\n    }\n  }\n\n  if (request.method === \"eth_call\") {\n    if (err instanceof RuntimeError) {\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        response.result = err.results[err.hashes[0]].return || \"0x\";\n        delete response.error;\n      }\n    }\n  }\n\n  return self.cleanUpErrorObject(err, response);\n};\n\nmodule.exports = Provider;","map":{"version":3,"names":["require","ProviderEngine","SubscriptionSubprovider","RequestFunnel","DelayedBlockFilter","GethDefaults","GethApiDouble","BlockTracker","RuntimeError","EventEmitter","_","Provider","options","self","call","_applyDefaultOptions","gethApiDouble","engine","blockTracker","blockchain","state","subscriptionSubprovider","manager","addProvider","setMaxListeners","start","sendAsync","send","bind","close","_queueRequest","_processRequestQueue","on","err","notification","emit","defaultOptions","_chainId","_chainIdRpc","vmErrorsOnRPCResponse","verbose","asyncRequestProcessing","logger","log","prototype","Object","create","constructor","merge","payload","callback","Error","externalize","cloneDeep","Array","isArray","map","intermediary","result","response","i","length","push","reportErrorInResponse","JSON","stringify","split","join","process","nextTick","error","stopMining","stop","_requestQueue","setImmediate","_requestInProgress","args","shift","cleanUpErrorObject","errorObject","data","message","stack","name","code","toString","transactionMethods","Set","_isTransactionRequest","request","has","method","hashes","results","return","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/provider.js"],"sourcesContent":["// make sourcemaps work!\nrequire(\"source-map-support/register\");\n\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst SubscriptionSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nconst RequestFunnel = require(\"./subproviders/requestfunnel\");\nconst DelayedBlockFilter = require(\"./subproviders/delayedblockfilter\");\nconst GethDefaults = require(\"./subproviders/gethdefaults\");\nconst GethApiDouble = require(\"./subproviders/geth_api_double\");\n\nconst BlockTracker = require(\"./block_tracker\");\n\nconst RuntimeError = require(\"./utils/runtimeerror\");\nconst EventEmitter = require(\"events\");\n\nconst _ = require(\"lodash\");\n\nfunction Provider(options) {\n  const self = this;\n  EventEmitter.call(this);\n\n  this.options = options = self._applyDefaultOptions(options || {});\n\n  const gethApiDouble = new GethApiDouble(options, this);\n\n  this.engine = new ProviderEngine({\n    blockTracker: new BlockTracker({ blockchain: gethApiDouble.state.blockchain })\n  });\n\n  const subscriptionSubprovider = new SubscriptionSubprovider();\n\n  this.engine.manager = gethApiDouble;\n  this.engine.addProvider(new RequestFunnel());\n  this.engine.addProvider(new DelayedBlockFilter());\n  this.engine.addProvider(subscriptionSubprovider);\n  this.engine.addProvider(new GethDefaults());\n  this.engine.addProvider(gethApiDouble);\n\n  this.engine.setMaxListeners(100);\n  this.engine.start();\n\n  this.manager = gethApiDouble;\n  this.sendAsync = this.send.bind(this);\n  this.send = this.send.bind(this);\n  this.close = this.close.bind(this);\n  this._queueRequest = this._queueRequest.bind(this);\n  this._processRequestQueue = this._processRequestQueue.bind(this);\n\n  subscriptionSubprovider.on(\"data\", function(err, notification) {\n    self.emit(\"data\", err, notification);\n  });\n}\n\nconst defaultOptions = {\n  _chainId: 1,\n  _chainIdRpc: 1337,\n  vmErrorsOnRPCResponse: true,\n  verbose: false,\n  asyncRequestProcessing: false,\n  logger: {\n    log: function() {}\n  }\n};\n\nProvider.prototype = Object.create(EventEmitter.prototype);\nProvider.prototype.constructor = Provider;\n\nProvider.prototype._applyDefaultOptions = function(options) {\n  return _.merge({}, defaultOptions, options);\n};\n\nProvider.prototype.send = function(payload, callback) {\n  if (typeof callback !== \"function\") {\n    throw new Error(\n      \"No callback provided to provider's send function. As of web3 1.0, provider.send \" +\n        \"is no longer synchronous and must be passed a callback as its final argument.\"\n    );\n  }\n\n  const self = this;\n\n  const externalize = function(payload) {\n    return _.cloneDeep(payload);\n  };\n\n  if (Array.isArray(payload)) {\n    payload = payload.map(externalize);\n  } else {\n    payload = externalize(payload);\n  }\n\n  const intermediary = function(err, result) {\n    // clone result so that we can mutate the response without worrying about\n    // that messing up assumptions the calling logic might have about us\n    // mutating things\n    result = _.cloneDeep(result);\n    let response;\n    if (Array.isArray(result)) {\n      response = [];\n      for (let i = 0; i < result.length; i++) {\n        response.push(self.reportErrorInResponse(payload[i], err, result[i]));\n      }\n    } else {\n      response = self.reportErrorInResponse(payload, err, result);\n    }\n\n    if (self.options.verbose) {\n      self.options.logger.log(\n        \" <   \" +\n          JSON.stringify(response, null, 2)\n            .split(\"\\n\")\n            .join(\"\\n <   \")\n      );\n    }\n    process.nextTick(() => callback(response.error ? err : null, response));\n  };\n\n  if (self.options.verbose) {\n    self.options.logger.log(\n      \"   > \" +\n        JSON.stringify(payload, null, 2)\n          .split(\"\\n\")\n          .join(\"\\n   > \")\n    );\n  }\n\n  if (self.options.asyncRequestProcessing) {\n    self.engine.sendAsync(payload, intermediary);\n  } else {\n    self._queueRequest(payload, intermediary);\n  }\n};\n\nProvider.prototype.close = function(callback) {\n  // This is a little gross reaching, but...\n  this.manager.state.stopMining();\n  this.manager.state.blockchain.close(callback);\n  this.engine.stop();\n};\n\nProvider.prototype._queueRequest = function(payload, intermediary) {\n  if (!this._requestQueue) {\n    this._requestQueue = [];\n  }\n\n  this._requestQueue.push({\n    payload: payload,\n    callback: intermediary\n  });\n\n  setImmediate(this._processRequestQueue);\n};\n\nProvider.prototype._processRequestQueue = function() {\n  const self = this;\n\n  if (self._requestInProgress) {\n    return;\n  }\n\n  self._requestInProgress = true;\n\n  const args = self._requestQueue.shift();\n\n  if (args) {\n    self.engine.sendAsync(args.payload, (err, result) => {\n      if (self._requestQueue.length > 0) {\n        setImmediate(self._processRequestQueue);\n      }\n      args.callback(err, result);\n      self._requestInProgress = false;\n    });\n  } else {\n    // still need to free the lock\n    self._requestInProgress = false;\n\n    if (self._requestQueue.length > 0) {\n      setImmediate(self._processRequestQueue);\n    }\n  }\n};\n\nProvider.prototype.cleanUpErrorObject = function(err, response) {\n  // Our response should already have an error field at this point, if it\n  // doesn't, this was likely intentional. If not, this is the wrong place to\n  // fix that problem.\n  if (!err || !response.error) {\n    return response;\n  }\n\n  const errorObject = {\n    error: {\n      data: {}\n    }\n  };\n\n  if (err.message) {\n    // clean up the error reporting done by the provider engine so the error message isn't lost in the stack trace noise\n    errorObject.error.message = err.message;\n    errorObject.error.data.stack = err.stack;\n    errorObject.error.data.name = err.name;\n    if (\"code\" in err) {\n      errorObject.error.code = err.code;\n    }\n  } else if (!response.error) {\n    errorObject.error = {\n      message: err.toString()\n    };\n  }\n\n  return _.merge(response, errorObject);\n};\n\n// helper set of RPC methods which execute code and respond with a transaction hash as their result\nconst transactionMethods = new Set([\"eth_sendTransaction\", \"eth_sendRawTransaction\", \"personal_sendTransaction\"]);\n\nProvider.prototype._isTransactionRequest = function(request) {\n  return transactionMethods.has(request.method);\n};\n\nProvider.prototype.reportErrorInResponse = function(request, err, response) {\n  const self = this;\n\n  if (!err) {\n    return response;\n  }\n\n  // TODO: for next major release: move reporting of tx hash on error to error\n  // field to prevent poorly-written clients which assume that the existence of\n  // the \"result\" field implies no errors from breaking.\n  if (self._isTransactionRequest(request)) {\n    if (err instanceof RuntimeError) {\n      // Make sure we always return the transaction hash on failed transactions so\n      // the caller can get their tx receipt. This breaks JSONRPC 2.0, but it's how\n      // we've always done it.\n      response.result = err.hashes[0];\n\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        delete response.error;\n      }\n    }\n  }\n\n  if (request.method === \"eth_call\") {\n    if (err instanceof RuntimeError) {\n      if (self.options.vmErrorsOnRPCResponse) {\n        if (!response.error.data) {\n          response.error.data = {};\n        }\n        response.error.data[err.hashes[0]] = err.results[err.hashes[0]];\n      } else {\n        response.result = err.results[err.hashes[0]].return || \"0x\";\n        delete response.error;\n      }\n    }\n  }\n\n  return self.cleanUpErrorObject(err, response);\n};\n\nmodule.exports = Provider;\n"],"mappings":"AAAA;AACAA,OAAO,CAAC,6BAAD,CAAP;;AAEA,MAAMC,cAAc,GAAGD,OAAO,CAAC,sBAAD,CAA9B;;AACA,MAAME,uBAAuB,GAAGF,OAAO,CAAC,iDAAD,CAAvC;;AAEA,MAAMG,aAAa,GAAGH,OAAO,CAAC,8BAAD,CAA7B;;AACA,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,mCAAD,CAAlC;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,6BAAD,CAA5B;;AACA,MAAMM,aAAa,GAAGN,OAAO,CAAC,gCAAD,CAA7B;;AAEA,MAAMO,YAAY,GAAGP,OAAO,CAAC,iBAAD,CAA5B;;AAEA,MAAMQ,YAAY,GAAGR,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMS,YAAY,GAAGT,OAAO,CAAC,QAAD,CAA5B;;AAEA,MAAMU,CAAC,GAAGV,OAAO,CAAC,QAAD,CAAjB;;AAEA,SAASW,QAAT,CAAkBC,OAAlB,EAA2B;EACzB,MAAMC,IAAI,GAAG,IAAb;EACAJ,YAAY,CAACK,IAAb,CAAkB,IAAlB;EAEA,KAAKF,OAAL,GAAeA,OAAO,GAAGC,IAAI,CAACE,oBAAL,CAA0BH,OAAO,IAAI,EAArC,CAAzB;EAEA,MAAMI,aAAa,GAAG,IAAIV,aAAJ,CAAkBM,OAAlB,EAA2B,IAA3B,CAAtB;EAEA,KAAKK,MAAL,GAAc,IAAIhB,cAAJ,CAAmB;IAC/BiB,YAAY,EAAE,IAAIX,YAAJ,CAAiB;MAAEY,UAAU,EAAEH,aAAa,CAACI,KAAd,CAAoBD;IAAlC,CAAjB;EADiB,CAAnB,CAAd;EAIA,MAAME,uBAAuB,GAAG,IAAInB,uBAAJ,EAAhC;EAEA,KAAKe,MAAL,CAAYK,OAAZ,GAAsBN,aAAtB;EACA,KAAKC,MAAL,CAAYM,WAAZ,CAAwB,IAAIpB,aAAJ,EAAxB;EACA,KAAKc,MAAL,CAAYM,WAAZ,CAAwB,IAAInB,kBAAJ,EAAxB;EACA,KAAKa,MAAL,CAAYM,WAAZ,CAAwBF,uBAAxB;EACA,KAAKJ,MAAL,CAAYM,WAAZ,CAAwB,IAAIlB,YAAJ,EAAxB;EACA,KAAKY,MAAL,CAAYM,WAAZ,CAAwBP,aAAxB;EAEA,KAAKC,MAAL,CAAYO,eAAZ,CAA4B,GAA5B;EACA,KAAKP,MAAL,CAAYQ,KAAZ;EAEA,KAAKH,OAAL,GAAeN,aAAf;EACA,KAAKU,SAAL,GAAiB,KAAKC,IAAL,CAAUC,IAAV,CAAe,IAAf,CAAjB;EACA,KAAKD,IAAL,GAAY,KAAKA,IAAL,CAAUC,IAAV,CAAe,IAAf,CAAZ;EACA,KAAKC,KAAL,GAAa,KAAKA,KAAL,CAAWD,IAAX,CAAgB,IAAhB,CAAb;EACA,KAAKE,aAAL,GAAqB,KAAKA,aAAL,CAAmBF,IAAnB,CAAwB,IAAxB,CAArB;EACA,KAAKG,oBAAL,GAA4B,KAAKA,oBAAL,CAA0BH,IAA1B,CAA+B,IAA/B,CAA5B;EAEAP,uBAAuB,CAACW,EAAxB,CAA2B,MAA3B,EAAmC,UAASC,GAAT,EAAcC,YAAd,EAA4B;IAC7DrB,IAAI,CAACsB,IAAL,CAAU,MAAV,EAAkBF,GAAlB,EAAuBC,YAAvB;EACD,CAFD;AAGD;;AAED,MAAME,cAAc,GAAG;EACrBC,QAAQ,EAAE,CADW;EAErBC,WAAW,EAAE,IAFQ;EAGrBC,qBAAqB,EAAE,IAHF;EAIrBC,OAAO,EAAE,KAJY;EAKrBC,sBAAsB,EAAE,KALH;EAMrBC,MAAM,EAAE;IACNC,GAAG,EAAE,YAAW,CAAE;EADZ;AANa,CAAvB;AAWAhC,QAAQ,CAACiC,SAAT,GAAqBC,MAAM,CAACC,MAAP,CAAcrC,YAAY,CAACmC,SAA3B,CAArB;AACAjC,QAAQ,CAACiC,SAAT,CAAmBG,WAAnB,GAAiCpC,QAAjC;;AAEAA,QAAQ,CAACiC,SAAT,CAAmB7B,oBAAnB,GAA0C,UAASH,OAAT,EAAkB;EAC1D,OAAOF,CAAC,CAACsC,KAAF,CAAQ,EAAR,EAAYZ,cAAZ,EAA4BxB,OAA5B,CAAP;AACD,CAFD;;AAIAD,QAAQ,CAACiC,SAAT,CAAmBjB,IAAnB,GAA0B,UAASsB,OAAT,EAAkBC,QAAlB,EAA4B;EACpD,IAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;IAClC,MAAM,IAAIC,KAAJ,CACJ,qFACE,+EAFE,CAAN;EAID;;EAED,MAAMtC,IAAI,GAAG,IAAb;;EAEA,MAAMuC,WAAW,GAAG,UAASH,OAAT,EAAkB;IACpC,OAAOvC,CAAC,CAAC2C,SAAF,CAAYJ,OAAZ,CAAP;EACD,CAFD;;EAIA,IAAIK,KAAK,CAACC,OAAN,CAAcN,OAAd,CAAJ,EAA4B;IAC1BA,OAAO,GAAGA,OAAO,CAACO,GAAR,CAAYJ,WAAZ,CAAV;EACD,CAFD,MAEO;IACLH,OAAO,GAAGG,WAAW,CAACH,OAAD,CAArB;EACD;;EAED,MAAMQ,YAAY,GAAG,UAASxB,GAAT,EAAcyB,MAAd,EAAsB;IACzC;IACA;IACA;IACAA,MAAM,GAAGhD,CAAC,CAAC2C,SAAF,CAAYK,MAAZ,CAAT;IACA,IAAIC,QAAJ;;IACA,IAAIL,KAAK,CAACC,OAAN,CAAcG,MAAd,CAAJ,EAA2B;MACzBC,QAAQ,GAAG,EAAX;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;QACtCD,QAAQ,CAACG,IAAT,CAAcjD,IAAI,CAACkD,qBAAL,CAA2Bd,OAAO,CAACW,CAAD,CAAlC,EAAuC3B,GAAvC,EAA4CyB,MAAM,CAACE,CAAD,CAAlD,CAAd;MACD;IACF,CALD,MAKO;MACLD,QAAQ,GAAG9C,IAAI,CAACkD,qBAAL,CAA2Bd,OAA3B,EAAoChB,GAApC,EAAyCyB,MAAzC,CAAX;IACD;;IAED,IAAI7C,IAAI,CAACD,OAAL,CAAa4B,OAAjB,EAA0B;MACxB3B,IAAI,CAACD,OAAL,CAAa8B,MAAb,CAAoBC,GAApB,CACE,UACEqB,IAAI,CAACC,SAAL,CAAeN,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,EACGO,KADH,CACS,IADT,EAEGC,IAFH,CAEQ,SAFR,CAFJ;IAMD;;IACDC,OAAO,CAACC,QAAR,CAAiB,MAAMnB,QAAQ,CAACS,QAAQ,CAACW,KAAT,GAAiBrC,GAAjB,GAAuB,IAAxB,EAA8B0B,QAA9B,CAA/B;EACD,CAxBD;;EA0BA,IAAI9C,IAAI,CAACD,OAAL,CAAa4B,OAAjB,EAA0B;IACxB3B,IAAI,CAACD,OAAL,CAAa8B,MAAb,CAAoBC,GAApB,CACE,UACEqB,IAAI,CAACC,SAAL,CAAehB,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,EACGiB,KADH,CACS,IADT,EAEGC,IAFH,CAEQ,SAFR,CAFJ;EAMD;;EAED,IAAItD,IAAI,CAACD,OAAL,CAAa6B,sBAAjB,EAAyC;IACvC5B,IAAI,CAACI,MAAL,CAAYS,SAAZ,CAAsBuB,OAAtB,EAA+BQ,YAA/B;EACD,CAFD,MAEO;IACL5C,IAAI,CAACiB,aAAL,CAAmBmB,OAAnB,EAA4BQ,YAA5B;EACD;AACF,CA5DD;;AA8DA9C,QAAQ,CAACiC,SAAT,CAAmBf,KAAnB,GAA2B,UAASqB,QAAT,EAAmB;EAC5C;EACA,KAAK5B,OAAL,CAAaF,KAAb,CAAmBmD,UAAnB;EACA,KAAKjD,OAAL,CAAaF,KAAb,CAAmBD,UAAnB,CAA8BU,KAA9B,CAAoCqB,QAApC;EACA,KAAKjC,MAAL,CAAYuD,IAAZ;AACD,CALD;;AAOA7D,QAAQ,CAACiC,SAAT,CAAmBd,aAAnB,GAAmC,UAASmB,OAAT,EAAkBQ,YAAlB,EAAgC;EACjE,IAAI,CAAC,KAAKgB,aAAV,EAAyB;IACvB,KAAKA,aAAL,GAAqB,EAArB;EACD;;EAED,KAAKA,aAAL,CAAmBX,IAAnB,CAAwB;IACtBb,OAAO,EAAEA,OADa;IAEtBC,QAAQ,EAAEO;EAFY,CAAxB;;EAKAiB,YAAY,CAAC,KAAK3C,oBAAN,CAAZ;AACD,CAXD;;AAaApB,QAAQ,CAACiC,SAAT,CAAmBb,oBAAnB,GAA0C,YAAW;EACnD,MAAMlB,IAAI,GAAG,IAAb;;EAEA,IAAIA,IAAI,CAAC8D,kBAAT,EAA6B;IAC3B;EACD;;EAED9D,IAAI,CAAC8D,kBAAL,GAA0B,IAA1B;;EAEA,MAAMC,IAAI,GAAG/D,IAAI,CAAC4D,aAAL,CAAmBI,KAAnB,EAAb;;EAEA,IAAID,IAAJ,EAAU;IACR/D,IAAI,CAACI,MAAL,CAAYS,SAAZ,CAAsBkD,IAAI,CAAC3B,OAA3B,EAAoC,CAAChB,GAAD,EAAMyB,MAAN,KAAiB;MACnD,IAAI7C,IAAI,CAAC4D,aAAL,CAAmBZ,MAAnB,GAA4B,CAAhC,EAAmC;QACjCa,YAAY,CAAC7D,IAAI,CAACkB,oBAAN,CAAZ;MACD;;MACD6C,IAAI,CAAC1B,QAAL,CAAcjB,GAAd,EAAmByB,MAAnB;MACA7C,IAAI,CAAC8D,kBAAL,GAA0B,KAA1B;IACD,CAND;EAOD,CARD,MAQO;IACL;IACA9D,IAAI,CAAC8D,kBAAL,GAA0B,KAA1B;;IAEA,IAAI9D,IAAI,CAAC4D,aAAL,CAAmBZ,MAAnB,GAA4B,CAAhC,EAAmC;MACjCa,YAAY,CAAC7D,IAAI,CAACkB,oBAAN,CAAZ;IACD;EACF;AACF,CA3BD;;AA6BApB,QAAQ,CAACiC,SAAT,CAAmBkC,kBAAnB,GAAwC,UAAS7C,GAAT,EAAc0B,QAAd,EAAwB;EAC9D;EACA;EACA;EACA,IAAI,CAAC1B,GAAD,IAAQ,CAAC0B,QAAQ,CAACW,KAAtB,EAA6B;IAC3B,OAAOX,QAAP;EACD;;EAED,MAAMoB,WAAW,GAAG;IAClBT,KAAK,EAAE;MACLU,IAAI,EAAE;IADD;EADW,CAApB;;EAMA,IAAI/C,GAAG,CAACgD,OAAR,EAAiB;IACf;IACAF,WAAW,CAACT,KAAZ,CAAkBW,OAAlB,GAA4BhD,GAAG,CAACgD,OAAhC;IACAF,WAAW,CAACT,KAAZ,CAAkBU,IAAlB,CAAuBE,KAAvB,GAA+BjD,GAAG,CAACiD,KAAnC;IACAH,WAAW,CAACT,KAAZ,CAAkBU,IAAlB,CAAuBG,IAAvB,GAA8BlD,GAAG,CAACkD,IAAlC;;IACA,IAAI,UAAUlD,GAAd,EAAmB;MACjB8C,WAAW,CAACT,KAAZ,CAAkBc,IAAlB,GAAyBnD,GAAG,CAACmD,IAA7B;IACD;EACF,CARD,MAQO,IAAI,CAACzB,QAAQ,CAACW,KAAd,EAAqB;IAC1BS,WAAW,CAACT,KAAZ,GAAoB;MAClBW,OAAO,EAAEhD,GAAG,CAACoD,QAAJ;IADS,CAApB;EAGD;;EAED,OAAO3E,CAAC,CAACsC,KAAF,CAAQW,QAAR,EAAkBoB,WAAlB,CAAP;AACD,CA7BD,C,CA+BA;;;AACA,MAAMO,kBAAkB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,qBAAD,EAAwB,wBAAxB,EAAkD,0BAAlD,CAAR,CAA3B;;AAEA5E,QAAQ,CAACiC,SAAT,CAAmB4C,qBAAnB,GAA2C,UAASC,OAAT,EAAkB;EAC3D,OAAOH,kBAAkB,CAACI,GAAnB,CAAuBD,OAAO,CAACE,MAA/B,CAAP;AACD,CAFD;;AAIAhF,QAAQ,CAACiC,SAAT,CAAmBmB,qBAAnB,GAA2C,UAAS0B,OAAT,EAAkBxD,GAAlB,EAAuB0B,QAAvB,EAAiC;EAC1E,MAAM9C,IAAI,GAAG,IAAb;;EAEA,IAAI,CAACoB,GAAL,EAAU;IACR,OAAO0B,QAAP;EACD,CALyE,CAO1E;EACA;EACA;;;EACA,IAAI9C,IAAI,CAAC2E,qBAAL,CAA2BC,OAA3B,CAAJ,EAAyC;IACvC,IAAIxD,GAAG,YAAYzB,YAAnB,EAAiC;MAC/B;MACA;MACA;MACAmD,QAAQ,CAACD,MAAT,GAAkBzB,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAAlB;;MAEA,IAAI/E,IAAI,CAACD,OAAL,CAAa2B,qBAAjB,EAAwC;QACtC,IAAI,CAACoB,QAAQ,CAACW,KAAT,CAAeU,IAApB,EAA0B;UACxBrB,QAAQ,CAACW,KAAT,CAAeU,IAAf,GAAsB,EAAtB;QACD;;QACDrB,QAAQ,CAACW,KAAT,CAAeU,IAAf,CAAoB/C,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAApB,IAAqC3D,GAAG,CAAC4D,OAAJ,CAAY5D,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAAZ,CAArC;MACD,CALD,MAKO;QACL,OAAOjC,QAAQ,CAACW,KAAhB;MACD;IACF;EACF;;EAED,IAAImB,OAAO,CAACE,MAAR,KAAmB,UAAvB,EAAmC;IACjC,IAAI1D,GAAG,YAAYzB,YAAnB,EAAiC;MAC/B,IAAIK,IAAI,CAACD,OAAL,CAAa2B,qBAAjB,EAAwC;QACtC,IAAI,CAACoB,QAAQ,CAACW,KAAT,CAAeU,IAApB,EAA0B;UACxBrB,QAAQ,CAACW,KAAT,CAAeU,IAAf,GAAsB,EAAtB;QACD;;QACDrB,QAAQ,CAACW,KAAT,CAAeU,IAAf,CAAoB/C,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAApB,IAAqC3D,GAAG,CAAC4D,OAAJ,CAAY5D,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAAZ,CAArC;MACD,CALD,MAKO;QACLjC,QAAQ,CAACD,MAAT,GAAkBzB,GAAG,CAAC4D,OAAJ,CAAY5D,GAAG,CAAC2D,MAAJ,CAAW,CAAX,CAAZ,EAA2BE,MAA3B,IAAqC,IAAvD;QACA,OAAOnC,QAAQ,CAACW,KAAhB;MACD;IACF;EACF;;EAED,OAAOzD,IAAI,CAACiE,kBAAL,CAAwB7C,GAAxB,EAA6B0B,QAA7B,CAAP;AACD,CA3CD;;AA6CAoC,MAAM,CAACC,OAAP,GAAiBrF,QAAjB"},"metadata":{},"sourceType":"script"}
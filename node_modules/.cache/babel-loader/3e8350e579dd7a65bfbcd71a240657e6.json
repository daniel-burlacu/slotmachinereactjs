{"ast":null,"code":"import { jsx as e } from \"react/jsx-runtime\";\nimport { createContext as t, useContext as n, useRef as i, useState as r } from \"react\";\nimport { config as s, useTransition as o, animated as a } from \"react-spring\";\nimport { useDrag as l } from \"@use-gesture/react\";\nimport { a as d, b as c, c as u } from \"./useThumbsModule-0944decf.js\";\nimport \"rxjs\";\nimport \"screenfull\";\nconst m = t(void 0);\n\nfunction g() {\n  const e = n(m);\n  if (!e) throw new Error(\"useTransitionCarouselContext isn't being used within the useTransitionCarousel context; \\n    use the context only inside a component that is rendered within the Carousel.\");\n  return e;\n}\n\nfunction h(_ref) {\n  let {\n    items: t,\n    withLoop: n = !1,\n    withThumbs: g = !1,\n    springConfig: h = s.default,\n    thumbsSlideAxis: p = \"x\",\n    enableThumbsWrapperScroll: f = !0,\n    draggingSlideTreshold: b = 50,\n    prepareThumbsData: x,\n    toPrevItemSpringProps: v,\n    toNextItemSpringProps: I,\n    disableGestures: T = !1,\n    trail: S,\n    exitBeforeEnter: j = !1,\n    springAnimationProps: O = {\n      initial: {\n        opacity: 1,\n        position: \"absolute\"\n      },\n      from: {\n        opacity: 0,\n        position: \"absolute\"\n      },\n      enter: {\n        opacity: 1,\n        position: \"absolute\"\n      },\n      leave: {\n        opacity: 0,\n        position: \"absolute\"\n      }\n    }\n  } = _ref;\n  const y = i(\"next\"),\n        C = i(null),\n        w = i(!1),\n        [A, N] = r(0),\n        {\n    emitObservable: F,\n    useListenToCustomEvent: P\n  } = d(),\n        {\n    enterFullscreen: E,\n    exitFullscreen: L,\n    getIsFullscreen: R\n  } = c({\n    emitObservable: F,\n    mainCarouselWrapperRef: C\n  }),\n        {\n    thumbsFragment: B,\n    handleThumbsScroll: D\n  } = u({\n    items: t,\n    withThumbs: g,\n    thumbsSlideAxis: p,\n    springConfig: h,\n    prepareThumbsData: x,\n    slideType: \"fixed\"\n  }),\n        W = l(_ref2 => {\n    let {\n      last: e,\n      movement: [i]\n    } = _ref2;\n\n    if (!G() && e) {\n      const e = i > b,\n            r = i < -b,\n            s = 0 === A,\n            o = A === t.length - 1;\n\n      if (r) {\n        if (!n && o) return;\n        H(), F({\n          eventName: \"onLeftSwipe\"\n        });\n      } else if (e) {\n        if (!n && s) return;\n        J(), F({\n          eventName: \"onRightSwipe\"\n        });\n      }\n    }\n  }, {\n    enabled: !T\n  });\n  const k = o(A, Object.assign(Object.assign({\n    config: h\n  }, function () {\n    const e = z();\n    return \"prev\" === e && v ? {\n      initial: Object.assign({}, O.initial),\n      from: Object.assign({}, v.from),\n      enter: Object.assign({}, v.enter),\n      leave: Object.assign({}, v.leave)\n    } : \"next\" === e && I ? {\n      initial: Object.assign({}, O.initial),\n      from: Object.assign({}, I.from),\n      enter: Object.assign({}, I.enter),\n      leave: Object.assign({}, I.leave)\n    } : {\n      initial: Object.assign({}, O.initial),\n      from: Object.assign({}, O.from),\n      enter: Object.assign({}, O.enter),\n      leave: Object.assign({}, O.leave)\n    };\n  }()), {\n    onStart: () => M(!0),\n    trail: S,\n    exitBeforeEnter: j,\n    key: t[A].id,\n    onRest: e => {\n      e.finished && (M(!1), F({\n        eventName: \"onSlideChange\",\n        slideActionType: z(),\n        currentItem: {\n          index: A,\n          id: t[A].id\n        }\n      }));\n    }\n  }))((n, i) => e(a.div, Object.assign({\n    style: Object.assign(Object.assign({}, n), {\n      flex: \"1 0 100%\",\n      width: \"100%\",\n      height: \"100%\"\n    })\n  }, {\n    children: t[i].renderItem\n  })));\n\n  function G() {\n    return w.current;\n  }\n\n  function M(e) {\n    w.current = e;\n  }\n\n  function q(e) {\n    y.current = e;\n  }\n\n  function z() {\n    return y.current;\n  }\n\n  function H() {\n    const e = A === t.length - 1;\n    n ? (q(\"next\"), e ? (F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: 0,\n        id: t[0].id\n      }\n    }), N(0)) : (F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: A + 1,\n        id: t[A + 1].id\n      }\n    }), N(A + 1))) : e || (F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: A + 1,\n        id: t[A + 1].id\n      }\n    }), q(\"next\"), N(A + 1));\n  }\n\n  function J() {\n    const e = 0 === A;\n    n ? (q(\"prev\"), e ? (F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: t.length - 1,\n        id: t[t.length - 1].id\n      }\n    }), N(t.length - 1)) : (F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: A - 1,\n        id: t[A - 1].id\n      }\n    }), N(A - 1))) : e || (q(\"prev\"), F({\n      eventName: \"onSlideStartChange\",\n      slideActionType: z(),\n      nextItem: {\n        index: A - 1,\n        id: t[A - 1].id\n      }\n    }), N(A - 1));\n  }\n\n  function K(e) {\n    return t.findIndex(t => t.id === e);\n  }\n\n  const Q = {\n    activeItem: A,\n    slideToItem: function (e) {\n      let n = 0;\n      if (n = \"string\" == typeof e ? t.findIndex(t => t.id === e) : e, n >= t.length) throw Error(\"The item you want to slide to doesn't exist. This could be due to the fact that \\n        you provide a wrong id or a higher numeric index.\");\n      if (n === A) return;\n      const i = K(t[A].id),\n            r = K(t[n].id);\n      F({\n        eventName: \"onSlideStartChange\",\n        slideActionType: z(),\n        nextItem: {\n          index: r,\n          id: t[n].id\n        }\n      }), q(r > i ? \"next\" : \"prev\"), N(n), f && g && D(n);\n    },\n    slideToNextItem: H,\n    slideToPrevItem: J,\n    enterFullscreen: E,\n    exitFullscreen: L,\n    useListenToCustomEvent: P,\n    getIsNextItem: function (e) {\n      const i = K(e);\n      return n && A === t.length - 1 ? 0 === i : i === A + 1;\n    },\n    getIsPrevItem: function (e) {\n      const i = K(e);\n      return n && 0 === A ? i === t.length - 1 : i === A - 1;\n    },\n    getIsAnimating: G,\n    getIsFullscreen: R,\n    getIsActiveItem: e => K(e) === A,\n    getCurrentActiveItem: () => ({\n      id: t[A].id,\n      index: A\n    })\n  },\n        U = e(m.Provider, Object.assign({\n    value: Q\n  }, {\n    children: e(\"div\", Object.assign({\n      ref: C\n    }, W(), {\n      style: {\n        display: \"flex\",\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n        overflow: \"hidden\"\n      }\n    }, {\n      children: k\n    }))\n  })),\n        V = e(m.Provider, Object.assign({\n    value: Q\n  }, {\n    children: B\n  }));\n  return Object.assign({\n    carouselFragment: U,\n    thumbsFragment: V\n  }, Q);\n}\n\nexport { h as useTransitionCarousel, g as useTransitionCarouselContext };","map":{"version":3,"mappings":"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","names":["UseTransitionCarouselContext","createContext","undefined","useTransitionCarouselContext","context","useContext","Error","useTransitionCarousel","items","withLoop","withThumbs","springConfig","config","default","thumbsSlideAxis","enableThumbsWrapperScroll","draggingSlideTreshold","prepareThumbsData","toPrevItemSpringProps","toNextItemSpringProps","disableGestures","trail","exitBeforeEnter","springAnimationProps","initial","opacity","position","from","enter","leave","slideActionType","useRef","mainCarouselWrapperRef","isAnimating","activeItem","setActiveItem","useState","emitObservable","useListenToCustomEvent","useCustomEventsModule","enterFullscreen","exitFullscreen","getIsFullscreen","useFullscreenModule","thumbsFragment","_thumbsFragment","handleThumbsScroll","useThumbsModule","slideType","bindSwipe","useDrag","mx","last","movement","getIsAnimating","prevItemTreshold","nextItemTreshold","isFirstItem","isLastItem","length","slideToNextItem","eventName","slideToPrevItem","enabled","itemsFragment","useTransition","getSlideActionType","getTransitionConfig","onStart","setIsAnimating","key","id","onRest","val","finished","currentItem","index","styles","item","_jsx","animated","div","style","flex","width","height","children","renderItem","current","setSlideActionType","type","nextItem","findItemIndex","findIndex","contextProps","slideToItem","itemIndex","_item","newActiveItem","getIsNextItem","getIsPrevItem","getIsActiveItem","getCurrentActiveItem","carouselFragment","Provider","value","ref","display","overflow"],"sources":["F:\\Games\\PFPRacerNFTProject\\slotmachinereact\\node_modules\\react-spring-carousel\\src\\useTransitionCarousel\\index.tsx"],"sourcesContent":["import { createContext, useRef, useState, useContext } from 'react'\nimport { useTransition, animated, config } from 'react-spring'\nimport { useDrag } from '@use-gesture/react'\nimport { useCustomEventsModule, useThumbsModule, useFullscreenModule } from '../modules'\nimport { SlideActionType } from '../types'\nimport {\n  UseTransitionCarouselContextProps,\n  UseTransitionCarouselProps,\n} from '../types/useTransitionCarousel'\nimport { ReactSpringCarouselItemWithThumbs } from '../types/useSpringCarousel'\n\nconst UseTransitionCarouselContext = createContext<\n  UseTransitionCarouselContextProps | undefined\n>(undefined)\n\nfunction useTransitionCarouselContext() {\n  const context = useContext(UseTransitionCarouselContext)\n\n  if (!context) {\n    throw new Error(`useTransitionCarouselContext isn't being used within the useTransitionCarousel context; \n    use the context only inside a component that is rendered within the Carousel.`)\n  }\n\n  return context\n}\n\nfunction useTransitionCarousel({\n  items,\n  withLoop = false,\n  withThumbs = false,\n  springConfig = config.default,\n  thumbsSlideAxis = 'x',\n  enableThumbsWrapperScroll = true,\n  draggingSlideTreshold = 50,\n  prepareThumbsData,\n  toPrevItemSpringProps,\n  toNextItemSpringProps,\n  disableGestures = false,\n  trail,\n  exitBeforeEnter = false,\n  springAnimationProps = {\n    initial: {\n      opacity: 1,\n      position: 'absolute',\n    },\n    from: {\n      opacity: 0,\n      position: 'absolute',\n    },\n    enter: {\n      opacity: 1,\n      position: 'absolute',\n    },\n    leave: {\n      opacity: 0,\n      position: 'absolute',\n    },\n  },\n}: UseTransitionCarouselProps) {\n  const slideActionType = useRef<SlideActionType>('next')\n  const mainCarouselWrapperRef = useRef<HTMLDivElement | null>(null)\n  const isAnimating = useRef(false)\n  const [activeItem, setActiveItem] = useState(0)\n\n  const { emitObservable, useListenToCustomEvent } =\n    useCustomEventsModule<'use-transition'>()\n  const { enterFullscreen, exitFullscreen, getIsFullscreen } = useFullscreenModule({\n    emitObservable,\n    mainCarouselWrapperRef,\n  })\n  const { thumbsFragment: _thumbsFragment, handleThumbsScroll } = useThumbsModule({\n    items: items as ReactSpringCarouselItemWithThumbs[],\n    withThumbs,\n    thumbsSlideAxis,\n    springConfig,\n    prepareThumbsData,\n    slideType: 'fixed',\n  })\n\n  const bindSwipe = useDrag(\n    ({ last, movement: [mx] }) => {\n      if (getIsAnimating()) {\n        return\n      }\n\n      if (last) {\n        const prevItemTreshold = mx > draggingSlideTreshold\n        const nextItemTreshold = mx < -draggingSlideTreshold\n        const isFirstItem = activeItem === 0\n        const isLastItem = activeItem === items.length - 1\n\n        if (nextItemTreshold) {\n          if (!withLoop && isLastItem) {\n            return\n          }\n\n          slideToNextItem()\n          emitObservable({\n            eventName: 'onLeftSwipe',\n          })\n        } else if (prevItemTreshold) {\n          if (!withLoop && isFirstItem) {\n            return\n          }\n\n          slideToPrevItem()\n          emitObservable({\n            eventName: 'onRightSwipe',\n          })\n        }\n      }\n    },\n    {\n      enabled: !disableGestures,\n    },\n  )\n\n  function getTransitionConfig() {\n    const slideActionType = getSlideActionType()\n\n    if (slideActionType === 'prev' && toPrevItemSpringProps) {\n      return {\n        initial: {\n          ...springAnimationProps.initial,\n        },\n        from: {\n          ...toPrevItemSpringProps.from,\n        },\n        enter: {\n          ...toPrevItemSpringProps.enter,\n        },\n        leave: {\n          ...toPrevItemSpringProps.leave,\n        },\n      }\n    }\n\n    if (slideActionType === 'next' && toNextItemSpringProps) {\n      return {\n        initial: {\n          ...springAnimationProps.initial,\n        },\n        from: {\n          ...toNextItemSpringProps.from,\n        },\n        enter: {\n          ...toNextItemSpringProps.enter,\n        },\n        leave: {\n          ...toNextItemSpringProps.leave,\n        },\n      }\n    }\n\n    return {\n      initial: {\n        ...springAnimationProps.initial,\n      },\n      from: {\n        ...springAnimationProps.from,\n      },\n      enter: {\n        ...springAnimationProps.enter,\n      },\n      leave: {\n        ...springAnimationProps.leave,\n      },\n    }\n  }\n\n  const transitions = useTransition(activeItem, {\n    config: springConfig,\n    ...getTransitionConfig(),\n    onStart: () => setIsAnimating(true),\n    trail,\n    exitBeforeEnter,\n    key: items[activeItem].id,\n    onRest: val => {\n      if (val.finished) {\n        setIsAnimating(false)\n        emitObservable({\n          eventName: 'onSlideChange',\n          slideActionType: getSlideActionType(),\n          currentItem: {\n            index: activeItem,\n            id: items[activeItem].id,\n          },\n        })\n      }\n    },\n  })\n  const itemsFragment = transitions((styles, item) => (\n    <animated.div\n      style={{\n        ...styles,\n        flex: '1 0 100%',\n        width: '100%',\n        height: '100%',\n      }}\n    >\n      {items[item].renderItem}\n    </animated.div>\n  ))\n\n  function getIsAnimating() {\n    return isAnimating.current\n  }\n  function setIsAnimating(val: boolean) {\n    isAnimating.current = val\n  }\n  function setSlideActionType(type: SlideActionType) {\n    slideActionType.current = type\n  }\n  function getSlideActionType() {\n    return slideActionType.current\n  }\n  function slideToItem(item: string | number) {\n    let itemIndex = 0\n\n    if (typeof item === 'string') {\n      itemIndex = items.findIndex(_item => _item.id === item)\n    } else {\n      itemIndex = item\n    }\n\n    if (itemIndex >= items.length) {\n      throw Error(\n        `The item you want to slide to doesn't exist. This could be due to the fact that \n        you provide a wrong id or a higher numeric index.`,\n      )\n    }\n\n    if (itemIndex === activeItem) {\n      return\n    }\n\n    const currentItem = findItemIndex(items[activeItem].id)\n    const newActiveItem = findItemIndex(items[itemIndex].id)\n\n    emitObservable({\n      eventName: 'onSlideStartChange',\n      slideActionType: getSlideActionType(),\n      nextItem: {\n        index: newActiveItem,\n        id: items[itemIndex].id,\n      },\n    })\n\n    if (newActiveItem > currentItem) {\n      setSlideActionType('next')\n    } else {\n      setSlideActionType('prev')\n    }\n\n    setActiveItem(itemIndex)\n\n    if (enableThumbsWrapperScroll && withThumbs) {\n      handleThumbsScroll(itemIndex)\n    }\n  }\n  function slideToNextItem() {\n    const isLastItem = activeItem === items.length - 1\n\n    if (withLoop) {\n      setSlideActionType('next')\n      if (isLastItem) {\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: 0,\n            id: items[0].id,\n          },\n        })\n        setActiveItem(0)\n      } else {\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: activeItem + 1,\n            id: items[activeItem + 1].id,\n          },\n        })\n        setActiveItem(activeItem + 1)\n      }\n    } else {\n      if (!isLastItem) {\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: activeItem + 1,\n            id: items[activeItem + 1].id,\n          },\n        })\n        setSlideActionType('next')\n        setActiveItem(activeItem + 1)\n      }\n    }\n  }\n  function slideToPrevItem() {\n    const isFirstItem = activeItem === 0\n\n    if (withLoop) {\n      setSlideActionType('prev')\n      if (isFirstItem) {\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: items.length - 1,\n            id: items[items.length - 1].id,\n          },\n        })\n\n        setActiveItem(items.length - 1)\n      } else {\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: activeItem - 1,\n            id: items[activeItem - 1].id,\n          },\n        })\n        setActiveItem(activeItem - 1)\n      }\n    } else {\n      if (!isFirstItem) {\n        setSlideActionType('prev')\n        emitObservable({\n          eventName: 'onSlideStartChange',\n          slideActionType: getSlideActionType(),\n          nextItem: {\n            index: activeItem - 1,\n            id: items[activeItem - 1].id,\n          },\n        })\n        setActiveItem(activeItem - 1)\n      }\n    }\n  }\n  function findItemIndex(id: string) {\n    return items.findIndex(item => item.id === id)\n  }\n  function getIsNextItem(id: string) {\n    const itemIndex = findItemIndex(id)\n\n    if (withLoop && activeItem === items.length - 1) {\n      return itemIndex === 0\n    }\n\n    return itemIndex === activeItem + 1\n  }\n  function getIsPrevItem(id: string) {\n    const itemIndex = findItemIndex(id)\n\n    if (withLoop && activeItem === 0) {\n      return itemIndex === items.length - 1\n    }\n\n    return itemIndex === activeItem - 1\n  }\n\n  const contextProps: UseTransitionCarouselContextProps = {\n    activeItem,\n    slideToItem,\n    slideToNextItem,\n    slideToPrevItem,\n    enterFullscreen,\n    exitFullscreen,\n    useListenToCustomEvent,\n    getIsNextItem,\n    getIsPrevItem,\n    getIsAnimating,\n    getIsFullscreen,\n    getIsActiveItem: id => {\n      return findItemIndex(id) === activeItem\n    },\n    getCurrentActiveItem: () => ({\n      id: items[activeItem].id,\n      index: activeItem,\n    }),\n  }\n\n  const carouselFragment = (\n    <UseTransitionCarouselContext.Provider value={contextProps}>\n      <div\n        ref={mainCarouselWrapperRef}\n        {...bindSwipe()}\n        style={{\n          display: 'flex',\n          position: 'relative',\n          width: '100%',\n          height: '100%',\n          overflow: 'hidden',\n        }}\n      >\n        {itemsFragment}\n      </div>\n    </UseTransitionCarouselContext.Provider>\n  )\n\n  const thumbsFragment = (\n    <UseTransitionCarouselContext.Provider value={contextProps}>\n      {_thumbsFragment}\n    </UseTransitionCarouselContext.Provider>\n  )\n\n  return {\n    carouselFragment,\n    thumbsFragment,\n    ...contextProps,\n  }\n}\n\nexport { useTransitionCarouselContext, useTransitionCarousel }\n"]},"metadata":{},"sourceType":"module"}
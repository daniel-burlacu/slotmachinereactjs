{"ast":null,"code":"var to = require(\"./utils/to.js\");\n\nvar Account = require(\"ethereumjs-account\").default;\n\nvar Block = require(\"ethereumjs-block\");\n\nvar Log = require(\"./utils/log\");\n\nvar Receipt = require(\"./utils/receipt\");\n\nvar VM = require(\"ethereumjs-vm\").default;\n\nvar Common = require(\"ethereumjs-common\").default;\n\nvar RuntimeError = require(\"./utils/runtimeerror\");\n\nvar Trie = require(\"merkle-patricia-tree\");\n\nvar utils = require(\"ethereumjs-util\");\n\nvar async = require(\"async\");\n\nvar Heap = require(\"heap\");\n\nvar Database = require(\"./database\");\n\nvar EventEmitter = require(\"events\");\n\nvar estimateGas = require(\"./utils/gas/estimateGas\");\n\nvar _ = require(\"lodash\");\n\nvar promisify = require(\"util\").promisify;\n\nconst BN = utils.BN;\n\nfunction BlockchainDouble(options) {\n  var self = this;\n  EventEmitter.apply(self);\n  this.options = options = this._applyDefaultOptions(options || {});\n  this.logger = options.logger || console;\n  this.data = new Database(options);\n\n  if (options.trie != null && options.db_path != null) {\n    throw new Error(\"Can't initialize a TestRPC with a db and a custom trie.\");\n  }\n\n  this.pending_transactions = []; // updated periodically to keep up with the times\n\n  this.blockGasLimit = options.gasLimit;\n  this.defaultTransactionGasLimit = options.defaultTransactionGasLimit;\n  this.timeAdjustment = 0;\n}\n\nconst defaultOptions = {\n  gasLimit: \"0x6691b7\",\n  defaultTransactionGasLimit: \"0x15f90\",\n  time: null,\n  debug: false,\n  hardfork: \"muirGlacier\",\n  allowUnlimitedContractSize: false\n}; // inheritence w/ prototype chaining\n\nBlockchainDouble.prototype = Object.create(EventEmitter.prototype);\nBlockchainDouble.prototype.constructor = BlockchainDouble;\n\nBlockchainDouble.prototype._applyDefaultOptions = function (options) {\n  // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nBlockchainDouble.prototype.initialize = function (accounts, callback) {\n  var self = this;\n  this.data.initialize(function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.latestBlock(function (err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      var options = self.options;\n      var root = null;\n\n      if (block) {\n        root = block.header.stateRoot;\n      } // I haven't yet found a good way to do this. Getting the trie from the\n      // forked blockchain without going through the other setup is a little gross.\n\n\n      self.stateTrie = self.createStateTrie(self.data.trie_db, root);\n      self.vm = options.vm || self.createVMFromStateTrie(self.stateTrie, true);\n\n      if (options.time) {\n        self.setTime(options.time);\n      } // If we already have a block, then that means there's an existing chain.\n      // Don't create a genesis block.\n\n\n      if (block) {\n        self.emit(\"block\", block);\n        return callback();\n      }\n\n      self.createGenesisBlock(function (err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        accounts = accounts || [];\n        self.vm.stateManager.checkpoint(() => {\n          async.eachSeries(accounts, function (accountData, finished) {\n            self.vm.stateManager.putAccount(utils.toBuffer(accountData.address), accountData.account, finished);\n          }, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            self.vm.stateManager.commit(() => {\n              // Create first block\n              self.putBlock(block, [], [], callback);\n            });\n          });\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.createVMFromStateTrie = function (state, activatePrecompiles) {\n  const self = this;\n  const common = Common.forCustomChain(\"mainnet\", // TODO needs to match chain id\n  {\n    name: \"ganache\",\n    networkId: self.options.network_id || self.forkVersion,\n    chainId: self.options._chainId,\n    comment: \"Local test network\",\n    bootstrapNodes: []\n  }, self.options.hardfork);\n  const vm = new VM({\n    state: state,\n    common,\n    blockchain: {\n      // EthereumJS VM needs a blockchain object in order to get block information.\n      // When calling getBlock() it will pass a number that's of a Buffer type.\n      // Unfortunately, it uses a 64-character buffer (when converted to hex) to\n      // represent block numbers as well as block hashes. Since it's very unlikely\n      // any block number will get higher than the maximum safe Javascript integer,\n      // we can convert this buffer to a number ahead of time before calling our\n      // own getBlock(). If the conversion succeeds, we have a block number.\n      // If it doesn't, we have a block hash. (Note: Our implementation accepts both.)\n      getBlock: function (number, done) {\n        try {\n          number = to.number(number);\n        } catch (e) {// Do nothing; must be a block hash.\n        }\n\n        self.getBlock(number, done);\n      }\n    },\n    activatePrecompiles: activatePrecompiles || false,\n    allowUnlimitedContractSize: self.options.allowUnlimitedContractSize\n  });\n\n  if (self.options.debug === true) {\n    // log executed opcodes, including args as hex\n    vm.on(\"step\", function (info) {\n      var name = info.opcode.name;\n      var argsNum = info.opcode.in;\n\n      if (argsNum) {\n        var args = info.stack.slice(-argsNum).map(arg => to.hex(arg)).join(\" \");\n        self.logger.log(`${name} ${args}`);\n      } else {\n        self.logger.log(name);\n      }\n    });\n  }\n\n  return vm;\n};\n\nBlockchainDouble.prototype.createStateTrie = function (db, root) {\n  return new Trie(db, root);\n}; // Overrideable so other implementations (forking) can edit it.\n\n\nBlockchainDouble.prototype.createGenesisBlock = function (callback) {\n  this.createBlock(callback);\n};\n\nBlockchainDouble.prototype.latestBlock = function (callback) {\n  this.data.blocks.last(function (err, last) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, last);\n  });\n}; // number accepts number (integer, hex) or tag (e.g., \"latest\")\n\n\nBlockchainDouble.prototype.getEffectiveBlockNumber = function (number, callback) {\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  } // If we have a hex number\n\n\n  if (number.indexOf(\"0x\") >= 0) {\n    return callback(null, to.number(number));\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.getHeight(callback);\n    } else if (number === \"earliest\") {\n      return callback(null, 0);\n    }\n  }\n}; // number accepts number (integer, hex), tag (e.g., \"latest\") or block hash\n// This function is used by ethereumjs-vm\n\n\nBlockchainDouble.prototype.getBlock = function (number, callback) {\n  var self = this;\n\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  } // If we have a hex number or a block hash\n\n\n  if (number.indexOf(\"0x\") >= 0) {\n    var hash = number; // block hash\n\n    if (hash.length > 40) {\n      this.data.blockHashes.get(to.hex(hash), function (err, blockIndex) {\n        if (err) {\n          return callback(err);\n        }\n\n        return self.data.blocks.get(blockIndex, callback);\n      });\n    } else {\n      // Block number\n      return this.data.blocks.get(to.number(hash), callback);\n    }\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.latestBlock(callback);\n    } else if (number === \"earliest\") {\n      return this.data.blocks.first(callback);\n    } else {\n      process.nextTick(callback, new Error(\"Invalid `blockNumber`: \\\"\" + number + \"\\\"\"));\n    }\n  }\n};\n\nBlockchainDouble.prototype.putBlock = function (block, logs, receipts, callback) {\n  var self = this; // Lock in the state root for this block.\n\n  block.header.stateRoot = this.stateTrie.root;\n  this.data.blocks.length(function (err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    var requests = [self.data.blocks.push.bind(self.data.blocks, block), self.data.blockLogs.push.bind(self.data.blockLogs, logs), self.data.blockHashes.set.bind(self.data.blockHashes, to.hex(block.hash()), length)];\n    block.transactions.forEach(function (tx, index) {\n      var txHash = to.hex(tx.hash());\n      requests.push(self.data.transactions.set.bind(self.data.transactions, txHash, tx), self.data.transactionReceipts.set.bind(self.data.transactionReceipts, txHash, receipts[index]));\n    });\n    async.parallel(requests, (err, result) => {\n      if (!err) {\n        self.emit(\"block\", block);\n      }\n\n      callback(err, result);\n    });\n  });\n};\n\nBlockchainDouble.prototype.popBlock = function (callback) {\n  var self = this;\n  this.data.blocks.last(function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (block == null) {\n      return callback(null, null);\n    }\n\n    var requests = [];\n    var blockHash = to.hex(block.hash());\n    block.transactions.forEach(function (tx) {\n      var txHash = to.hex(tx.hash());\n      requests.push(self.data.transactions.del.bind(self.data.transactions, txHash), self.data.transactionReceipts.del.bind(self.data.transactionReceipts, txHash));\n    });\n    requests.push(self.data.blockLogs.pop.bind(self.data.blockLogs), self.data.blockHashes.del.bind(self.data.blockHashes, blockHash), self.data.blocks.pop.bind(self.data.blocks) // Do this one last in case anything relies on it.\n    );\n    async.series(requests, function (err) {\n      if (err) {\n        return callback(err);\n      } // Set the root to the last available, which will \"roll back\" to the previous\n      // moment in time. Note that all the old data is still in the db, but it's now just junk data.\n\n\n      self.data.blocks.last(function (err, newLastBlock) {\n        if (err) {\n          return callback(err);\n        } // using setStateRoot because in the future it will automatically take care\n        // of clearing the cache for us.\n        // note setStateRoot checks for checkpoints, and if there are any, it will fail.\n        // At time of writing this comment, the only time there could be a checkpoint\n        // is in the middle of a vm.runBlock call. Once asyncRequestProcessing is reenabled\n        // this will likely cause problems.\n\n\n        self.vm.stateManager.setStateRoot(newLastBlock.header.stateRoot, function (err) {\n          // Remember: Return block we popped off.\n          callback(err, block);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.clearPendingTransactions = function () {\n  this.pending_transactions = [];\n};\n/**\n * createBlock\n *\n * Create a new block, where the parent's block is either the latest block\n * on the chain or the parent block passed in.\n *\n * @param  {Block}   parent   The block meant to be the parent block (optional)\n * @param  {Function} callback Callback function called after block is created\n * @return Block              The block created.\n */\n\n\nBlockchainDouble.prototype.createBlock = function (parent, emulateParent, callback) {\n  var self = this;\n\n  if (typeof parent === \"function\") {\n    callback = parent;\n    parent = null;\n    emulateParent = false;\n  } else if (typeof emulateParent === \"function\") {\n    callback = emulateParent;\n    emulateParent = false;\n  }\n\n  var block = new Block();\n\n  function getParent(callback) {\n    if (parent) {\n      return callback(null, parent);\n    } else {\n      self.latestBlock(callback);\n    }\n  }\n\n  getParent(function (err, parent) {\n    if (err) {\n      return callback(err);\n    }\n\n    block.header.gasLimit = self.blockGasLimit;\n\n    if (parent != null && emulateParent) {\n      block.header.number = parent.header.number;\n      block.header.timestamp = parent.header.timestamp;\n      block.header.parentHash = parent.header.parentHash;\n    } else {\n      var parentNumber = parent != null ? to.number(parent.header.number) : -1; // Ensure we have the right block number for the VM.\n\n      block.header.number = to.hex(parentNumber + 1); // Set the timestamp before processing txs\n\n      block.header.timestamp = to.hex(self.currentTime());\n\n      if (parent != null) {\n        block.header.parentHash = to.hex(parent.hash());\n      }\n    }\n\n    callback(null, block);\n  });\n};\n\nBlockchainDouble.prototype.getQueuedNonce = function (address, callback) {\n  var nonce = null;\n  var addressBuffer = to.buffer(address);\n  this.pending_transactions.forEach(function (tx) {\n    if (!tx.from.equals(addressBuffer)) {\n      return;\n    }\n\n    var pendingNonce = new BN(tx.nonce); // If this is the first queued nonce for this address we found,\n    // or it's higher than the previous highest, note it.\n\n    if (nonce === null || pendingNonce.gt(nonce)) {\n      nonce = pendingNonce;\n    }\n  }); // If we found a queued transaction nonce, return one higher\n  // than the highest we found\n\n  if (nonce != null) {\n    return callback(null, nonce.iaddn(1).toArrayLike(Buffer));\n  }\n\n  this.stateTrie.get(addressBuffer, function (err, val) {\n    if (err) {\n      return callback(err);\n    }\n\n    var account = new Account(val); // nonces are initiallized as an empty buffer, which isn't what we want.\n\n    callback(null, account.nonce.length === 0 ? Buffer.from([0]) : account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.queueTransaction = function (tx) {\n  this.pending_transactions.push(tx);\n};\n\nBlockchainDouble.prototype.sortByPriceAndNonce = function () {\n  // Sorts transactions like I believe geth does.\n  // See the description of 'SortByPriceAndNonce' at\n  // https://github.com/ethereum/go-ethereum/blob/290e851f57f5d27a1d5f0f7ad784c836e017c337/core/types/transaction.go\n  var self = this;\n  var sortedByNonce = {};\n  self.pending_transactions.forEach(tx => {\n    const from = tx.from.toString(\"hex\");\n    const arr = sortedByNonce[from];\n\n    if (arr) {\n      arr.push(tx);\n    } else {\n      sortedByNonce[from] = [tx];\n    }\n  });\n\n  var priceSort = function (a, b) {\n    return parseInt(to.hex(b.gasPrice), 16) - parseInt(to.hex(a.gasPrice), 16);\n  };\n\n  var nonceSort = function (a, b) {\n    return parseInt(to.hex(a.nonce), 16) - parseInt(to.hex(b.nonce), 16);\n  }; // Now sort each address by nonce\n\n\n  Object.keys(sortedByNonce).forEach(address => {\n    sortedByNonce[address].sort(nonceSort);\n  }); // Initialise a heap, sorted by price, for the head transaction from each account.\n\n  var heap = new Heap(priceSort);\n  Object.keys(sortedByNonce).forEach(address => {\n    heap.push(sortedByNonce[address].shift());\n  }); // Now reorder our transactions. Compare the next transactions from each account, and choose\n  // the one with the highest gas price.\n\n  const sortedTransactions = [];\n\n  while (heap.size() > 0) {\n    const best = heap.pop();\n    const address = best.from.toString(\"hex\");\n\n    if (sortedByNonce[address].length > 0) {\n      // Push on the next transaction from this account\n      heap.push(sortedByNonce[address].shift());\n    }\n\n    sortedTransactions.push(best);\n  }\n\n  self.pending_transactions = sortedTransactions;\n};\n\nBlockchainDouble.prototype.getReadyCall = function (tx, emulateParent, blockNumber, callback) {\n  const readyCall = (tx, err, parentBlock) => {\n    if (err) {\n      return callback(err);\n    } // create a fake block with this fake transaction\n\n\n    this.createBlock(parentBlock, emulateParent, (err, newBlock) => {\n      if (err) {\n        return callback(err);\n      }\n\n      newBlock.transactions.push(tx); // gas estimates and eth_calls aren't subject to block gas limits\n\n      newBlock.header.gasLimit = tx.gasLimit;\n      const runArgs = {\n        tx: tx,\n        block: newBlock,\n        skipBalance: true,\n        skipNonce: true\n      };\n      callback(null, parentBlock.header.stateRoot, runArgs);\n    });\n  }; // Delegate block selection\n\n\n  if (blockNumber === \"latest\") {\n    this.latestBlock(readyCall.bind(null, tx));\n  } else {\n    this.getBlock(blockNumber, readyCall.bind(null, tx));\n  }\n};\n\nBlockchainDouble.prototype.readyCall = function (tx, emulateParent, blockNumber, callback) {\n  this.getReadyCall(tx, emulateParent, blockNumber, (err, stateRoot, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    const stateTrie = this.createStateTrie(this.data.trie_db, stateRoot, {\n      persist: false\n    });\n    const vm = this.createVMFromStateTrie(stateTrie);\n    callback(null, vm, runArgs);\n  });\n};\n\nBlockchainDouble.prototype.processCall = function (tx, blockNumber, callback) {\n  this.readyCall(tx, true, blockNumber, async (err, vm, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    const result = await vm.runTx(runArgs).catch(vmerr => ({\n      vmerr\n    }));\n    let vmerr = result.vmerr; // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n\n    if (vmerr && vmerr instanceof Error === false) {\n      vmerr = new Error(\"VM error: \" + vmerr);\n    } // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n\n\n    if (vmerr) {\n      return callback(vmerr, err);\n    } // If no error, check for a runtime error. This can return null if no runtime error.\n\n\n    vmerr = RuntimeError.fromResults([tx], {\n      results: [result]\n    });\n    callback(vmerr, result);\n  });\n};\n\nBlockchainDouble.prototype.estimateGas = function (tx, blockNumber, callback) {\n  this.getReadyCall(tx, false, blockNumber, (err, stateRoot, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    const generateVM = () => {\n      const stateTrie = this.createStateTrie(this.data.trie_db, stateRoot);\n      return this.createVMFromStateTrie(stateTrie);\n    };\n\n    estimateGas(generateVM, runArgs, callback);\n  });\n};\n/**\n * processBlock\n *\n * Process the passed in block and included transactions\n *\n * @param  {VM} vm             the vm to use when running the block\n * @param  {Block} block       block to process\n * @param  {Boolean} commit    Whether or not changes should be committed to the state\n * trie and the block appended to the end of the chain.\n * @param  {Function} callback Callback function when transaction processing is completed.\n * @return [type]              [description]\n */\n\n\nBlockchainDouble.prototype.processBlock = async function (vm, block, commit, callback) {\n  var self = this;\n\n  if (typeof commit === \"function\") {\n    callback = commit;\n    commit = true;\n  }\n\n  const results = await vm.runBlock({\n    block: block,\n    generate: true,\n    skipBlockValidation: true\n  }).catch(vmerr => ({\n    vmerr\n  }));\n  let vmerr = results.vmerr; // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n\n  if (vmerr && vmerr instanceof Error === false) {\n    vmerr = new Error(\"VM error: \" + vmerr);\n  } // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n\n\n  if (vmerr) {\n    callback(vmerr);\n    return;\n  } // If no error, check for a runtime error. This can return null if no runtime error.\n\n\n  vmerr = RuntimeError.fromResults(block.transactions, results); // Note, even if we have an error, some transactions may still have succeeded.\n  // Process their logs if so, returning the error at the end.\n\n  var logs = [];\n  var receipts = [];\n  var totalBlockGasUsage = 0;\n  results.results.forEach(function (result) {\n    totalBlockGasUsage += to.number(result.gasUsed);\n  });\n  block.header.gasUsed = utils.toBuffer(to.hex(totalBlockGasUsage));\n  const txTrie = new Trie();\n  const rcptTrie = new Trie();\n  const promises = [];\n\n  const putInTrie = (trie, key, val) => promisify(trie.put.bind(trie))(key, val);\n\n  for (var v = 0; v < results.receipts.length; v++) {\n    var result = results.results[v];\n    var receipt = results.receipts[v];\n    var tx = block.transactions[v];\n    var txHash = tx.hash();\n    var txLogs = []; // Only process the transaction's logs if it didn't error.\n\n    if (result.execResult.exceptionError === undefined) {\n      for (var i = 0; i < receipt.logs.length; i++) {\n        var receiptLog = receipt.logs[i];\n        var address = to.hex(receiptLog[0]);\n        var topics = [];\n\n        for (var j = 0; j < receiptLog[1].length; j++) {\n          topics.push(to.hex(receiptLog[1][j]));\n        }\n\n        var data = to.hex(receiptLog[2]);\n        var log = new Log({\n          logIndex: to.hex(i),\n          transactionIndex: to.hex(v),\n          transactionHash: txHash,\n          block: block,\n          address: address,\n          data: data,\n          topics: topics,\n          type: \"mined\"\n        });\n        logs.push(log);\n        txLogs.push(log);\n      }\n    }\n\n    const rcpt = new Receipt(tx, block, txLogs, result.gasUsed.toArrayLike(Buffer), receipt.gasUsed, result.createdAddress, receipt.status, to.hex(receipt.bitvector));\n    receipts.push(rcpt);\n    const rawReceipt = [receipt.status, receipt.gasUsed, receipt.bitvector, receipt.logs];\n    const rcptBuffer = utils.rlp.encode(rawReceipt);\n    const key = utils.rlp.encode(v);\n    promises.push(putInTrie(txTrie, key, tx.serialize()));\n    promises.push(putInTrie(rcptTrie, key, rcptBuffer));\n  }\n\n  await Promise.all(promises);\n  block.header.transactionsTrie = utils.toBuffer(txTrie.root);\n  block.header.receiptTrie = utils.toBuffer(rcptTrie.root);\n\n  if (commit) {\n    // Put that block on the end of the chain\n    self.putBlock(block, logs, receipts, done);\n  } else {\n    done();\n  }\n\n  function done(e) {\n    if (e) {\n      return callback(e);\n    } // Note we return the vm err here too, if it exists.\n\n\n    callback(vmerr, block.transactions, results);\n  }\n};\n/**\n * processNextBlock\n *\n * Process the next block like a normal blockchain, pulling from the list of\n * pending transactions.\n *\n * @param  {number} timestamp at which the block is mined\n * @param  {Function} callback Callback when transaction processing is finished.\n * @return [type]              [description]\n */\n\n\nBlockchainDouble.prototype.processNextBlock = function (timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = undefined;\n  }\n\n  self.sortByPriceAndNonce(); // Grab only the transactions that can fit within the block\n\n  var currentTransactions = [];\n  var totalGasLimit = 0;\n  var maxGasLimit = to.number(self.blockGasLimit);\n\n  while (self.pending_transactions.length > 0) {\n    var tx = self.pending_transactions[0];\n    var gasLimit = to.number(tx.gasLimit);\n\n    if (totalGasLimit + gasLimit <= maxGasLimit) {\n      totalGasLimit += gasLimit;\n      self.pending_transactions.shift();\n      currentTransactions.push(tx);\n    } else {\n      // Next one won't fit. Break.\n      break;\n    }\n  } // Remember, we ensured transactions had a valid gas limit when they were queued (in the state manager).\n  // If we run into a case where we can't process any because one is higher than the gas limit,\n  // then it's a serious issue. This should never happen, but let's check anyway.\n\n\n  if (currentTransactions.length === 0 && self.pending_transactions.length > 0) {\n    // Error like geth.\n    var error = \"Unexpected error condition: next transaction exceeds block gas limit\";\n    return callback(error);\n  } // Create a new block meant to be the end of the chain\n\n\n  this.createBlock(function (err, block) {\n    if (err) {\n      return callback(err);\n    } // Overwrite block timestamp\n\n\n    if (timestamp) {\n      self.data.blocks.last(function (err, last) {\n        if (err) {\n          // it is safe to ignore this error as we only use the result\n          // to log a warning to the console.\n          return;\n        }\n\n        if (last && to.number(last.header.timestamp) > timestamp) {\n          self.logger.log(\"Waring: Setting the block timestamp (\" + timestamp + \") that is earlier than the parent block one.\");\n        }\n      });\n      block.header.timestamp = to.hex(timestamp);\n      self.setTime(new Date(timestamp * 1000));\n    } // Add transactions to the block.\n\n\n    Array.prototype.push.apply(block.transactions, currentTransactions);\n    self.processBlock(self.vm, block, true, callback);\n  });\n};\n/**\n * processTransactionTrace\n *\n * Run a previously-run transaction in the same state in which it occurred at the time it was run.\n * This will return the vm-level trace output for debugging purposes.\n *\n * Strategy:\n *\n *  1. Find block where transaction occurred\n *  2. Set state root of that block\n *  3. Rerun every transaction in that block prior to and including the requested transaction\n *  4. Send trace results back.\n *\n * @param  {[type]}   tx       [description]\n * @param  {Function} callback [description]\n * @return [type]              [description]\n */\n\n\nBlockchainDouble.prototype.processTransactionTrace = async function (hash, params, callback) {\n  const self = this;\n  const targetHash = to.hex(hash);\n  let txHashCurrentlyProcessing = \"\";\n  let txCurrentlyProcessing = null;\n  let vm;\n  const storageStack = {\n    currentDepth: -1,\n    stack: []\n  };\n  const returnVal = {\n    gas: 0,\n    returnValue: \"\",\n    structLogs: []\n  };\n\n  function stepListener(event, next) {\n    // See these docs:\n    // https://github.com/ethereum/go-ethereum/wiki/Management-APIs\n    const gasLeft = to.number(event.gasLeft);\n    const totalGasUsedAfterThisStep = to.number(txCurrentlyProcessing.gasLimit) - gasLeft;\n    const gasUsedPreviousStep = totalGasUsedAfterThisStep - returnVal.gas;\n    returnVal.gas += gasUsedPreviousStep;\n    let memory = null;\n\n    if (!params.disableMemory) {\n      // Get memory and break it up into 32-byte words.\n      // Note we may possibly have to pad the final word.\n      memory = Buffer.from(event.memory).toString(\"hex\");\n      memory = memory.match(/.{1,64}/g) || [];\n\n      if (memory.length > 0) {\n        const lastItem = memory[memory.length - 1];\n\n        if (lastItem.length < 64) {\n          memory[memory.length - 1] = lastItem + new Array(64 - lastItem.length + 1).join(\"0\");\n        }\n      }\n    }\n\n    let stack = null;\n\n    if (!params.disableStack) {\n      stack = event.stack.map(item => {\n        return to.rpcDataHexString(item, 64).replace(\"0x\", \"\"); // non-0x prefixed.\n      });\n    }\n\n    let structLog = {\n      depth: event.depth,\n      error: \"\",\n      gas: gasLeft,\n      gasCost: 0,\n      memory,\n      op: event.opcode.name,\n      pc: event.pc,\n      stack,\n      storage: null\n    }; // The gas difference calculated for each step is indicative of gas consumed in\n    // the previous step. Gas consumption in the final step will always be zero.\n\n    if (returnVal.structLogs.length) {\n      returnVal.structLogs[returnVal.structLogs.length - 1].gasCost = gasUsedPreviousStep;\n    }\n\n    if (params.disableStorage) {\n      returnVal.structLogs.push(structLog);\n      next();\n    } else {\n      structLog = self.processStorageTrace(structLog, storageStack, event, vm, function (err, structLog) {\n        if (err) {\n          return next(err);\n        }\n\n        returnVal.structLogs.push(structLog);\n        next();\n      });\n    }\n  } // #1 - get block via transaction receipt\n\n\n  this.getTransactionReceipt(targetHash, function (err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!receipt) {\n      return callback(new Error(\"Unknown transaction \" + targetHash));\n    }\n\n    const targetBlock = receipt.block; // Get the parent of the target block\n\n    self.getBlock(targetBlock.header.parentHash, function (err, parent) {\n      if (err) {\n        return callback(err);\n      } // #2 - Set state root of original block\n\n\n      var stateTrie = self.createStateTrie(self.data.trie_db, parent.header.stateRoot, {\n        // when forking we need to make sure we also copy over the forkBlockNumber,\n        // otherwise some operations will request data from the main chain at the\n        // latest block\n        forkBlockNumber: to.number(parent.header.number)\n      });\n      vm = self.createVMFromStateTrie(stateTrie); // Prepare the \"next\" block with necessary transactions\n\n      self.createBlock(parent, false, function (err, block) {\n        if (err) {\n          return callback(err);\n        } // make sure we use the same timestamp as the target block\n\n\n        block.header.timestamp = targetBlock.header.timestamp;\n\n        for (var i = 0; i < targetBlock.transactions.length; i++) {\n          var tx = targetBlock.transactions[i];\n          block.transactions.push(tx); // After including the target transaction, that's all we need to do.\n\n          if (to.hex(tx.hash()) === targetHash) {\n            break;\n          }\n        }\n\n        function beforeTxListener(tx) {\n          txCurrentlyProcessing = tx;\n          txHashCurrentlyProcessing = to.hex(tx.hash());\n\n          if (txHashCurrentlyProcessing === targetHash) {\n            vm.on(\"step\", stepListener);\n          }\n        } // afterTxListener cleans up everything.\n\n\n        function afterTxListener() {\n          if (txHashCurrentlyProcessing === targetHash) {\n            removeListeners();\n          }\n        }\n\n        function removeListeners() {\n          vm.removeListener(\"step\", stepListener);\n          vm.removeListener(\"beforeTx\", beforeTxListener);\n          vm.removeListener(\"afterTx\", afterTxListener);\n        } // Listen to beforeTx and afterTx so we know when our target transaction\n        // is processing. These events will add the event listener for getting the trace data.\n\n\n        vm.on(\"beforeTx\", beforeTxListener);\n        vm.on(\"afterTx\", afterTxListener); // Don't even let the vm try to flush the block's _cache to the stateTrie.\n        // When forking some of the data that the traced function may request will\n        // exist only on the main chain. Because we pretty much lie to the VM by\n        // telling it we DO have data in our Trie, when we really don't, it gets\n        // lost during the commit phase when it traverses the \"borrowed\" data's\n        // trie (as it may not have a valid root). Because this is a trace, and we\n        // don't need to commit the data, duck punching the `flush` method (the\n        // simplest method I could find) is fine.\n        // Remove this and you may see the infamous\n        // `Uncaught TypeError: Cannot read property 'pop' of undefined` error!\n\n        vm.stateManager._cache.flush = cb => cb(); // #3 - Process the block without committing the data.\n\n\n        self.processBlock(vm, block, false, function (err) {\n          // Ignore runtime errors, or else erroneous transactions can't be traced.\n          if (err && err.message.indexOf(\"VM Exception\") === 0) {\n            err = null;\n          } // Just to be safe\n\n\n          removeListeners(); // #4 - send state results back\n\n          callback(err, returnVal);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.processStorageTrace = function (structLog, storageStack, event, vm, callback) {\n  var name = event.opcode.name;\n\n  if (storageStack.currentDepth > event.depth) {\n    storageStack.stack.pop();\n  }\n\n  if (storageStack.currentDepth < event.depth) {\n    storageStack.stack.push({});\n  }\n\n  storageStack.currentDepth = event.depth;\n  var key;\n  var value;\n\n  switch (name) {\n    case \"SSTORE\":\n      {\n        const stack = event.stack;\n        const stackLength = stack.length;\n        key = to.rpcDataHexString(stack[stackLength - 1], 64).replace(\"0x\", \"\");\n        value = to.rpcDataHexString(stack[stackLength - 2], 64).replace(\"0x\", \"\"); // use Object.assign to prevent future steps from overwriting this step's storage values\n\n        structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n        callback(null, structLog); // assign after callback because this storage change actually takes\n        // effect _after_ this opcode executes\n\n        storageStack.stack[storageStack.currentDepth][key] = value;\n      }\n      break;\n\n    case \"SLOAD\":\n      {\n        const stack = event.stack; // this one's more fun, we need to get the value the contract is loading from current storage\n\n        key = to.rpcDataHexString(stack[stack.length - 1], 64).replace(\"0x\", \"\");\n        vm.stateManager.getContractStorage(event.address, Buffer.from(key, \"hex\"), function (err, result) {\n          if (err) {\n            return callback(err);\n          }\n\n          value = to.rpcDataHexString(result, 64).replace(\"0x\", \"\");\n          storageStack.stack[storageStack.currentDepth][key] = value; // use Object.assign to prevent future steps from overwriting this step's storage values\n\n          structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n          callback(null, structLog);\n        });\n      }\n      break;\n\n    default:\n      // use Object.assign to prevent future steps from overwriting this step's storage values\n      structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n      callback(null, structLog);\n  }\n};\n\nBlockchainDouble.prototype.getAccount = function (address, number, callback) {\n  var self = this;\n  this.getBlock(number, function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie; // Manipulate the state root in place to maintain checkpoints\n\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n    trie.get(utils.toBuffer(address), function (err, data) {\n      // Finally, put the stateRoot back for good\n      trie.root = currentStateRoot;\n\n      if (err) {\n        return callback(err);\n      }\n\n      var account = new Account(data);\n      callback(null, account);\n    });\n  });\n};\n\nBlockchainDouble.prototype.getNonce = function (address, number, callback) {\n  this.getAccount(address, number, function (err, account) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.getBalance = function (address, number, callback) {\n  this.getAccount(address, number, function (err, account) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, account.balance);\n  });\n}; // Note! Storage values are returned RLP encoded!\n\n\nBlockchainDouble.prototype.getStorage = function (address, position, number, callback) {\n  var self = this;\n  this.getBlock(number, function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie; // Manipulate the state root in place to maintain checkpoints\n\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n    trie.get(utils.toBuffer(address), function (err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n      trie.root = account.stateRoot;\n      trie.get(utils.setLengthLeft(utils.toBuffer(position), 32), function (err, value) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err != null) {\n          return callback(err);\n        }\n\n        callback(null, value);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getCode = function (address, number, callback) {\n  var self = this;\n  this.getBlock(number, function (err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie; // Manipulate the state root in place to maintain checkpoints\n\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n    trie.get(utils.toBuffer(address), function (err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n      account.getCode(trie, function (err, code) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, code);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getTransaction = function (hash, callback) {\n  hash = to.hex(hash);\n  this.data.transactions.get(hash, function (err, tx) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(null, tx);\n  });\n};\n\nBlockchainDouble.prototype.getTransactionReceipt = function (hash, callback) {\n  hash = to.hex(hash);\n  const pendingTxs = this.pending_transactions;\n\n  for (var i = 0; i < pendingTxs.length; i++) {\n    const pendingTxHash = to.hex(pendingTxs[i].hash());\n\n    if (hash === pendingTxHash) {\n      return callback(null, {\n        tx: pendingTxs[i]\n      });\n    }\n  }\n\n  this.data.transactionReceipts.get(hash, function (err, receipt) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(err, receipt);\n  });\n};\n\nBlockchainDouble.prototype.getBlockLogs = function (number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function (err, effective) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.data.blockLogs.get(effective, callback);\n  });\n};\n\nBlockchainDouble.prototype.getHeight = function (callback) {\n  this.data.blocks.length(function (err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, length - 1);\n  });\n};\n\nBlockchainDouble.prototype.currentTime = function () {\n  return (new Date().getTime() / 1000 | 0) + this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.increaseTime = function (seconds) {\n  if (seconds < 0) {\n    seconds = 0;\n  }\n\n  this.timeAdjustment += seconds;\n  return this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.setTime = function (date) {\n  var now = new Date().getTime() / 1000 | 0;\n  var start = date.getTime() / 1000 | 0;\n  this.timeAdjustment = start - now;\n};\n\nBlockchainDouble.prototype.close = function (callback) {\n  this.data.close(callback);\n};\n\nmodule.exports = BlockchainDouble;","map":{"version":3,"names":["to","require","Account","default","Block","Log","Receipt","VM","Common","RuntimeError","Trie","utils","async","Heap","Database","EventEmitter","estimateGas","_","promisify","BN","BlockchainDouble","options","self","apply","_applyDefaultOptions","logger","console","data","trie","db_path","Error","pending_transactions","blockGasLimit","gasLimit","defaultTransactionGasLimit","timeAdjustment","defaultOptions","time","debug","hardfork","allowUnlimitedContractSize","prototype","Object","create","constructor","merge","assign","initialize","accounts","callback","err","latestBlock","block","root","header","stateRoot","stateTrie","createStateTrie","trie_db","vm","createVMFromStateTrie","setTime","emit","createGenesisBlock","stateManager","checkpoint","eachSeries","accountData","finished","putAccount","toBuffer","address","account","commit","putBlock","state","activatePrecompiles","common","forCustomChain","name","networkId","network_id","forkVersion","chainId","_chainId","comment","bootstrapNodes","blockchain","getBlock","number","done","e","on","info","opcode","argsNum","in","args","stack","slice","map","arg","hex","join","log","db","createBlock","blocks","last","getEffectiveBlockNumber","indexOf","getHeight","hash","length","blockHashes","get","blockIndex","first","process","nextTick","logs","receipts","requests","push","bind","blockLogs","set","transactions","forEach","tx","index","txHash","transactionReceipts","parallel","result","popBlock","blockHash","del","pop","series","newLastBlock","setStateRoot","clearPendingTransactions","parent","emulateParent","getParent","timestamp","parentHash","parentNumber","currentTime","getQueuedNonce","nonce","addressBuffer","buffer","from","equals","pendingNonce","gt","iaddn","toArrayLike","Buffer","val","queueTransaction","sortByPriceAndNonce","sortedByNonce","toString","arr","priceSort","a","b","parseInt","gasPrice","nonceSort","keys","sort","heap","shift","sortedTransactions","size","best","getReadyCall","blockNumber","readyCall","parentBlock","newBlock","runArgs","skipBalance","skipNonce","persist","processCall","runTx","catch","vmerr","fromResults","results","generateVM","processBlock","runBlock","generate","skipBlockValidation","totalBlockGasUsage","gasUsed","txTrie","rcptTrie","promises","putInTrie","key","put","v","receipt","txLogs","execResult","exceptionError","undefined","i","receiptLog","topics","j","logIndex","transactionIndex","transactionHash","type","rcpt","createdAddress","status","bitvector","rawReceipt","rcptBuffer","rlp","encode","serialize","Promise","all","transactionsTrie","receiptTrie","processNextBlock","currentTransactions","totalGasLimit","maxGasLimit","error","Date","Array","processTransactionTrace","params","targetHash","txHashCurrentlyProcessing","txCurrentlyProcessing","storageStack","currentDepth","returnVal","gas","returnValue","structLogs","stepListener","event","next","gasLeft","totalGasUsedAfterThisStep","gasUsedPreviousStep","memory","disableMemory","match","lastItem","disableStack","item","rpcDataHexString","replace","structLog","depth","gasCost","op","pc","storage","disableStorage","processStorageTrace","getTransactionReceipt","targetBlock","forkBlockNumber","beforeTxListener","afterTxListener","removeListeners","removeListener","_cache","flush","cb","message","value","stackLength","getContractStorage","getAccount","currentStateRoot","getNonce","getBalance","balance","getStorage","position","setLengthLeft","getCode","code","getTransaction","notFound","pendingTxs","pendingTxHash","getBlockLogs","effective","getTime","increaseTime","seconds","date","now","start","close","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/blockchain_double.js"],"sourcesContent":["var to = require(\"./utils/to.js\");\nvar Account = require(\"ethereumjs-account\").default;\nvar Block = require(\"ethereumjs-block\");\nvar Log = require(\"./utils/log\");\nvar Receipt = require(\"./utils/receipt\");\nvar VM = require(\"ethereumjs-vm\").default;\nvar Common = require(\"ethereumjs-common\").default;\nvar RuntimeError = require(\"./utils/runtimeerror\");\nvar Trie = require(\"merkle-patricia-tree\");\nvar utils = require(\"ethereumjs-util\");\nvar async = require(\"async\");\nvar Heap = require(\"heap\");\nvar Database = require(\"./database\");\nvar EventEmitter = require(\"events\");\nvar estimateGas = require(\"./utils/gas/estimateGas\");\nvar _ = require(\"lodash\");\nvar promisify = require(\"util\").promisify;\nconst BN = utils.BN;\n\nfunction BlockchainDouble(options) {\n  var self = this;\n  EventEmitter.apply(self);\n\n  this.options = options = this._applyDefaultOptions(options || {});\n\n  this.logger = options.logger || console;\n\n  this.data = new Database(options);\n\n  if (options.trie != null && options.db_path != null) {\n    throw new Error(\"Can't initialize a TestRPC with a db and a custom trie.\");\n  }\n\n  this.pending_transactions = [];\n\n  // updated periodically to keep up with the times\n  this.blockGasLimit = options.gasLimit;\n  this.defaultTransactionGasLimit = options.defaultTransactionGasLimit;\n  this.timeAdjustment = 0;\n}\n\nconst defaultOptions = {\n  gasLimit: \"0x6691b7\",\n  defaultTransactionGasLimit: \"0x15f90\",\n  time: null,\n  debug: false,\n  hardfork: \"muirGlacier\",\n  allowUnlimitedContractSize: false\n};\n\n// inheritence w/ prototype chaining\nBlockchainDouble.prototype = Object.create(EventEmitter.prototype);\nBlockchainDouble.prototype.constructor = BlockchainDouble;\n\nBlockchainDouble.prototype._applyDefaultOptions = function(options) {\n  // We want this function to mutate the options object so that we can report\n  // our settings back to our consumer application (e.g., ganache)\n  return _.merge(options, defaultOptions, Object.assign({}, options));\n};\n\nBlockchainDouble.prototype.initialize = function(accounts, callback) {\n  var self = this;\n\n  this.data.initialize(function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.latestBlock(function(err, block) {\n      if (err) {\n        return callback(err);\n      }\n\n      var options = self.options;\n\n      var root = null;\n\n      if (block) {\n        root = block.header.stateRoot;\n      }\n\n      // I haven't yet found a good way to do this. Getting the trie from the\n      // forked blockchain without going through the other setup is a little gross.\n      self.stateTrie = self.createStateTrie(self.data.trie_db, root);\n\n      self.vm = options.vm || self.createVMFromStateTrie(self.stateTrie, true);\n\n      if (options.time) {\n        self.setTime(options.time);\n      }\n\n      // If we already have a block, then that means there's an existing chain.\n      // Don't create a genesis block.\n      if (block) {\n        self.emit(\"block\", block);\n        return callback();\n      }\n\n      self.createGenesisBlock(function(err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        accounts = accounts || [];\n\n        self.vm.stateManager.checkpoint(() => {\n          async.eachSeries(\n            accounts,\n            function(accountData, finished) {\n              self.vm.stateManager.putAccount(utils.toBuffer(accountData.address), accountData.account, finished);\n            },\n            function(err) {\n              if (err) {\n                return callback(err);\n              }\n\n              self.vm.stateManager.commit(() => {\n                // Create first block\n                self.putBlock(block, [], [], callback);\n              });\n            }\n          );\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.createVMFromStateTrie = function(state, activatePrecompiles) {\n  const self = this;\n  const common = Common.forCustomChain(\n    \"mainnet\", // TODO needs to match chain id\n    {\n      name: \"ganache\",\n      networkId: self.options.network_id || self.forkVersion,\n      chainId: self.options._chainId,\n      comment: \"Local test network\",\n      bootstrapNodes: []\n    },\n    self.options.hardfork\n  );\n\n  const vm = new VM({\n    state: state,\n    common,\n    blockchain: {\n      // EthereumJS VM needs a blockchain object in order to get block information.\n      // When calling getBlock() it will pass a number that's of a Buffer type.\n      // Unfortunately, it uses a 64-character buffer (when converted to hex) to\n      // represent block numbers as well as block hashes. Since it's very unlikely\n      // any block number will get higher than the maximum safe Javascript integer,\n      // we can convert this buffer to a number ahead of time before calling our\n      // own getBlock(). If the conversion succeeds, we have a block number.\n      // If it doesn't, we have a block hash. (Note: Our implementation accepts both.)\n      getBlock: function(number, done) {\n        try {\n          number = to.number(number);\n        } catch (e) {\n          // Do nothing; must be a block hash.\n        }\n\n        self.getBlock(number, done);\n      }\n    },\n    activatePrecompiles: activatePrecompiles || false,\n    allowUnlimitedContractSize: self.options.allowUnlimitedContractSize\n  });\n\n  if (self.options.debug === true) {\n    // log executed opcodes, including args as hex\n    vm.on(\"step\", function(info) {\n      var name = info.opcode.name;\n      var argsNum = info.opcode.in;\n      if (argsNum) {\n        var args = info.stack\n          .slice(-argsNum)\n          .map((arg) => to.hex(arg))\n          .join(\" \");\n\n        self.logger.log(`${name} ${args}`);\n      } else {\n        self.logger.log(name);\n      }\n    });\n  }\n\n  return vm;\n};\n\nBlockchainDouble.prototype.createStateTrie = function(db, root) {\n  return new Trie(db, root);\n};\n\n// Overrideable so other implementations (forking) can edit it.\nBlockchainDouble.prototype.createGenesisBlock = function(callback) {\n  this.createBlock(callback);\n};\n\nBlockchainDouble.prototype.latestBlock = function(callback) {\n  this.data.blocks.last(function(err, last) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, last);\n  });\n};\n\n// number accepts number (integer, hex) or tag (e.g., \"latest\")\nBlockchainDouble.prototype.getEffectiveBlockNumber = function(number, callback) {\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  }\n\n  // If we have a hex number\n  if (number.indexOf(\"0x\") >= 0) {\n    return callback(null, to.number(number));\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.getHeight(callback);\n    } else if (number === \"earliest\") {\n      return callback(null, 0);\n    }\n  }\n};\n\n// number accepts number (integer, hex), tag (e.g., \"latest\") or block hash\n// This function is used by ethereumjs-vm\nBlockchainDouble.prototype.getBlock = function(number, callback) {\n  var self = this;\n\n  if (typeof number !== \"string\") {\n    number = to.hex(number);\n  }\n\n  // If we have a hex number or a block hash\n  if (number.indexOf(\"0x\") >= 0) {\n    var hash = number;\n\n    // block hash\n    if (hash.length > 40) {\n      this.data.blockHashes.get(to.hex(hash), function(err, blockIndex) {\n        if (err) {\n          return callback(err);\n        }\n        return self.data.blocks.get(blockIndex, callback);\n      });\n    } else {\n      // Block number\n      return this.data.blocks.get(to.number(hash), callback);\n    }\n  } else {\n    if (number === \"latest\" || number === \"pending\") {\n      return this.latestBlock(callback);\n    } else if (number === \"earliest\") {\n      return this.data.blocks.first(callback);\n    } else {\n      process.nextTick(callback, new Error(\"Invalid `blockNumber`: \\\"\" + number + \"\\\"\"));\n    }\n  }\n};\n\nBlockchainDouble.prototype.putBlock = function(block, logs, receipts, callback) {\n  var self = this;\n\n  // Lock in the state root for this block.\n  block.header.stateRoot = this.stateTrie.root;\n\n  this.data.blocks.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n\n    var requests = [\n      self.data.blocks.push.bind(self.data.blocks, block),\n      self.data.blockLogs.push.bind(self.data.blockLogs, logs),\n      self.data.blockHashes.set.bind(self.data.blockHashes, to.hex(block.hash()), length)\n    ];\n\n    block.transactions.forEach(function(tx, index) {\n      var txHash = to.hex(tx.hash());\n      requests.push(\n        self.data.transactions.set.bind(self.data.transactions, txHash, tx),\n        self.data.transactionReceipts.set.bind(self.data.transactionReceipts, txHash, receipts[index])\n      );\n    });\n\n    async.parallel(requests, (err, result) => {\n      if (!err) {\n        self.emit(\"block\", block);\n      }\n      callback(err, result);\n    });\n  });\n};\n\nBlockchainDouble.prototype.popBlock = function(callback) {\n  var self = this;\n\n  this.data.blocks.last(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n    if (block == null) {\n      return callback(null, null);\n    }\n\n    var requests = [];\n    var blockHash = to.hex(block.hash());\n\n    block.transactions.forEach(function(tx) {\n      var txHash = to.hex(tx.hash());\n\n      requests.push(\n        self.data.transactions.del.bind(self.data.transactions, txHash),\n        self.data.transactionReceipts.del.bind(self.data.transactionReceipts, txHash)\n      );\n    });\n\n    requests.push(\n      self.data.blockLogs.pop.bind(self.data.blockLogs),\n      self.data.blockHashes.del.bind(self.data.blockHashes, blockHash),\n      self.data.blocks.pop.bind(self.data.blocks) // Do this one last in case anything relies on it.\n    );\n\n    async.series(requests, function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Set the root to the last available, which will \"roll back\" to the previous\n      // moment in time. Note that all the old data is still in the db, but it's now just junk data.\n      self.data.blocks.last(function(err, newLastBlock) {\n        if (err) {\n          return callback(err);\n        }\n        // using setStateRoot because in the future it will automatically take care\n        // of clearing the cache for us.\n        // note setStateRoot checks for checkpoints, and if there are any, it will fail.\n        // At time of writing this comment, the only time there could be a checkpoint\n        // is in the middle of a vm.runBlock call. Once asyncRequestProcessing is reenabled\n        // this will likely cause problems.\n        self.vm.stateManager.setStateRoot(newLastBlock.header.stateRoot, function(err) {\n          // Remember: Return block we popped off.\n          callback(err, block);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.clearPendingTransactions = function() {\n  this.pending_transactions = [];\n};\n\n/**\n * createBlock\n *\n * Create a new block, where the parent's block is either the latest block\n * on the chain or the parent block passed in.\n *\n * @param  {Block}   parent   The block meant to be the parent block (optional)\n * @param  {Function} callback Callback function called after block is created\n * @return Block              The block created.\n */\nBlockchainDouble.prototype.createBlock = function(parent, emulateParent, callback) {\n  var self = this;\n\n  if (typeof parent === \"function\") {\n    callback = parent;\n    parent = null;\n    emulateParent = false;\n  } else if (typeof emulateParent === \"function\") {\n    callback = emulateParent;\n    emulateParent = false;\n  }\n\n  var block = new Block();\n\n  function getParent(callback) {\n    if (parent) {\n      return callback(null, parent);\n    } else {\n      self.latestBlock(callback);\n    }\n  }\n\n  getParent(function(err, parent) {\n    if (err) {\n      return callback(err);\n    }\n\n    block.header.gasLimit = self.blockGasLimit;\n\n    if (parent != null && emulateParent) {\n      block.header.number = parent.header.number;\n      block.header.timestamp = parent.header.timestamp;\n      block.header.parentHash = parent.header.parentHash;\n    } else {\n      var parentNumber = parent != null ? to.number(parent.header.number) : -1;\n\n      // Ensure we have the right block number for the VM.\n      block.header.number = to.hex(parentNumber + 1);\n\n      // Set the timestamp before processing txs\n      block.header.timestamp = to.hex(self.currentTime());\n\n      if (parent != null) {\n        block.header.parentHash = to.hex(parent.hash());\n      }\n    }\n\n    callback(null, block);\n  });\n};\n\nBlockchainDouble.prototype.getQueuedNonce = function(address, callback) {\n  var nonce = null;\n  var addressBuffer = to.buffer(address);\n  this.pending_transactions.forEach(function(tx) {\n    if (!tx.from.equals(addressBuffer)) {\n      return;\n    }\n\n    var pendingNonce = new BN(tx.nonce);\n    // If this is the first queued nonce for this address we found,\n    // or it's higher than the previous highest, note it.\n    if (nonce === null || pendingNonce.gt(nonce)) {\n      nonce = pendingNonce;\n    }\n  });\n\n  // If we found a queued transaction nonce, return one higher\n  // than the highest we found\n  if (nonce != null) {\n    return callback(null, nonce.iaddn(1).toArrayLike(Buffer));\n  }\n  this.stateTrie.get(addressBuffer, function(err, val) {\n    if (err) {\n      return callback(err);\n    }\n\n    var account = new Account(val);\n    // nonces are initiallized as an empty buffer, which isn't what we want.\n    callback(null, account.nonce.length === 0 ? Buffer.from([0]) : account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.queueTransaction = function(tx) {\n  this.pending_transactions.push(tx);\n};\n\nBlockchainDouble.prototype.sortByPriceAndNonce = function() {\n  // Sorts transactions like I believe geth does.\n  // See the description of 'SortByPriceAndNonce' at\n  // https://github.com/ethereum/go-ethereum/blob/290e851f57f5d27a1d5f0f7ad784c836e017c337/core/types/transaction.go\n  var self = this;\n  var sortedByNonce = {};\n\n  self.pending_transactions.forEach((tx) => {\n    const from = tx.from.toString(\"hex\");\n    const arr = sortedByNonce[from];\n    if (arr) {\n      arr.push(tx);\n    } else {\n      sortedByNonce[from] = [tx];\n    }\n  });\n\n  var priceSort = function(a, b) {\n    return parseInt(to.hex(b.gasPrice), 16) - parseInt(to.hex(a.gasPrice), 16);\n  };\n  var nonceSort = function(a, b) {\n    return parseInt(to.hex(a.nonce), 16) - parseInt(to.hex(b.nonce), 16);\n  };\n\n  // Now sort each address by nonce\n  Object.keys(sortedByNonce).forEach((address) => {\n    sortedByNonce[address].sort(nonceSort);\n  });\n\n  // Initialise a heap, sorted by price, for the head transaction from each account.\n  var heap = new Heap(priceSort);\n  Object.keys(sortedByNonce).forEach((address) => {\n    heap.push(sortedByNonce[address].shift());\n  });\n\n  // Now reorder our transactions. Compare the next transactions from each account, and choose\n  // the one with the highest gas price.\n  const sortedTransactions = [];\n  while (heap.size() > 0) {\n    const best = heap.pop();\n    const address = best.from.toString(\"hex\");\n    if (sortedByNonce[address].length > 0) {\n      // Push on the next transaction from this account\n      heap.push(sortedByNonce[address].shift());\n    }\n    sortedTransactions.push(best);\n  }\n  self.pending_transactions = sortedTransactions;\n};\n\nBlockchainDouble.prototype.getReadyCall = function(tx, emulateParent, blockNumber, callback) {\n  const readyCall = (tx, err, parentBlock) => {\n    if (err) {\n      return callback(err);\n    }\n    // create a fake block with this fake transaction\n    this.createBlock(parentBlock, emulateParent, (err, newBlock) => {\n      if (err) {\n        return callback(err);\n      }\n\n      newBlock.transactions.push(tx);\n\n      // gas estimates and eth_calls aren't subject to block gas limits\n      newBlock.header.gasLimit = tx.gasLimit;\n\n      const runArgs = {\n        tx: tx,\n        block: newBlock,\n        skipBalance: true,\n        skipNonce: true\n      };\n\n      callback(null, parentBlock.header.stateRoot, runArgs);\n    });\n  };\n  // Delegate block selection\n  if (blockNumber === \"latest\") {\n    this.latestBlock(readyCall.bind(null, tx));\n  } else {\n    this.getBlock(blockNumber, readyCall.bind(null, tx));\n  }\n};\n\nBlockchainDouble.prototype.readyCall = function(tx, emulateParent, blockNumber, callback) {\n  this.getReadyCall(tx, emulateParent, blockNumber, (err, stateRoot, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const stateTrie = this.createStateTrie(this.data.trie_db, stateRoot, { persist: false });\n    const vm = this.createVMFromStateTrie(stateTrie);\n    callback(null, vm, runArgs);\n  });\n};\n\nBlockchainDouble.prototype.processCall = function(tx, blockNumber, callback) {\n  this.readyCall(tx, true, blockNumber, async(err, vm, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    const result = await vm.runTx(runArgs).catch((vmerr) => ({ vmerr }));\n    let vmerr = result.vmerr;\n    // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n    if (vmerr && vmerr instanceof Error === false) {\n      vmerr = new Error(\"VM error: \" + vmerr);\n    }\n\n    // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n    if (vmerr) {\n      return callback(vmerr, err);\n    }\n\n    // If no error, check for a runtime error. This can return null if no runtime error.\n    vmerr = RuntimeError.fromResults([tx], { results: [result] });\n\n    callback(vmerr, result);\n  });\n};\n\nBlockchainDouble.prototype.estimateGas = function(tx, blockNumber, callback) {\n  this.getReadyCall(tx, false, blockNumber, (err, stateRoot, runArgs) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const generateVM = () => {\n      const stateTrie = this.createStateTrie(this.data.trie_db, stateRoot);\n      return this.createVMFromStateTrie(stateTrie);\n    };\n    estimateGas(generateVM, runArgs, callback);\n  });\n};\n\n/**\n * processBlock\n *\n * Process the passed in block and included transactions\n *\n * @param  {VM} vm             the vm to use when running the block\n * @param  {Block} block       block to process\n * @param  {Boolean} commit    Whether or not changes should be committed to the state\n * trie and the block appended to the end of the chain.\n * @param  {Function} callback Callback function when transaction processing is completed.\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processBlock = async function(vm, block, commit, callback) {\n  var self = this;\n\n  if (typeof commit === \"function\") {\n    callback = commit;\n    commit = true;\n  }\n\n  const results = await vm\n    .runBlock({\n      block: block,\n      generate: true,\n      skipBlockValidation: true\n    })\n    .catch((vmerr) => ({ vmerr }));\n  let vmerr = results.vmerr;\n  // This is a check that has been in there for awhile. I'm unsure if it's required, but it can't hurt.\n  if (vmerr && vmerr instanceof Error === false) {\n    vmerr = new Error(\"VM error: \" + vmerr);\n  }\n\n  // If we're given an error back directly, it's worse than a runtime error. Expose it and get out.\n  if (vmerr) {\n    callback(vmerr);\n    return;\n  }\n  // If no error, check for a runtime error. This can return null if no runtime error.\n  vmerr = RuntimeError.fromResults(block.transactions, results);\n\n  // Note, even if we have an error, some transactions may still have succeeded.\n  // Process their logs if so, returning the error at the end.\n\n  var logs = [];\n  var receipts = [];\n\n  var totalBlockGasUsage = 0;\n\n  results.results.forEach(function(result) {\n    totalBlockGasUsage += to.number(result.gasUsed);\n  });\n\n  block.header.gasUsed = utils.toBuffer(to.hex(totalBlockGasUsage));\n\n  const txTrie = new Trie();\n  const rcptTrie = new Trie();\n  const promises = [];\n  const putInTrie = (trie, key, val) => promisify(trie.put.bind(trie))(key, val);\n\n  for (var v = 0; v < results.receipts.length; v++) {\n    var result = results.results[v];\n    var receipt = results.receipts[v];\n    var tx = block.transactions[v];\n    var txHash = tx.hash();\n    var txLogs = [];\n\n    // Only process the transaction's logs if it didn't error.\n    if (result.execResult.exceptionError === undefined) {\n      for (var i = 0; i < receipt.logs.length; i++) {\n        var receiptLog = receipt.logs[i];\n        var address = to.hex(receiptLog[0]);\n        var topics = [];\n\n        for (var j = 0; j < receiptLog[1].length; j++) {\n          topics.push(to.hex(receiptLog[1][j]));\n        }\n\n        var data = to.hex(receiptLog[2]);\n\n        var log = new Log({\n          logIndex: to.hex(i),\n          transactionIndex: to.hex(v),\n          transactionHash: txHash,\n          block: block,\n          address: address,\n          data: data,\n          topics: topics,\n          type: \"mined\"\n        });\n\n        logs.push(log);\n        txLogs.push(log);\n      }\n    }\n\n    const rcpt = new Receipt(\n      tx,\n      block,\n      txLogs,\n      result.gasUsed.toArrayLike(Buffer),\n      receipt.gasUsed,\n      result.createdAddress,\n      receipt.status,\n      to.hex(receipt.bitvector)\n    );\n    receipts.push(rcpt);\n\n    const rawReceipt = [receipt.status, receipt.gasUsed, receipt.bitvector, receipt.logs];\n    const rcptBuffer = utils.rlp.encode(rawReceipt);\n    const key = utils.rlp.encode(v);\n    promises.push(putInTrie(txTrie, key, tx.serialize()));\n    promises.push(putInTrie(rcptTrie, key, rcptBuffer));\n  }\n  await Promise.all(promises);\n\n  block.header.transactionsTrie = utils.toBuffer(txTrie.root);\n  block.header.receiptTrie = utils.toBuffer(rcptTrie.root);\n\n  if (commit) {\n    // Put that block on the end of the chain\n    self.putBlock(block, logs, receipts, done);\n  } else {\n    done();\n  }\n\n  function done(e) {\n    if (e) {\n      return callback(e);\n    }\n    // Note we return the vm err here too, if it exists.\n    callback(vmerr, block.transactions, results);\n  }\n};\n\n/**\n * processNextBlock\n *\n * Process the next block like a normal blockchain, pulling from the list of\n * pending transactions.\n *\n * @param  {number} timestamp at which the block is mined\n * @param  {Function} callback Callback when transaction processing is finished.\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processNextBlock = function(timestamp, callback) {\n  var self = this;\n\n  if (typeof timestamp === \"function\") {\n    callback = timestamp;\n    timestamp = undefined;\n  }\n\n  self.sortByPriceAndNonce();\n\n  // Grab only the transactions that can fit within the block\n  var currentTransactions = [];\n  var totalGasLimit = 0;\n  var maxGasLimit = to.number(self.blockGasLimit);\n\n  while (self.pending_transactions.length > 0) {\n    var tx = self.pending_transactions[0];\n    var gasLimit = to.number(tx.gasLimit);\n\n    if (totalGasLimit + gasLimit <= maxGasLimit) {\n      totalGasLimit += gasLimit;\n      self.pending_transactions.shift();\n      currentTransactions.push(tx);\n    } else {\n      // Next one won't fit. Break.\n      break;\n    }\n  }\n\n  // Remember, we ensured transactions had a valid gas limit when they were queued (in the state manager).\n  // If we run into a case where we can't process any because one is higher than the gas limit,\n  // then it's a serious issue. This should never happen, but let's check anyway.\n  if (currentTransactions.length === 0 && self.pending_transactions.length > 0) {\n    // Error like geth.\n    var error = \"Unexpected error condition: next transaction exceeds block gas limit\";\n    return callback(error);\n  }\n\n  // Create a new block meant to be the end of the chain\n  this.createBlock(function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Overwrite block timestamp\n    if (timestamp) {\n      self.data.blocks.last(function(err, last) {\n        if (err) {\n          // it is safe to ignore this error as we only use the result\n          // to log a warning to the console.\n          return;\n        }\n        if (last && to.number(last.header.timestamp) > timestamp) {\n          self.logger.log(\n            \"Waring: Setting the block timestamp (\" + timestamp + \") that is earlier than the parent block one.\"\n          );\n        }\n      });\n      block.header.timestamp = to.hex(timestamp);\n      self.setTime(new Date(timestamp * 1000));\n    }\n    // Add transactions to the block.\n    Array.prototype.push.apply(block.transactions, currentTransactions);\n\n    self.processBlock(self.vm, block, true, callback);\n  });\n};\n\n/**\n * processTransactionTrace\n *\n * Run a previously-run transaction in the same state in which it occurred at the time it was run.\n * This will return the vm-level trace output for debugging purposes.\n *\n * Strategy:\n *\n *  1. Find block where transaction occurred\n *  2. Set state root of that block\n *  3. Rerun every transaction in that block prior to and including the requested transaction\n *  4. Send trace results back.\n *\n * @param  {[type]}   tx       [description]\n * @param  {Function} callback [description]\n * @return [type]              [description]\n */\nBlockchainDouble.prototype.processTransactionTrace = async function(hash, params, callback) {\n  const self = this;\n  const targetHash = to.hex(hash);\n  let txHashCurrentlyProcessing = \"\";\n  let txCurrentlyProcessing = null;\n  let vm;\n\n  const storageStack = {\n    currentDepth: -1,\n    stack: []\n  };\n\n  const returnVal = {\n    gas: 0,\n    returnValue: \"\",\n    structLogs: []\n  };\n\n  function stepListener(event, next) {\n    // See these docs:\n    // https://github.com/ethereum/go-ethereum/wiki/Management-APIs\n\n    const gasLeft = to.number(event.gasLeft);\n    const totalGasUsedAfterThisStep = to.number(txCurrentlyProcessing.gasLimit) - gasLeft;\n    const gasUsedPreviousStep = totalGasUsedAfterThisStep - returnVal.gas;\n    returnVal.gas += gasUsedPreviousStep;\n\n    let memory = null;\n    if (!params.disableMemory) {\n      // Get memory and break it up into 32-byte words.\n      // Note we may possibly have to pad the final word.\n      memory = Buffer.from(event.memory).toString(\"hex\");\n      memory = memory.match(/.{1,64}/g) || [];\n\n      if (memory.length > 0) {\n        const lastItem = memory[memory.length - 1];\n        if (lastItem.length < 64) {\n          memory[memory.length - 1] = lastItem + new Array(64 - lastItem.length + 1).join(\"0\");\n        }\n      }\n    }\n\n    let stack = null;\n    if (!params.disableStack) {\n      stack = event.stack.map((item) => {\n        return to.rpcDataHexString(item, 64).replace(\"0x\", \"\"); // non-0x prefixed.\n      });\n    }\n    let structLog = {\n      depth: event.depth,\n      error: \"\",\n      gas: gasLeft,\n      gasCost: 0,\n      memory,\n      op: event.opcode.name,\n      pc: event.pc,\n      stack,\n      storage: null\n    };\n\n    // The gas difference calculated for each step is indicative of gas consumed in\n    // the previous step. Gas consumption in the final step will always be zero.\n    if (returnVal.structLogs.length) {\n      returnVal.structLogs[returnVal.structLogs.length - 1].gasCost = gasUsedPreviousStep;\n    }\n\n    if (params.disableStorage) {\n      returnVal.structLogs.push(structLog);\n      next();\n    } else {\n      structLog = self.processStorageTrace(structLog, storageStack, event, vm, function(err, structLog) {\n        if (err) {\n          return next(err);\n        }\n        returnVal.structLogs.push(structLog);\n        next();\n      });\n    }\n  }\n\n  // #1 - get block via transaction receipt\n  this.getTransactionReceipt(targetHash, function(err, receipt) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!receipt) {\n      return callback(new Error(\"Unknown transaction \" + targetHash));\n    }\n\n    const targetBlock = receipt.block;\n\n    // Get the parent of the target block\n    self.getBlock(targetBlock.header.parentHash, function(err, parent) {\n      if (err) {\n        return callback(err);\n      }\n\n      // #2 - Set state root of original block\n      var stateTrie = self.createStateTrie(self.data.trie_db, parent.header.stateRoot, {\n        // when forking we need to make sure we also copy over the forkBlockNumber,\n        // otherwise some operations will request data from the main chain at the\n        // latest block\n        forkBlockNumber: to.number(parent.header.number)\n      });\n      vm = self.createVMFromStateTrie(stateTrie);\n\n      // Prepare the \"next\" block with necessary transactions\n      self.createBlock(parent, false, function(err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        // make sure we use the same timestamp as the target block\n        block.header.timestamp = targetBlock.header.timestamp;\n\n        for (var i = 0; i < targetBlock.transactions.length; i++) {\n          var tx = targetBlock.transactions[i];\n          block.transactions.push(tx);\n\n          // After including the target transaction, that's all we need to do.\n          if (to.hex(tx.hash()) === targetHash) {\n            break;\n          }\n        }\n\n        function beforeTxListener(tx) {\n          txCurrentlyProcessing = tx;\n          txHashCurrentlyProcessing = to.hex(tx.hash());\n          if (txHashCurrentlyProcessing === targetHash) {\n            vm.on(\"step\", stepListener);\n          }\n        }\n\n        // afterTxListener cleans up everything.\n        function afterTxListener() {\n          if (txHashCurrentlyProcessing === targetHash) {\n            removeListeners();\n          }\n        }\n\n        function removeListeners() {\n          vm.removeListener(\"step\", stepListener);\n          vm.removeListener(\"beforeTx\", beforeTxListener);\n          vm.removeListener(\"afterTx\", afterTxListener);\n        }\n\n        // Listen to beforeTx and afterTx so we know when our target transaction\n        // is processing. These events will add the event listener for getting the trace data.\n        vm.on(\"beforeTx\", beforeTxListener);\n        vm.on(\"afterTx\", afterTxListener);\n\n        // Don't even let the vm try to flush the block's _cache to the stateTrie.\n        // When forking some of the data that the traced function may request will\n        // exist only on the main chain. Because we pretty much lie to the VM by\n        // telling it we DO have data in our Trie, when we really don't, it gets\n        // lost during the commit phase when it traverses the \"borrowed\" data's\n        // trie (as it may not have a valid root). Because this is a trace, and we\n        // don't need to commit the data, duck punching the `flush` method (the\n        // simplest method I could find) is fine.\n        // Remove this and you may see the infamous\n        // `Uncaught TypeError: Cannot read property 'pop' of undefined` error!\n        vm.stateManager._cache.flush = (cb) => cb();\n\n        // #3 - Process the block without committing the data.\n        self.processBlock(vm, block, false, function(err) {\n          // Ignore runtime errors, or else erroneous transactions can't be traced.\n          if (err && err.message.indexOf(\"VM Exception\") === 0) {\n            err = null;\n          }\n\n          // Just to be safe\n          removeListeners();\n\n          // #4 - send state results back\n          callback(err, returnVal);\n        });\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.processStorageTrace = function(structLog, storageStack, event, vm, callback) {\n  var name = event.opcode.name;\n\n  if (storageStack.currentDepth > event.depth) {\n    storageStack.stack.pop();\n  }\n  if (storageStack.currentDepth < event.depth) {\n    storageStack.stack.push({});\n  }\n\n  storageStack.currentDepth = event.depth;\n\n  var key;\n  var value;\n  switch (name) {\n    case \"SSTORE\":\n      {\n        const stack = event.stack;\n        const stackLength = stack.length;\n        key = to.rpcDataHexString(stack[stackLength - 1], 64).replace(\"0x\", \"\");\n        value = to.rpcDataHexString(stack[stackLength - 2], 64).replace(\"0x\", \"\");\n        // use Object.assign to prevent future steps from overwriting this step's storage values\n        structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n\n        callback(null, structLog);\n        // assign after callback because this storage change actually takes\n        // effect _after_ this opcode executes\n        storageStack.stack[storageStack.currentDepth][key] = value;\n      }\n      break;\n    case \"SLOAD\":\n      {\n        const stack = event.stack;\n        // this one's more fun, we need to get the value the contract is loading from current storage\n        key = to.rpcDataHexString(stack[stack.length - 1], 64).replace(\"0x\", \"\");\n\n        vm.stateManager.getContractStorage(event.address, Buffer.from(key, \"hex\"), function(err, result) {\n          if (err) {\n            return callback(err);\n          }\n\n          value = to.rpcDataHexString(result, 64).replace(\"0x\", \"\");\n          storageStack.stack[storageStack.currentDepth][key] = value;\n          // use Object.assign to prevent future steps from overwriting this step's storage values\n          structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n          callback(null, structLog);\n        });\n      }\n      break;\n    default:\n      // use Object.assign to prevent future steps from overwriting this step's storage values\n      structLog.storage = Object.assign({}, storageStack.stack[storageStack.currentDepth]);\n      callback(null, structLog);\n  }\n};\n\nBlockchainDouble.prototype.getAccount = function(address, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      // Finally, put the stateRoot back for good\n      trie.root = currentStateRoot;\n\n      if (err) {\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      callback(null, account);\n    });\n  });\n};\n\nBlockchainDouble.prototype.getNonce = function(address, number, callback) {\n  this.getAccount(address, number, function(err, account) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, account.nonce);\n  });\n};\n\nBlockchainDouble.prototype.getBalance = function(address, number, callback) {\n  this.getAccount(address, number, function(err, account) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, account.balance);\n  });\n};\n\n// Note! Storage values are returned RLP encoded!\nBlockchainDouble.prototype.getStorage = function(address, position, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      trie.root = account.stateRoot;\n\n      trie.get(utils.setLengthLeft(utils.toBuffer(position), 32), function(err, value) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err != null) {\n          return callback(err);\n        }\n\n        callback(null, value);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getCode = function(address, number, callback) {\n  var self = this;\n\n  this.getBlock(number, function(err, block) {\n    if (err) {\n      return callback(err);\n    }\n\n    var trie = self.stateTrie;\n\n    // Manipulate the state root in place to maintain checkpoints\n    var currentStateRoot = trie.root;\n    self.stateTrie.root = block.header.stateRoot;\n\n    trie.get(utils.toBuffer(address), function(err, data) {\n      if (err != null) {\n        // Put the stateRoot back if there's an error\n        trie.root = currentStateRoot;\n        return callback(err);\n      }\n\n      var account = new Account(data);\n\n      account.getCode(trie, function(err, code) {\n        // Finally, put the stateRoot back for good\n        trie.root = currentStateRoot;\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, code);\n      });\n    });\n  });\n};\n\nBlockchainDouble.prototype.getTransaction = function(hash, callback) {\n  hash = to.hex(hash);\n\n  this.data.transactions.get(hash, function(err, tx) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n    callback(null, tx);\n  });\n};\n\nBlockchainDouble.prototype.getTransactionReceipt = function(hash, callback) {\n  hash = to.hex(hash);\n  const pendingTxs = this.pending_transactions;\n\n  for (var i = 0; i < pendingTxs.length; i++) {\n    const pendingTxHash = to.hex(pendingTxs[i].hash());\n    if (hash === pendingTxHash) {\n      return callback(null, { tx: pendingTxs[i] });\n    }\n  }\n\n  this.data.transactionReceipts.get(hash, function(err, receipt) {\n    if (err) {\n      if (err.notFound) {\n        return callback(null, null);\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback(err, receipt);\n  });\n};\n\nBlockchainDouble.prototype.getBlockLogs = function(number, callback) {\n  var self = this;\n  this.getEffectiveBlockNumber(number, function(err, effective) {\n    if (err) {\n      return callback(err);\n    }\n    self.data.blockLogs.get(effective, callback);\n  });\n};\n\nBlockchainDouble.prototype.getHeight = function(callback) {\n  this.data.blocks.length(function(err, length) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, length - 1);\n  });\n};\n\nBlockchainDouble.prototype.currentTime = function() {\n  return ((new Date().getTime() / 1000) | 0) + this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.increaseTime = function(seconds) {\n  if (seconds < 0) {\n    seconds = 0;\n  }\n  this.timeAdjustment += seconds;\n  return this.timeAdjustment;\n};\n\nBlockchainDouble.prototype.setTime = function(date) {\n  var now = (new Date().getTime() / 1000) | 0;\n  var start = (date.getTime() / 1000) | 0;\n  this.timeAdjustment = start - now;\n};\n\nBlockchainDouble.prototype.close = function(callback) {\n  this.data.close(callback);\n};\n\nmodule.exports = BlockchainDouble;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
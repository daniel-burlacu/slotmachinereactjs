{"ast":null,"code":"\"use strict\"; // Using a unique object to compare by reference.\n\nvar traverseDocOnExitStackMarker = {};\n\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  var docsStack = [doc];\n\n  while (docsStack.length !== 0) {\n    var _doc = docsStack.pop();\n\n    if (_doc === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n\n    var shouldRecurse = true;\n\n    if (onEnter) {\n      if (onEnter(_doc) === false) {\n        shouldRecurse = false;\n      }\n    }\n\n    if (onExit) {\n      docsStack.push(_doc);\n      docsStack.push(traverseDocOnExitStackMarker);\n    }\n\n    if (shouldRecurse) {\n      // When there are multiple parts to process,\n      // the parts need to be pushed onto the stack in reverse order,\n      // so that they are processed in the original order\n      // when the stack is popped.\n      if (_doc.type === \"concat\" || _doc.type === \"fill\") {\n        for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(_doc.parts[i]);\n        }\n      } else if (_doc.type === \"if-break\") {\n        if (_doc.flatContents) {\n          docsStack.push(_doc.flatContents);\n        }\n\n        if (_doc.breakContents) {\n          docsStack.push(_doc.breakContents);\n        }\n      } else if (_doc.type === \"group\" && _doc.expandedStates) {\n        if (shouldTraverseConditionalGroups) {\n          for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {\n            docsStack.push(_doc.expandedStates[_i]);\n          }\n        } else {\n          docsStack.push(_doc.contents);\n        }\n      } else if (_doc.contents) {\n        docsStack.push(_doc.contents);\n      }\n    }\n  }\n}\n\nfunction mapDoc(doc, cb) {\n  if (doc.type === \"concat\" || doc.type === \"fill\") {\n    var parts = doc.parts.map(function (part) {\n      return mapDoc(part, cb);\n    });\n    return cb(Object.assign({}, doc, {\n      parts: parts\n    }));\n  } else if (doc.type === \"if-break\") {\n    var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);\n    var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);\n    return cb(Object.assign({}, doc, {\n      breakContents: breakContents,\n      flatContents: flatContents\n    }));\n  } else if (doc.contents) {\n    var contents = mapDoc(doc.contents, cb);\n    return cb(Object.assign({}, doc, {\n      contents: contents\n    }));\n  }\n\n  return cb(doc);\n}\n\nfunction findInDoc(doc, fn, defaultValue) {\n  var result = defaultValue;\n  var hasStopped = false;\n\n  function findInDocOnEnterFn(doc) {\n    var maybeResult = fn(doc);\n\n    if (maybeResult !== undefined) {\n      hasStopped = true;\n      result = maybeResult;\n    }\n\n    if (hasStopped) {\n      return false;\n    }\n  }\n\n  traverseDoc(doc, findInDocOnEnterFn);\n  return result;\n}\n\nfunction isEmpty(n) {\n  return typeof n === \"string\" && n.length === 0;\n}\n\nfunction isLineNextFn(doc) {\n  if (typeof doc === \"string\") {\n    return false;\n  }\n\n  if (doc.type === \"line\") {\n    return true;\n  }\n}\n\nfunction isLineNext(doc) {\n  return findInDoc(doc, isLineNextFn, false);\n}\n\nfunction willBreakFn(doc) {\n  if (doc.type === \"group\" && doc[\"break\"]) {\n    return true;\n  }\n\n  if (doc.type === \"line\" && doc.hard) {\n    return true;\n  }\n\n  if (doc.type === \"break-parent\") {\n    return true;\n  }\n}\n\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\n\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because\n    // the user is expected to manually handle what breaks.\n\n    if (!parentGroup.expandedStates) {\n      parentGroup[\"break\"] = true;\n    }\n  }\n\n  return null;\n}\n\nfunction propagateBreaks(doc) {\n  var alreadyVisitedSet = new Set();\n  var groupStack = [];\n\n  function propagateBreaksOnEnterFn(doc) {\n    if (doc.type === \"break-parent\") {\n      breakParentGroup(groupStack);\n    }\n\n    if (doc.type === \"group\") {\n      groupStack.push(doc);\n\n      if (alreadyVisitedSet.has(doc)) {\n        return false;\n      }\n\n      alreadyVisitedSet.add(doc);\n    }\n  }\n\n  function propagateBreaksOnExitFn(doc) {\n    if (doc.type === \"group\") {\n      var group = groupStack.pop();\n\n      if (group[\"break\"]) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n\n  traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,\n  /* shouldTraverseConditionalGroups */\n  true);\n}\n\nfunction removeLinesFn(doc) {\n  // Force this doc into flat mode by statically converting all\n  // lines into spaces (or soft lines into nothing). Hard lines\n  // should still output because there's too great of a chance\n  // of breaking existing assumptions otherwise.\n  if (doc.type === \"line\" && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  } else if (doc.type === \"if-break\") {\n    return doc.flatContents || \"\";\n  }\n\n  return doc;\n}\n\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\n\nfunction stripTrailingHardline(doc) {\n  // HACK remove ending hardline, original PR: #1984\n  if (doc.type === \"concat\" && doc.parts.length !== 0) {\n    var lastPart = doc.parts[doc.parts.length - 1];\n\n    if (lastPart.type === \"concat\") {\n      if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === \"break-parent\") {\n        return {\n          type: \"concat\",\n          parts: doc.parts.slice(0, -1)\n        };\n      }\n\n      return {\n        type: \"concat\",\n        parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))\n      };\n    }\n  }\n\n  return doc;\n}\n\nmodule.exports = {\n  isEmpty: isEmpty,\n  willBreak: willBreak,\n  isLineNext: isLineNext,\n  traverseDoc: traverseDoc,\n  findInDoc: findInDoc,\n  mapDoc: mapDoc,\n  propagateBreaks: propagateBreaks,\n  removeLines: removeLines,\n  stripTrailingHardline: stripTrailingHardline\n};","map":{"version":3,"names":["traverseDocOnExitStackMarker","traverseDoc","doc","onEnter","onExit","shouldTraverseConditionalGroups","docsStack","length","_doc","pop","shouldRecurse","push","type","ic","parts","i","flatContents","breakContents","expandedStates","_ic","_i","contents","mapDoc","cb","map","part","Object","assign","findInDoc","fn","defaultValue","result","hasStopped","findInDocOnEnterFn","maybeResult","undefined","isEmpty","n","isLineNextFn","isLineNext","willBreakFn","hard","willBreak","breakParentGroup","groupStack","parentGroup","propagateBreaks","alreadyVisitedSet","Set","propagateBreaksOnEnterFn","has","add","propagateBreaksOnExitFn","group","removeLinesFn","soft","removeLines","stripTrailingHardline","lastPart","slice","concat","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/doc/doc-utils.js"],"sourcesContent":["\"use strict\"; // Using a unique object to compare by reference.\n\nvar traverseDocOnExitStackMarker = {};\n\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  var docsStack = [doc];\n\n  while (docsStack.length !== 0) {\n    var _doc = docsStack.pop();\n\n    if (_doc === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n\n    var shouldRecurse = true;\n\n    if (onEnter) {\n      if (onEnter(_doc) === false) {\n        shouldRecurse = false;\n      }\n    }\n\n    if (onExit) {\n      docsStack.push(_doc);\n      docsStack.push(traverseDocOnExitStackMarker);\n    }\n\n    if (shouldRecurse) {\n      // When there are multiple parts to process,\n      // the parts need to be pushed onto the stack in reverse order,\n      // so that they are processed in the original order\n      // when the stack is popped.\n      if (_doc.type === \"concat\" || _doc.type === \"fill\") {\n        for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(_doc.parts[i]);\n        }\n      } else if (_doc.type === \"if-break\") {\n        if (_doc.flatContents) {\n          docsStack.push(_doc.flatContents);\n        }\n\n        if (_doc.breakContents) {\n          docsStack.push(_doc.breakContents);\n        }\n      } else if (_doc.type === \"group\" && _doc.expandedStates) {\n        if (shouldTraverseConditionalGroups) {\n          for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {\n            docsStack.push(_doc.expandedStates[_i]);\n          }\n        } else {\n          docsStack.push(_doc.contents);\n        }\n      } else if (_doc.contents) {\n        docsStack.push(_doc.contents);\n      }\n    }\n  }\n}\n\nfunction mapDoc(doc, cb) {\n  if (doc.type === \"concat\" || doc.type === \"fill\") {\n    var parts = doc.parts.map(function (part) {\n      return mapDoc(part, cb);\n    });\n    return cb(Object.assign({}, doc, {\n      parts: parts\n    }));\n  } else if (doc.type === \"if-break\") {\n    var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);\n    var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);\n    return cb(Object.assign({}, doc, {\n      breakContents: breakContents,\n      flatContents: flatContents\n    }));\n  } else if (doc.contents) {\n    var contents = mapDoc(doc.contents, cb);\n    return cb(Object.assign({}, doc, {\n      contents: contents\n    }));\n  }\n\n  return cb(doc);\n}\n\nfunction findInDoc(doc, fn, defaultValue) {\n  var result = defaultValue;\n  var hasStopped = false;\n\n  function findInDocOnEnterFn(doc) {\n    var maybeResult = fn(doc);\n\n    if (maybeResult !== undefined) {\n      hasStopped = true;\n      result = maybeResult;\n    }\n\n    if (hasStopped) {\n      return false;\n    }\n  }\n\n  traverseDoc(doc, findInDocOnEnterFn);\n  return result;\n}\n\nfunction isEmpty(n) {\n  return typeof n === \"string\" && n.length === 0;\n}\n\nfunction isLineNextFn(doc) {\n  if (typeof doc === \"string\") {\n    return false;\n  }\n\n  if (doc.type === \"line\") {\n    return true;\n  }\n}\n\nfunction isLineNext(doc) {\n  return findInDoc(doc, isLineNextFn, false);\n}\n\nfunction willBreakFn(doc) {\n  if (doc.type === \"group\" && doc[\"break\"]) {\n    return true;\n  }\n\n  if (doc.type === \"line\" && doc.hard) {\n    return true;\n  }\n\n  if (doc.type === \"break-parent\") {\n    return true;\n  }\n}\n\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\n\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because\n    // the user is expected to manually handle what breaks.\n\n    if (!parentGroup.expandedStates) {\n      parentGroup[\"break\"] = true;\n    }\n  }\n\n  return null;\n}\n\nfunction propagateBreaks(doc) {\n  var alreadyVisitedSet = new Set();\n  var groupStack = [];\n\n  function propagateBreaksOnEnterFn(doc) {\n    if (doc.type === \"break-parent\") {\n      breakParentGroup(groupStack);\n    }\n\n    if (doc.type === \"group\") {\n      groupStack.push(doc);\n\n      if (alreadyVisitedSet.has(doc)) {\n        return false;\n      }\n\n      alreadyVisitedSet.add(doc);\n    }\n  }\n\n  function propagateBreaksOnExitFn(doc) {\n    if (doc.type === \"group\") {\n      var group = groupStack.pop();\n\n      if (group[\"break\"]) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n\n  traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,\n  /* shouldTraverseConditionalGroups */\n  true);\n}\n\nfunction removeLinesFn(doc) {\n  // Force this doc into flat mode by statically converting all\n  // lines into spaces (or soft lines into nothing). Hard lines\n  // should still output because there's too great of a chance\n  // of breaking existing assumptions otherwise.\n  if (doc.type === \"line\" && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  } else if (doc.type === \"if-break\") {\n    return doc.flatContents || \"\";\n  }\n\n  return doc;\n}\n\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\n\nfunction stripTrailingHardline(doc) {\n  // HACK remove ending hardline, original PR: #1984\n  if (doc.type === \"concat\" && doc.parts.length !== 0) {\n    var lastPart = doc.parts[doc.parts.length - 1];\n\n    if (lastPart.type === \"concat\") {\n      if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === \"break-parent\") {\n        return {\n          type: \"concat\",\n          parts: doc.parts.slice(0, -1)\n        };\n      }\n\n      return {\n        type: \"concat\",\n        parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))\n      };\n    }\n  }\n\n  return doc;\n}\n\nmodule.exports = {\n  isEmpty: isEmpty,\n  willBreak: willBreak,\n  isLineNext: isLineNext,\n  traverseDoc: traverseDoc,\n  findInDoc: findInDoc,\n  mapDoc: mapDoc,\n  propagateBreaks: propagateBreaks,\n  removeLines: removeLines,\n  stripTrailingHardline: stripTrailingHardline\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
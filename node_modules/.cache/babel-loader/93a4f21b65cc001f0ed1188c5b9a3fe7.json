{"ast":null,"code":"\"use strict\"; // This file is currently named parser-babylon.js to maintain backwards compatibility.\n// However, it should be named parser-babel.js in the next major release.\n\nvar createError = require(\"../common/parser-create-error\");\n\nvar hasPragma = require(\"./pragma\").hasPragma;\n\nvar locFns = require(\"./loc\");\n\nvar postprocess = require(\"./postprocess\");\n\nvar babelParser = require(\"@babel/parser\");\n\nfunction babelOptions(extraOptions, extraPlugins) {\n  return Object.assign({\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(extraPlugins)\n  }, extraOptions);\n}\n\nfunction createParse(parseMethod, extraPlugins) {\n  return function (text, parsers, opts) {\n    // Inline the require to avoid loading all the JS if we don't use it\n    var combinations = [babelOptions({\n      strictMode: true\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: true\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins))];\n    var ast;\n\n    try {\n      ast = tryCombinations(babelParser[parseMethod].bind(null, text), combinations);\n    } catch (error) {\n      throw createError( // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      error.message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: error.loc.line,\n          column: error.loc.column + 1\n        }\n      });\n    }\n\n    delete ast.tokens;\n    return postprocess(ast, Object.assign({}, opts, {\n      originalText: text\n    }));\n  };\n}\n\nvar parse = createParse(\"parse\", [\"flow\"]);\nvar parseFlow = createParse(\"parse\", [[\"flow\", {\n  all: true\n}]]);\nvar parseExpression = createParse(\"parseExpression\");\n\nfunction tryCombinations(fn, combinations) {\n  var error;\n\n  for (var i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  var ast = parseExpression(text, parsers, opts);\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      } // istanbul ignore if\n\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n\n      return [node.key, node.value].forEach(assertJsonChildNode);\n\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n\n        default:\n          throw createJsonError(\"operator\");\n      }\n\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n\n      throw createJsonError();\n\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  } // istanbul ignore next\n\n\n  function createJsonError(attribute) {\n    var name = !attribute ? node.type : \"\".concat(node.type, \" with \").concat(attribute, \"=\").concat(JSON.stringify(node[attribute]));\n    return createError(\"\".concat(name, \" is not allowed in JSON.\"), {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1\n      }\n    });\n  }\n}\n\nvar babel = Object.assign({\n  parse: parse,\n  astFormat: \"estree\",\n  hasPragma: hasPragma\n}, locFns);\nvar babelFlow = Object.assign({}, babel, {\n  parse: parseFlow\n});\nvar babelExpression = Object.assign({}, babel, {\n  parse: parseExpression\n}); // Export as a plugin so we can reuse the same bundle for UMD loading\n\nmodule.exports = {\n  parsers: {\n    babel: babel,\n    \"babel-flow\": babelFlow,\n    // aliased to keep backwards compatibility\n    babylon: babel,\n    json: Object.assign({}, babelExpression, {\n      hasPragma: function hasPragma() {\n        return true;\n      }\n    }),\n    json5: babelExpression,\n    \"json-stringify\": Object.assign({\n      parse: parseJson,\n      astFormat: \"estree-json\"\n    }, locFns),\n\n    /** @internal */\n    __js_expression: babelExpression,\n\n    /** for vue filter */\n    __vue_expression: babelExpression,\n\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel\n  }\n};","map":{"version":3,"names":["createError","require","hasPragma","locFns","postprocess","babelParser","babelOptions","extraOptions","extraPlugins","Object","assign","sourceType","allowAwaitOutsideFunction","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","plugins","proposal","concat","createParse","parseMethod","text","parsers","opts","combinations","strictMode","decoratorsBeforeExport","ast","tryCombinations","bind","error","message","replace","start","line","loc","column","tokens","originalText","parse","parseFlow","all","parseExpression","fn","i","length","_error","parseJson","comments","forEach","assertJsonNode","node","parent","type","elements","assertJsonChildNode","properties","computed","createJsonError","shorthand","key","value","operator","argument","child","attribute","name","JSON","stringify","babel","astFormat","babelFlow","babelExpression","module","exports","babylon","json","json5","__js_expression","__vue_expression","__vue_event_binding"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/language-js/parser-babylon.js"],"sourcesContent":["\"use strict\"; // This file is currently named parser-babylon.js to maintain backwards compatibility.\n// However, it should be named parser-babel.js in the next major release.\n\nvar createError = require(\"../common/parser-create-error\");\n\nvar hasPragma = require(\"./pragma\").hasPragma;\n\nvar locFns = require(\"./loc\");\n\nvar postprocess = require(\"./postprocess\");\n\nvar babelParser = require(\"@babel/parser\");\n\nfunction babelOptions(extraOptions, extraPlugins) {\n  return Object.assign({\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(extraPlugins)\n  }, extraOptions);\n}\n\nfunction createParse(parseMethod, extraPlugins) {\n  return function (text, parsers, opts) {\n    // Inline the require to avoid loading all the JS if we don't use it\n    var combinations = [babelOptions({\n      strictMode: true\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: true\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins))];\n    var ast;\n\n    try {\n      ast = tryCombinations(babelParser[parseMethod].bind(null, text), combinations);\n    } catch (error) {\n      throw createError( // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      error.message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: error.loc.line,\n          column: error.loc.column + 1\n        }\n      });\n    }\n\n    delete ast.tokens;\n    return postprocess(ast, Object.assign({}, opts, {\n      originalText: text\n    }));\n  };\n}\n\nvar parse = createParse(\"parse\", [\"flow\"]);\nvar parseFlow = createParse(\"parse\", [[\"flow\", {\n  all: true\n}]]);\nvar parseExpression = createParse(\"parseExpression\");\n\nfunction tryCombinations(fn, combinations) {\n  var error;\n\n  for (var i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  var ast = parseExpression(text, parsers, opts);\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      } // istanbul ignore if\n\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n\n      return [node.key, node.value].forEach(assertJsonChildNode);\n\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n\n        default:\n          throw createJsonError(\"operator\");\n      }\n\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n\n      throw createJsonError();\n\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  } // istanbul ignore next\n\n\n  function createJsonError(attribute) {\n    var name = !attribute ? node.type : \"\".concat(node.type, \" with \").concat(attribute, \"=\").concat(JSON.stringify(node[attribute]));\n    return createError(\"\".concat(name, \" is not allowed in JSON.\"), {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1\n      }\n    });\n  }\n}\n\nvar babel = Object.assign({\n  parse: parse,\n  astFormat: \"estree\",\n  hasPragma: hasPragma\n}, locFns);\nvar babelFlow = Object.assign({}, babel, {\n  parse: parseFlow\n});\nvar babelExpression = Object.assign({}, babel, {\n  parse: parseExpression\n}); // Export as a plugin so we can reuse the same bundle for UMD loading\n\nmodule.exports = {\n  parsers: {\n    babel: babel,\n    \"babel-flow\": babelFlow,\n    // aliased to keep backwards compatibility\n    babylon: babel,\n    json: Object.assign({}, babelExpression, {\n      hasPragma: function hasPragma() {\n        return true;\n      }\n    }),\n    json5: babelExpression,\n    \"json-stringify\": Object.assign({\n      parse: parseJson,\n      astFormat: \"estree-json\"\n    }, locFns),\n\n    /** @internal */\n    __js_expression: babelExpression,\n\n    /** for vue filter */\n    __vue_expression: babelExpression,\n\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import { useRef as e, useEffect as n, useLayoutEffect as t } from \"react\";\nimport { Subject as r } from \"rxjs\";\nimport o from \"screenfull\";\nimport { jsx as i } from \"react/jsx-runtime\";\nimport { useSpring as s, animated as u } from \"react-spring\";\n\nfunction c() {\n  const t = e(new r());\n  return {\n    useListenToCustomEvent: function (e) {\n      n(() => {\n        const n = t.current.subscribe(e);\n        return () => n.unsubscribe();\n      }, [e]);\n    },\n    emitObservable: e => {\n      t.current.next(e);\n    }\n  };\n}\n\nconst l = \"undefined\" != typeof window ? t : n;\n\nfunction f(n) {\n  const t = e(!1);\n  l(() => {\n    if (!t.current) {\n      const e = n();\n      return t.current = !0, () => {\n        e && e();\n      };\n    }\n  }, []);\n}\n\nfunction a(_ref) {\n  let {\n    mainCarouselWrapperRef: n,\n    emitObservable: t,\n    handleResize: r\n  } = _ref;\n  const i = e(!1);\n\n  function s(e) {\n    i.current = e;\n  }\n\n  return f(() => {\n    function e() {\n      document.fullscreenElement && (s(!0), t({\n        eventName: \"onFullscreenChange\",\n        isFullscreen: !0\n      }), r && r()), document.fullscreenElement || (s(!1), t({\n        eventName: \"onFullscreenChange\",\n        isFullscreen: !1\n      }), r && r());\n    }\n\n    if (o.isEnabled) return o.on(\"change\", e), () => {\n      o.isEnabled && o.off(\"change\", e);\n    };\n  }), {\n    enterFullscreen: function (e) {\n      o.isEnabled && o.request(e || n.current);\n    },\n    exitFullscreen: function () {\n      o.isEnabled && o.exit();\n    },\n    getIsFullscreen: function () {\n      return i.current;\n    }\n  };\n}\n\nfunction m(_ref2) {\n  let {\n    items: n,\n    withThumbs: t,\n    thumbsSlideAxis: r = \"x\",\n    springConfig: o,\n    prepareThumbsData: c,\n    getFluidWrapperScrollValue: l = () => 0,\n    getSlideValue: a = () => 0,\n    slideType: m\n  } = _ref2;\n  const h = e(null),\n        [p, d] = s(() => ({\n    x: 0,\n    y: 0,\n    config: o,\n    onChange: _ref3 => {\n      let {\n        value: e\n      } = _ref3;\n      h.current && \"fluid\" === m && (h.current[\"x\" === r ? \"scrollLeft\" : \"scrollTop\"] = Math.abs(e[r]));\n    }\n  }));\n\n  function b() {\n    return h.current[\"x\" === r ? \"scrollLeft\" : \"scrollTop\"];\n  }\n\n  function g() {\n    var e;\n    return Math.round(Number(null === (e = h.current) || void 0 === e ? void 0 : e[\"x\" === r ? \"scrollWidth\" : \"scrollHeight\"]) - h.current.getBoundingClientRect()[\"x\" === r ? \"width\" : \"height\"]);\n  }\n\n  function x() {\n    const e = Math.round(l() / a());\n    return g() / e;\n  }\n\n  f(() => {\n    if (t && !h.current) throw new Error(\"The thumbs wrapper is not defined. If you've passed a Functional component, be sure to wrap your component in forwardRef.\");\n  });\n  return {\n    thumbsFragment: t ? i(u.div, Object.assign({\n      ref: h,\n      className: \"use-spring-carousel-thumbs-wrapper\",\n      onWheel: () => {\n        p[r].stop();\n      },\n      style: Object.assign({\n        display: \"flex\",\n        flex: 1,\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n        flexDirection: \"x\" === r ? \"row\" : \"column\"\n      }, \"x\" === r ? {\n        overflowX: \"auto\"\n      } : {\n        overflowY: \"auto\",\n        maxHeight: \"100%\"\n      })\n    }, {\n      children: function () {\n        function e(e) {\n          return e.map(e => ({\n            id: e.id,\n            renderThumb: e.renderThumb\n          }));\n        }\n\n        return c ? c(e(n)) : e(n);\n      }().map(_ref4 => {\n        let {\n          id: e,\n          renderThumb: n\n        } = _ref4;\n        const t = `thumb-${e}`;\n        return i(\"div\", Object.assign({\n          id: t,\n          className: \"thumb-item\"\n        }, {\n          children: n\n        }), t);\n      })\n    })) : null,\n    handleThumbsScroll: function (e, t) {\n      if (\"fluid\" === m) {\n        const e = g();\n\n        if (\"next\" === t) {\n          const n = b() + x();\n          d.start({\n            from: {\n              [r]: b()\n            },\n            to: {\n              [r]: n > e ? e : n\n            }\n          });\n        }\n\n        if (\"prev\" === t) {\n          const e = b() - x();\n          d.start({\n            from: {\n              [r]: b()\n            },\n            to: {\n              [r]: e < 0 ? 0 : e\n            }\n          });\n        }\n      } else {\n        const o = h.current.querySelector(`#thumb-${n[e].id}`);\n\n        if (o) {\n          const i = h.current,\n                s = \"x\" === r ? \"offsetWidth\" : \"offsetHeight\",\n                u = \"x\" === r ? \"scrollLeft\" : \"scrollTop\",\n                c = function (_ref5) {\n            let {\n              thumbNode: e,\n              offsetDirection: n,\n              offsetDimension: t\n            } = _ref5;\n            return e[n] + e[t] / 2;\n          }({\n            thumbNode: o,\n            offsetDimension: s,\n            offsetDirection: \"x\" === r ? \"offsetLeft\" : \"offsetTop\"\n          }),\n                l = function (_ref6) {\n            let {\n              thumbWrapper: e,\n              offsetDimension: n\n            } = _ref6;\n            return e[n] / 2;\n          }({\n            thumbWrapper: i,\n            offsetDimension: s\n          }),\n                f = function (_ref7) {\n            let {\n              thumbWrapper: e,\n              scrollDirection: n\n            } = _ref7;\n            return e[n];\n          }({\n            thumbWrapper: i,\n            scrollDirection: u\n          }),\n                a = function (_ref8) {\n            let {\n              thumbWrapper: t,\n              thumbOffsetPosition: o,\n              thumbScrollDimension: i,\n              offsetDimension: s\n            } = _ref8;\n            const u = \"x\" === r ? \"scrollWidth\" : \"scrollHeight\";\n            return e === n.length - 1 || o - i > t[u] - t[s] ? t[u] - t[s] : 0 === e ? 0 : o - i;\n          }({\n            thumbWrapper: i,\n            thumbOffsetPosition: c,\n            thumbScrollDimension: l,\n            offsetDimension: s\n          });\n\n          d.start({\n            from: {\n              [r]: f\n            },\n            to: {\n              [r]: \"prev\" === t && a < 0 ? 0 : a\n            },\n            onChange: _ref9 => {\n              let {\n                value: e\n              } = _ref9;\n              \"x\" === r ? h.current.scrollLeft = e.x : h.current.scrollTop = e.y;\n            }\n          });\n        }\n      }\n    }\n  };\n}\n\nexport { c as a, a as b, m as c, f as d, l as u };","map":{"version":3,"mappings":"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","names":["useCustomEventsModule","eventsObserverRef","useRef","Subject","useListenToCustomEvent","fn","useEffect","subscribe","current","unsubscribe","emitObservable","data","next","useIsomorphicLayoutEffect","window","useLayoutEffect","useIsomorphicMount","callback","isMounted","clean","useFullscreenModule","handleResize","mainCarouselWrapperRef","isFullscreen","setIsFullscreen","_isFullscreen","handleFullscreenChange","document","fullscreenElement","eventName","screenfull","isEnabled","on","off","enterFullscreen","elementRef","request","exitFullscreen","exit","getIsFullscreen","useThumbsModule","slideType","items","withThumbs","thumbsSlideAxis","springConfig","prepareThumbsData","getFluidWrapperScrollValue","getSlideValue","internalThumbsWrapperRef","thumbListStyles","setThumbListStyles","useSpring","x","y","config","onChange","value","Math","abs","getCurrentThumbScrollValue","getThumbsTotalScrollableValue","round","Number","getBoundingClientRect","getThumbSlideValue","thumbSlideTotal","Error","thumbsFragment","_jsx","animated","div","ref","className","onWheel","stop","style","display","flex","position","width","height","flexDirection","overflowX","overflowY","maxHeight","children","getPreparedItems","_items","map","i","id","renderThumb","handlePrepareThumbsData","thumbId","handleThumbsScroll","activeItem","actionType","totalScrollableValue","nextValue","start","from","[object Object]","to","thumbNode","querySelector","thumbWrapper","offsetDimension","scrollDirection","thumbOffsetPosition","offsetDirection","getThumbOffsetPosition","thumbScrollDimension","getThumbScrollDimension","fromValue","getScrollFromValue","toValue","scrollDimensionProperty","length","getScrollToValue","scrollLeft","scrollTop"],"sources":["F:\\Games\\PFPRacerNFTProject\\slotmachinereact\\node_modules\\react-spring-carousel\\src\\modules\\useCustomEventsModule.tsx","F:\\Games\\PFPRacerNFTProject\\slotmachinereact\\node_modules\\react-spring-carousel\\src\\utils.ts","F:\\Games\\PFPRacerNFTProject\\slotmachinereact\\node_modules\\react-spring-carousel\\src\\modules\\useFullscreenModule.tsx","F:\\Games\\PFPRacerNFTProject\\slotmachinereact\\node_modules\\react-spring-carousel\\src\\modules\\useThumbsModule.tsx"],"sourcesContent":["import { useEffect, useRef } from 'react'\nimport { Subject } from 'rxjs'\nimport {\n  UseSpringCarouselEventsObservableProps,\n  UseTransitionCarouselEventsObservableProps,\n  ObservableCallbackFn,\n  EmitObservableFn,\n} from '../types'\n\nexport function useCustomEventsModule<T>() {\n  const eventsObserverRef = useRef(\n    new Subject<\n      T extends 'use-spring'\n        ? UseSpringCarouselEventsObservableProps\n        : UseTransitionCarouselEventsObservableProps\n    >(),\n  )\n\n  function useListenToCustomEvent(fn: ObservableCallbackFn<T>) {\n    useEffect(() => {\n      const subscribe = eventsObserverRef.current.subscribe(fn)\n      return () => subscribe.unsubscribe()\n    }, [fn])\n  }\n\n  const emitObservable: EmitObservableFn<T> = data => {\n    eventsObserverRef.current.next(data)\n  }\n\n  return {\n    useListenToCustomEvent,\n    emitObservable,\n  }\n}\n","import { useRef, useLayoutEffect, useEffect } from 'react'\n\ntype Callback = () => void | (() => void)\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nfunction useIsomorphicMount(callback: Callback) {\n  const isMounted = useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!isMounted.current) {\n      const clean = callback()\n      isMounted.current = true\n\n      return () => {\n        clean && clean()\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n}\n\nexport { useIsomorphicLayoutEffect, useIsomorphicMount }\n","import { useRef, MutableRefObject } from 'react'\nimport screenfull from 'screenfull'\nimport { EmitObservableFn } from '../types'\nimport { useIsomorphicMount } from '../utils'\n\ntype FullscreenModule<T> = {\n  mainCarouselWrapperRef: MutableRefObject<HTMLDivElement | null>\n  emitObservable: EmitObservableFn<T>\n  handleResize?(): void\n}\n\nexport function useFullscreenModule<T>({\n  mainCarouselWrapperRef,\n  emitObservable,\n  handleResize,\n}: FullscreenModule<T>) {\n  const isFullscreen = useRef(false)\n\n  useIsomorphicMount(() => {\n    function handleFullscreenChange() {\n      if (document.fullscreenElement) {\n        setIsFullscreen(true)\n        emitObservable({\n          eventName: 'onFullscreenChange',\n          isFullscreen: true,\n        })\n\n        handleResize && handleResize()\n      }\n\n      if (!document.fullscreenElement) {\n        setIsFullscreen(false)\n        emitObservable({\n          eventName: 'onFullscreenChange',\n          isFullscreen: false,\n        })\n        handleResize && handleResize()\n      }\n    }\n\n    if (screenfull.isEnabled) {\n      screenfull.on('change', handleFullscreenChange)\n      return () => {\n        if (screenfull.isEnabled) {\n          screenfull.off('change', handleFullscreenChange)\n        }\n      }\n    }\n  })\n\n  function setIsFullscreen(_isFullscreen: boolean) {\n    isFullscreen.current = _isFullscreen\n  }\n\n  function getIsFullscreen() {\n    return isFullscreen.current\n  }\n\n  function enterFullscreen(elementRef?: HTMLElement) {\n    if (screenfull.isEnabled) {\n      screenfull.request((elementRef || mainCarouselWrapperRef.current) as Element)\n    }\n  }\n\n  function exitFullscreen() {\n    screenfull.isEnabled && screenfull.exit()\n  }\n\n  return {\n    enterFullscreen,\n    exitFullscreen,\n    getIsFullscreen,\n  }\n}\n","import { useRef } from 'react'\nimport { useSpring, SpringConfig, animated } from 'react-spring'\nimport { useIsomorphicMount } from 'src/utils'\nimport { UseSpringCarouselProps, SlideActionType } from '../types'\nimport { ReactSpringCarouselItemWithThumbs } from '../types/useSpringCarousel'\nimport { PrepareThumbsData } from '../types/index'\n\ntype OffsetDimension = 'offsetWidth' | 'offsetHeight'\ntype OffsetDirection = 'offsetLeft' | 'offsetTop'\ntype ScrollDirection = 'scrollLeft' | 'scrollTop'\n\ntype Props = {\n  items: ReactSpringCarouselItemWithThumbs[]\n  withThumbs: boolean\n  slideType: UseSpringCarouselProps['slideType']\n  thumbsSlideAxis: UseSpringCarouselProps['thumbsSlideAxis']\n  springConfig: SpringConfig\n  prepareThumbsData?: UseSpringCarouselProps['prepareThumbsData']\n  getFluidWrapperScrollValue?(): number\n  getSlideValue?(): number\n}\n\nexport function useThumbsModule({\n  items,\n  withThumbs,\n  thumbsSlideAxis = 'x',\n  springConfig,\n  prepareThumbsData,\n  getFluidWrapperScrollValue = () => 0,\n  getSlideValue = () => 0,\n  slideType,\n}: Props) {\n  const internalThumbsWrapperRef = useRef<HTMLDivElement | null>(null)\n  const [thumbListStyles, setThumbListStyles] = useSpring(() => ({\n    x: 0,\n    y: 0,\n    config: springConfig,\n    onChange: ({ value }) => {\n      if (internalThumbsWrapperRef.current && slideType === 'fluid') {\n        internalThumbsWrapperRef.current[\n          thumbsSlideAxis === 'x' ? 'scrollLeft' : 'scrollTop'\n        ] = Math.abs(value[thumbsSlideAxis])\n      }\n    },\n  }))\n\n  useIsomorphicMount(() => {\n    if (withThumbs && !internalThumbsWrapperRef.current) {\n      throw new Error(\n        \"The thumbs wrapper is not defined. If you've passed a Functional component, be sure to wrap your component in forwardRef.\",\n      )\n    }\n  })\n\n  function getCurrentThumbScrollValue() {\n    return internalThumbsWrapperRef.current![\n      thumbsSlideAxis === 'x' ? 'scrollLeft' : 'scrollTop'\n    ]\n  }\n  function getThumbsTotalScrollableValue() {\n    return Math.round(\n      Number(\n        internalThumbsWrapperRef.current?.[\n          thumbsSlideAxis === 'x' ? 'scrollWidth' : 'scrollHeight'\n        ],\n      ) -\n        internalThumbsWrapperRef.current!.getBoundingClientRect()[\n          thumbsSlideAxis === 'x' ? 'width' : 'height'\n        ],\n    )\n  }\n\n  function getThumbSlideValue() {\n    const thumbSlideTotal = Math.round(getFluidWrapperScrollValue() / getSlideValue())\n    const totalScrollableValue = getThumbsTotalScrollableValue()\n    return totalScrollableValue / thumbSlideTotal\n  }\n\n  function handleThumbsScroll(activeItem: number, actionType?: SlideActionType) {\n    if (slideType === 'fluid') {\n      const totalScrollableValue = getThumbsTotalScrollableValue()\n\n      if (actionType === 'next') {\n        const nextValue = getCurrentThumbScrollValue() + getThumbSlideValue()\n        setThumbListStyles.start({\n          from: {\n            [thumbsSlideAxis]: getCurrentThumbScrollValue(),\n          },\n          to: {\n            [thumbsSlideAxis]:\n              nextValue > totalScrollableValue ? totalScrollableValue : nextValue,\n          },\n        })\n      }\n      if (actionType === 'prev') {\n        const nextValue = getCurrentThumbScrollValue() - getThumbSlideValue()\n        setThumbListStyles.start({\n          from: {\n            [thumbsSlideAxis]: getCurrentThumbScrollValue(),\n          },\n          to: {\n            [thumbsSlideAxis]: nextValue < 0 ? 0 : nextValue,\n          },\n        })\n      }\n    } else {\n      function getOffsetDirection() {\n        return thumbsSlideAxis === 'x' ? 'offsetLeft' : 'offsetTop'\n      }\n      function getOffsetDimension() {\n        return thumbsSlideAxis === 'x' ? 'offsetWidth' : 'offsetHeight'\n      }\n      function getScrollDirecton() {\n        return thumbsSlideAxis === 'x' ? 'scrollLeft' : 'scrollTop'\n      }\n      function getThumbNode() {\n        return internalThumbsWrapperRef.current!.querySelector(\n          `#thumb-${items[activeItem].id}`,\n        ) as HTMLElement\n      }\n      function getThumbOffsetPosition({\n        thumbNode,\n        offsetDirection,\n        offsetDimension,\n      }: {\n        thumbNode: HTMLElement\n        offsetDirection: OffsetDirection\n        offsetDimension: OffsetDimension\n      }) {\n        return thumbNode[offsetDirection] + thumbNode[offsetDimension] / 2\n      }\n      function getThumbScrollDimension({\n        thumbWrapper,\n        offsetDimension,\n      }: {\n        thumbWrapper: HTMLDivElement\n        offsetDimension: OffsetDimension\n      }) {\n        return thumbWrapper[offsetDimension] / 2\n      }\n      function getScrollFromValue({\n        thumbWrapper,\n        scrollDirection,\n      }: {\n        thumbWrapper: HTMLDivElement\n        scrollDirection: ScrollDirection\n      }) {\n        return thumbWrapper[scrollDirection]\n      }\n      function getScrollToValue({\n        thumbWrapper,\n        thumbOffsetPosition,\n        thumbScrollDimension,\n        offsetDimension,\n      }: {\n        thumbWrapper: HTMLDivElement\n        thumbOffsetPosition: number\n        thumbScrollDimension: number\n        offsetDimension: OffsetDimension\n      }) {\n        const scrollDimensionProperty =\n          thumbsSlideAxis === 'x' ? 'scrollWidth' : 'scrollHeight'\n\n        if (\n          activeItem === items.length - 1 ||\n          thumbOffsetPosition - thumbScrollDimension >\n            thumbWrapper[scrollDimensionProperty] - thumbWrapper[offsetDimension]\n        ) {\n          return thumbWrapper[scrollDimensionProperty] - thumbWrapper[offsetDimension]\n        }\n        if (activeItem === 0) {\n          return 0\n        }\n\n        return thumbOffsetPosition - thumbScrollDimension\n      }\n\n      const thumbNode = getThumbNode()\n\n      if (thumbNode) {\n        const thumbWrapper = internalThumbsWrapperRef.current!\n        const offsetDirection = getOffsetDirection()\n        const offsetDimension = getOffsetDimension()\n        const scrollDirection = getScrollDirecton()\n        const thumbOffsetPosition = getThumbOffsetPosition({\n          thumbNode,\n          offsetDimension,\n          offsetDirection,\n        })\n        const thumbScrollDimension = getThumbScrollDimension({\n          thumbWrapper,\n          offsetDimension,\n        })\n\n        const fromValue = getScrollFromValue({\n          thumbWrapper,\n          scrollDirection,\n        })\n        const toValue = getScrollToValue({\n          thumbWrapper,\n          thumbOffsetPosition,\n          thumbScrollDimension,\n          offsetDimension,\n        })\n\n        setThumbListStyles.start({\n          from: {\n            [thumbsSlideAxis]: fromValue,\n          },\n          to: {\n            [thumbsSlideAxis]: actionType === 'prev' && toValue < 0 ? 0 : toValue,\n          },\n          onChange: ({ value }) => {\n            if (thumbsSlideAxis === 'x') {\n              internalThumbsWrapperRef!.current!.scrollLeft = value.x\n            } else {\n              internalThumbsWrapperRef!.current!.scrollTop = value.y\n            }\n          },\n        })\n      }\n    }\n  }\n  function handlePrepareThumbsData() {\n    function getPreparedItems(\n      _items: ReturnType<PrepareThumbsData>,\n    ): ReturnType<PrepareThumbsData> {\n      return _items.map(i => ({\n        id: i.id,\n        renderThumb: i.renderThumb,\n      }))\n    }\n\n    if (prepareThumbsData) {\n      return prepareThumbsData(getPreparedItems(items))\n    }\n    return getPreparedItems(items)\n  }\n\n  const thumbsFragment = withThumbs ? (\n    <animated.div\n      ref={internalThumbsWrapperRef}\n      className=\"use-spring-carousel-thumbs-wrapper\"\n      onWheel={() => {\n        thumbListStyles[thumbsSlideAxis].stop()\n      }}\n      style={{\n        display: 'flex',\n        flex: 1,\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        flexDirection: thumbsSlideAxis === 'x' ? 'row' : 'column',\n        ...(thumbsSlideAxis === 'x'\n          ? { overflowX: 'auto' }\n          : {\n              overflowY: 'auto',\n              maxHeight: '100%',\n            }),\n      }}\n    >\n      {handlePrepareThumbsData().map(({ id, renderThumb }) => {\n        const thumbId = `thumb-${id}`\n        return (\n          <div key={thumbId} id={thumbId} className=\"thumb-item\">\n            {renderThumb}\n          </div>\n        )\n      })}\n    </animated.div>\n  ) : null\n\n  return {\n    thumbsFragment,\n    handleThumbsScroll,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
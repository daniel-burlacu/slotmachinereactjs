{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeSpdxLicenceIdentifiers = exports.flattenSingleFile = exports.flattenAndSave = exports.flattenProject = void 0;\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst mkdirp_1 = __importDefault(require(\"mkdirp\"));\n\nconst config_1 = require(\"./config\");\n\nconst imports_fs_1 = require(\"@resolver-engine/imports-fs\");\n\nconst imports_1 = require(\"@resolver-engine/imports\");\n\nconst findInputs_1 = require(\"./findInputs\");\n\nconst utils_1 = require(\"./utils\");\n\nasync function flattenProject(configPath) {\n  await flattenAndSave(await config_1.loadConfig(configPath));\n}\n\nexports.flattenProject = flattenProject;\n\nasync function flattenAndSave(input) {\n  const config = config_1.inputToConfig(input);\n  const output = await getContractDependency(config);\n  await saveToFile(output, config);\n}\n\nexports.flattenAndSave = flattenAndSave;\n\nconst getFileName = rootContract => path_1.default.parse(rootContract.url).base;\n\nconst getFilePath = (fileName, outputDirectory) => path_1.default.join(outputDirectory, fileName);\n\nasync function flattenSingleFile(input, name) {\n  const config = config_1.inputToConfig(input);\n  const output = await getContractDependency(config);\n  const contract = output.find(contracts => getFileName(contracts[contracts.length - 1]) === name);\n\n  if (!contract) {\n    return null;\n  }\n\n  return getFlattenedSource(contract, '').sourceWithNormalizedLicences;\n}\n\nexports.flattenSingleFile = flattenSingleFile;\n\nasync function getContractDependency(config) {\n  const resolver = imports_fs_1.ImportsFsEngine().addResolver(imports_fs_1.resolvers.BacktrackFsResolver(config.nodeModulesDirectory));\n  const allContracts = findInputs_1.findInputs(config.sourceDirectory, utils_1.getExtensionForCompilerType(config));\n  return Promise.all(allContracts.map(async contract => imports_1.gatherSourcesAndCanonizeImports([contract], '.', resolver)));\n}\n\nconst fsOps = {\n  createDirectory: mkdirp_1.default.sync,\n  writeFile: fs_1.default.writeFileSync\n};\n\nconst unique = arr => [...new Set(arr)];\n\nfunction getFlattenedSource(contract, outputDirectory) {\n  const rootContract = contract[contract.length - 1];\n  const fileName = getFileName(rootContract);\n  const filePath = getFilePath(fileName, outputDirectory);\n  const contractsWithCommentedDirectives = contract.map(replaceDirectivesWithComments(rootContract));\n  const source = ''.concat(...unique(contractsWithCommentedDirectives));\n  const sourceWithNormalizedLicences = normalizeSpdxLicenceIdentifiers(source, fileName);\n  return {\n    filePath,\n    sourceWithNormalizedLicences\n  };\n}\n\nfunction saveToFile(output, config) {\n  let fileSystem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsOps;\n  const outputDirectory = config.flattenOutputDirectory;\n  fileSystem.createDirectory(outputDirectory);\n  output.map(contract => {\n    const {\n      filePath,\n      sourceWithNormalizedLicences\n    } = getFlattenedSource(contract, outputDirectory);\n    fileSystem.writeFile(filePath, sourceWithNormalizedLicences);\n  });\n}\n\nfunction replaceDirectivesWithComments(rootContract) {\n  const IMPORT_SOLIDITY_REGEX = /^[ \\t]*import[^=]+?$/gm;\n  const IMPORT_NODE_MODULES_REGEX = /(import.*\").*node_modules\\/(.*\\n)/gi;\n  const PRAGMA_SOLIDITY_REGEX = /pragma solidity/gi;\n  const NODE_MODULES_REGEX = /^.*\\/node_modules\\//gi;\n  return dependency => {\n    const sourceWithImportsWithRelativeImports = dependency.source.replace(IMPORT_NODE_MODULES_REGEX, '$1$2');\n    const sourceWithCommentedImports = sourceWithImportsWithRelativeImports.replace(IMPORT_SOLIDITY_REGEX, '// $&');\n    const filePath = dependency.url.replace(NODE_MODULES_REGEX, '');\n\n    if (dependency === rootContract) {\n      return `// Root file: ${filePath}\\n\\n` + sourceWithCommentedImports;\n    }\n\n    const sourceWithCommentedPragmas = sourceWithCommentedImports.replace(PRAGMA_SOLIDITY_REGEX, '// pragma solidity');\n    return `// Dependency file: ${filePath}\\n\\n` + sourceWithCommentedPragmas + '\\n\\n';\n  };\n}\n\nfunction findUniqueLicences(flattenContracts) {\n  const LICENCE_REGEX = /^\\s*\\/\\/\\s*SPDX-License-Identifier:(.*)$/mg;\n  const licences = new Set();\n  let match;\n\n  while (true) {\n    match = LICENCE_REGEX.exec(flattenContracts);\n\n    if (!match) {\n      break;\n    }\n\n    licences.add(match[1].trim());\n  }\n\n  return [...licences];\n}\n\nfunction normalizeSpdxLicenceIdentifiers(flattenContracts, contractName) {\n  const LICENCE_REGEX = /^\\s*\\/\\/\\s*SPDX-License-Identifier:(.*)$/mg;\n  const uniqueLicences = findUniqueLicences(flattenContracts);\n\n  if (uniqueLicences.length > 1) {\n    console.warn(`WARNING contract ${contractName}: multiple licences found: ${uniqueLicences.join(', ')}.\n  Solidity compiler does not allow more than one licence. Licence selected: ${uniqueLicences}\n    `);\n  }\n\n  const firstLicence = LICENCE_REGEX.exec(flattenContracts);\n\n  if (!firstLicence) {\n    return flattenContracts;\n  }\n\n  const normalizedContract = flattenContracts.replace(LICENCE_REGEX, '');\n  return utils_1.insert(normalizedContract, firstLicence[0], firstLicence.index);\n}\n\nexports.normalizeSpdxLicenceIdentifiers = normalizeSpdxLicenceIdentifiers;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","normalizeSpdxLicenceIdentifiers","flattenSingleFile","flattenAndSave","flattenProject","fs_1","require","path_1","mkdirp_1","config_1","imports_fs_1","imports_1","findInputs_1","utils_1","configPath","loadConfig","input","config","inputToConfig","output","getContractDependency","saveToFile","getFileName","rootContract","default","parse","url","base","getFilePath","fileName","outputDirectory","join","name","contract","find","contracts","length","getFlattenedSource","sourceWithNormalizedLicences","resolver","ImportsFsEngine","addResolver","resolvers","BacktrackFsResolver","nodeModulesDirectory","allContracts","findInputs","sourceDirectory","getExtensionForCompilerType","Promise","all","map","gatherSourcesAndCanonizeImports","fsOps","createDirectory","sync","writeFile","writeFileSync","unique","arr","Set","filePath","contractsWithCommentedDirectives","replaceDirectivesWithComments","source","concat","fileSystem","flattenOutputDirectory","IMPORT_SOLIDITY_REGEX","IMPORT_NODE_MODULES_REGEX","PRAGMA_SOLIDITY_REGEX","NODE_MODULES_REGEX","dependency","sourceWithImportsWithRelativeImports","replace","sourceWithCommentedImports","sourceWithCommentedPragmas","findUniqueLicences","flattenContracts","LICENCE_REGEX","licences","match","exec","add","trim","contractName","uniqueLicences","console","warn","firstLicence","normalizedContract","insert","index"],"sources":["F:/Games/slotmachinereact/node_modules/@ethereum-waffle/compiler/dist/cjs/flattener.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeSpdxLicenceIdentifiers = exports.flattenSingleFile = exports.flattenAndSave = exports.flattenProject = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst mkdirp_1 = __importDefault(require(\"mkdirp\"));\nconst config_1 = require(\"./config\");\nconst imports_fs_1 = require(\"@resolver-engine/imports-fs\");\nconst imports_1 = require(\"@resolver-engine/imports\");\nconst findInputs_1 = require(\"./findInputs\");\nconst utils_1 = require(\"./utils\");\nasync function flattenProject(configPath) {\n    await flattenAndSave(await config_1.loadConfig(configPath));\n}\nexports.flattenProject = flattenProject;\nasync function flattenAndSave(input) {\n    const config = config_1.inputToConfig(input);\n    const output = await getContractDependency(config);\n    await saveToFile(output, config);\n}\nexports.flattenAndSave = flattenAndSave;\nconst getFileName = (rootContract) => path_1.default.parse(rootContract.url).base;\nconst getFilePath = (fileName, outputDirectory) => path_1.default.join(outputDirectory, fileName);\nasync function flattenSingleFile(input, name) {\n    const config = config_1.inputToConfig(input);\n    const output = await getContractDependency(config);\n    const contract = output.find((contracts) => getFileName(contracts[contracts.length - 1]) === name);\n    if (!contract) {\n        return null;\n    }\n    return getFlattenedSource(contract, '').sourceWithNormalizedLicences;\n}\nexports.flattenSingleFile = flattenSingleFile;\nasync function getContractDependency(config) {\n    const resolver = imports_fs_1.ImportsFsEngine().addResolver(imports_fs_1.resolvers.BacktrackFsResolver(config.nodeModulesDirectory));\n    const allContracts = findInputs_1.findInputs(config.sourceDirectory, utils_1.getExtensionForCompilerType(config));\n    return Promise.all(allContracts.map(async (contract) => imports_1.gatherSourcesAndCanonizeImports([contract], '.', resolver)));\n}\nconst fsOps = {\n    createDirectory: mkdirp_1.default.sync,\n    writeFile: fs_1.default.writeFileSync\n};\nconst unique = (arr) => [...new Set(arr)];\nfunction getFlattenedSource(contract, outputDirectory) {\n    const rootContract = contract[contract.length - 1];\n    const fileName = getFileName(rootContract);\n    const filePath = getFilePath(fileName, outputDirectory);\n    const contractsWithCommentedDirectives = contract.map(replaceDirectivesWithComments(rootContract));\n    const source = ''.concat(...unique(contractsWithCommentedDirectives));\n    const sourceWithNormalizedLicences = normalizeSpdxLicenceIdentifiers(source, fileName);\n    return { filePath, sourceWithNormalizedLicences };\n}\nfunction saveToFile(output, config, fileSystem = fsOps) {\n    const outputDirectory = config.flattenOutputDirectory;\n    fileSystem.createDirectory(outputDirectory);\n    output.map((contract) => {\n        const { filePath, sourceWithNormalizedLicences } = getFlattenedSource(contract, outputDirectory);\n        fileSystem.writeFile(filePath, sourceWithNormalizedLicences);\n    });\n}\nfunction replaceDirectivesWithComments(rootContract) {\n    const IMPORT_SOLIDITY_REGEX = /^[ \\t]*import[^=]+?$/gm;\n    const IMPORT_NODE_MODULES_REGEX = /(import.*\").*node_modules\\/(.*\\n)/gi;\n    const PRAGMA_SOLIDITY_REGEX = /pragma solidity/gi;\n    const NODE_MODULES_REGEX = /^.*\\/node_modules\\//gi;\n    return (dependency) => {\n        const sourceWithImportsWithRelativeImports = dependency.source.replace(IMPORT_NODE_MODULES_REGEX, '$1$2');\n        const sourceWithCommentedImports = sourceWithImportsWithRelativeImports.replace(IMPORT_SOLIDITY_REGEX, '// $&');\n        const filePath = dependency.url.replace(NODE_MODULES_REGEX, '');\n        if (dependency === rootContract) {\n            return `// Root file: ${filePath}\\n\\n` + sourceWithCommentedImports;\n        }\n        const sourceWithCommentedPragmas = sourceWithCommentedImports.replace(PRAGMA_SOLIDITY_REGEX, '// pragma solidity');\n        return `// Dependency file: ${filePath}\\n\\n` + sourceWithCommentedPragmas + '\\n\\n';\n    };\n}\nfunction findUniqueLicences(flattenContracts) {\n    const LICENCE_REGEX = /^\\s*\\/\\/\\s*SPDX-License-Identifier:(.*)$/mg;\n    const licences = new Set();\n    let match;\n    while (true) {\n        match = LICENCE_REGEX.exec(flattenContracts);\n        if (!match) {\n            break;\n        }\n        licences.add(match[1].trim());\n    }\n    return [...licences];\n}\nfunction normalizeSpdxLicenceIdentifiers(flattenContracts, contractName) {\n    const LICENCE_REGEX = /^\\s*\\/\\/\\s*SPDX-License-Identifier:(.*)$/mg;\n    const uniqueLicences = findUniqueLicences(flattenContracts);\n    if (uniqueLicences.length > 1) {\n        console.warn(`WARNING contract ${contractName}: multiple licences found: ${uniqueLicences.join(', ')}.\n  Solidity compiler does not allow more than one licence. Licence selected: ${uniqueLicences}\n    `);\n    }\n    const firstLicence = LICENCE_REGEX.exec(flattenContracts);\n    if (!firstLicence) {\n        return flattenContracts;\n    }\n    const normalizedContract = flattenContracts.replace(LICENCE_REGEX, '');\n    return utils_1.insert(normalizedContract, firstLicence[0], firstLicence.index);\n}\nexports.normalizeSpdxLicenceIdentifiers = normalizeSpdxLicenceIdentifiers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nconst JSX_SOURCE_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);\n\nconst set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction createPlugin(_ref) {\n  let {\n    name,\n    development\n  } = _ref;\n  return (0, _helperPluginUtils.declare)((api, options) => {\n    const {\n      pure: PURE_ANNOTATION,\n      throwIfNamespace = true,\n      filter,\n      runtime: RUNTIME_DEFAULT = development ? \"automatic\" : \"classic\",\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n    } = options;\n    {\n      var {\n        useSpread = false,\n        useBuiltIns = false\n      } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    const injectMetaPropertiesVisitor = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n\n        if (isThisAllowed(path.scope)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n\n    };\n    return {\n      name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n\n        Program: {\n          enter(path, state) {\n            const {\n              file\n            } = state;\n            let runtime = RUNTIME_DEFAULT;\n            let source = IMPORT_SOURCE_DEFAULT;\n            let pragma = PRAGMA_DEFAULT;\n            let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", () => _core.types.cloneNode(createElement));\n              set(state, \"id/fragment\", () => _core.types.cloneNode(fragment));\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n              }\n\n              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n\n        },\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n\n        JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n\n      }\n    };\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(scope) {\n      do {\n        const {\n          path\n        } = scope;\n\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            return true;\n          }\n\n          if (path.node.kind !== \"constructor\") {\n            return true;\n          }\n\n          return !isDerivedClass(path.parentPath.parentPath);\n        }\n\n        if (path.isTSModuleBlock()) {\n          return false;\n        }\n      } while (scope = scope.parent);\n\n      return true;\n    }\n\n    function call(pass, name, args) {\n      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n      let seenPropsSpread = false;\n\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      const value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      let childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      const args = [getTag(openingPath)];\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n          const {\n            name\n          } = attr.node.name;\n\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n\n            case \"key\":\n              {\n                const keyValue = convertAttributeValue(attr.node.value);\n\n                if (keyValue === null) {\n                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                }\n\n                extracted[name] = keyValue;\n                break;\n              }\n\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      let attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, children) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function buildCreateElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\")), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function getTag(openingPath) {\n      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      let tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      const runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (props.length > start) {\n              objs.push(_core.types.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(_core.types.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            return objs[0];\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      const props = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n        if (runtime === \"automatic\" && (name === \"__source\" || name === \"__self\")) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return () => {\n      const actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, `imports/${importName}`, reference);\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n\n        if (reference) {\n          reference = _core.types.cloneNode(reference);\n        } else {\n          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return _core.types.memberExpression(reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n}\n\nfunction makeSource(path, state) {\n  const location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    const {\n      filename = \"\"\n    } = state;\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  const fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  const lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  const columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","createPlugin","_pluginSyntaxJsx","require","_helperPluginUtils","_core","_helperModuleImports","_helperAnnotateAsPure","DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","development","declare","api","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","types","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXElement","exit","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","node","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","properties","spreadElement","booleanLiteral","isStringLiteral","_value$extra","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","_extracted$key","_extracted$__source","_extracted$__self","key","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isIdentifier","isLiteral","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","hub","getScope","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","fileNameProperty","lineNumberProperty","columnNumberProperty","pluginName"],"sources":["F:/Games/slotmachinereact/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nconst JSX_SOURCE_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);\n\nconst set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction createPlugin({\n  name,\n  development\n}) {\n  return (0, _helperPluginUtils.declare)((api, options) => {\n    const {\n      pure: PURE_ANNOTATION,\n      throwIfNamespace = true,\n      filter,\n      runtime: RUNTIME_DEFAULT = development ? \"automatic\" : \"classic\",\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n    } = options;\n    {\n      var {\n        useSpread = false,\n        useBuiltIns = false\n      } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    const injectMetaPropertiesVisitor = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n\n        if (isThisAllowed(path.scope)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n\n    };\n    return {\n      name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n\n        Program: {\n          enter(path, state) {\n            const {\n              file\n            } = state;\n            let runtime = RUNTIME_DEFAULT;\n            let source = IMPORT_SOURCE_DEFAULT;\n            let pragma = PRAGMA_DEFAULT;\n            let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", () => _core.types.cloneNode(createElement));\n              set(state, \"id/fragment\", () => _core.types.cloneNode(fragment));\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n              }\n\n              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n\n        },\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n\n        JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n\n      }\n    };\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(scope) {\n      do {\n        const {\n          path\n        } = scope;\n\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            return true;\n          }\n\n          if (path.node.kind !== \"constructor\") {\n            return true;\n          }\n\n          return !isDerivedClass(path.parentPath.parentPath);\n        }\n\n        if (path.isTSModuleBlock()) {\n          return false;\n        }\n      } while (scope = scope.parent);\n\n      return true;\n    }\n\n    function call(pass, name, args) {\n      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n      let seenPropsSpread = false;\n\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      const value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      let childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      const args = [getTag(openingPath)];\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n          const {\n            name\n          } = attr.node.name;\n\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n\n            case \"key\":\n              {\n                const keyValue = convertAttributeValue(attr.node.value);\n\n                if (keyValue === null) {\n                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                }\n\n                extracted[name] = keyValue;\n                break;\n              }\n\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      let attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, children) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function buildCreateElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\")), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function getTag(openingPath) {\n      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      let tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      const runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (props.length > start) {\n              objs.push(_core.types.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(_core.types.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            return objs[0];\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      const props = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n        if (runtime === \"automatic\" && (name === \"__source\" || name === \"__self\")) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return () => {\n      const actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, `imports/${importName}`, reference);\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n\n        if (reference) {\n          reference = _core.types.cloneNode(reference);\n        } else {\n          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return _core.types.memberExpression(reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n}\n\nfunction makeSource(path, state) {\n  const location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    const {\n      filename = \"\"\n    } = state;\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  const fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  const lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  const columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}
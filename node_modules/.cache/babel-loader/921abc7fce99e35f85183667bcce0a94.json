{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst debug = debug_1.default(\"resolverengine:main\");\nconst UNKNOWN_RESOLVER = \"unknown\";\n\nclass ResolverEngine {\n  constructor(options) {\n    this.resolvers = [];\n    this.parsers = [];\n    const opts = Object.assign({}, options);\n\n    if (opts.debug) {\n      debug_1.default.enable(\"resolverengine:*\");\n    }\n  } // Takes a simplified name (URI) and converts into cannonical URL of the location\n\n\n  resolve(uri, workingDir) {\n    return __awaiter(this, void 0, void 0, function* () {\n      debug(`Resolving \"${uri}\"`);\n      const ctx = {\n        cwd: workingDir,\n        resolver: UNKNOWN_RESOLVER\n      };\n      const result = yield utils_1.firstResult(this.resolvers, resolver => resolver(uri, ctx));\n\n      if (result === null) {\n        throw resolverError(uri);\n      }\n\n      debug(`Resolved \"${uri}\" into \"${result}\"`);\n      return result.result;\n    });\n  }\n\n  require(uri, workingDir) {\n    return __awaiter(this, void 0, void 0, function* () {\n      debug(`Requiring \"${uri}\"`);\n      const ctx = {\n        resolver: UNKNOWN_RESOLVER,\n        cwd: workingDir\n      };\n      const url = yield utils_1.firstResult(this.resolvers, currentResolver => currentResolver(uri, ctx));\n\n      if (url === null) {\n        throw resolverError(uri);\n      } // Through the context we extract information about execution details like the resolver that actually succeeded\n\n\n      const resolver = this.resolvers[url.index];\n      const name = typeof resolver === \"function\" ? resolver.name : resolver.toString();\n      ctx.resolver = name;\n      const result = yield utils_1.firstResult(this.parsers, parser => parser(url.result, ctx));\n\n      if (result === null) {\n        throw parserError(uri);\n      }\n\n      return result.result;\n    });\n  }\n\n  addResolver(resolver) {\n    this.resolvers.push(resolver);\n    return this;\n  }\n\n  addParser(parser) {\n    this.parsers.push(parser);\n    return this;\n  }\n\n}\n\nexports.ResolverEngine = ResolverEngine;\n\nconst resolverError = uri => new Error(`None of the sub-resolvers resolved \"${uri}\" location.`);\n\nconst parserError = uri => new Error(`None of the sub-parsers resolved \"${uri}\" into data. Please confirm your configuration.`);","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAIA;;AAEA,MAAMA,KAAK,GAAGC,gBAAM,qBAAN,CAAd;AAEA,MAAMC,gBAAgB,GAAG,SAAzB;;AAMA,MAAaC,cAAb,CAA2B;EAIzBC,YAAYC,OAAZ,EAA6B;IAHrB,iBAA2B,EAA3B;IACA,eAA+B,EAA/B;IAGN,MAAMC,IAAI,qBAAiBD,OAAjB,CAAV;;IACA,IAAIC,IAAI,CAACN,KAAT,EAAgB;MACdC,gBAAMM,MAAN,CAAa,kBAAb;IACD;EACF,CATwB,CAWzB;;;EACaC,OAAO,CAACC,GAAD,EAAcC,UAAd,EAAiC;;MACnDV,KAAK,CAAC,cAAcS,GAAG,GAAlB,CAAL;MAEA,MAAME,GAAG,GAAY;QACnBC,GAAG,EAAEF,UADc;QAEnBG,QAAQ,EAAEX;MAFS,CAArB;MAKA,MAAMY,MAAM,GAAG,MAAMC,oBAAY,KAAKC,SAAjB,EAA4BH,QAAQ,IAAIA,QAAQ,CAACJ,GAAD,EAAME,GAAN,CAAhD,CAArB;;MAEA,IAAIG,MAAM,KAAK,IAAf,EAAqB;QACnB,MAAMG,aAAa,CAACR,GAAD,CAAnB;MACD;;MAEDT,KAAK,CAAC,aAAaS,GAAG,WAAWK,MAAM,GAAlC,CAAL;MAEA,OAAOA,MAAM,CAACA,MAAd;IACD;EAAA;;EAEYI,OAAO,CAACT,GAAD,EAAcC,UAAd,EAAiC;;MACnDV,KAAK,CAAC,cAAcS,GAAG,GAAlB,CAAL;MAEA,MAAME,GAAG,GAAY;QACnBE,QAAQ,EAAEX,gBADS;QAEnBU,GAAG,EAAEF;MAFc,CAArB;MAKA,MAAMS,GAAG,GAAG,MAAMJ,oBAAY,KAAKC,SAAjB,EAA4BI,eAAe,IAAIA,eAAe,CAACX,GAAD,EAAME,GAAN,CAA9D,CAAlB;;MAEA,IAAIQ,GAAG,KAAK,IAAZ,EAAkB;QAChB,MAAMF,aAAa,CAACR,GAAD,CAAnB;MACD,EAED;;;MACA,MAAMI,QAAQ,GAAQ,KAAKG,SAAL,CAAeG,GAAG,CAACE,KAAnB,CAAtB;MACA,MAAMC,IAAI,GAAG,OAAOT,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,CAACS,IAA1C,GAAiDT,QAAQ,CAACU,QAAT,EAA9D;MACAZ,GAAG,CAACE,QAAJ,GAAeS,IAAf;MAEA,MAAMR,MAAM,GAAG,MAAMC,oBAAY,KAAKS,OAAjB,EAA0BC,MAAM,IAAIA,MAAM,CAACN,GAAG,CAACL,MAAL,EAAaH,GAAb,CAA1C,CAArB;;MAEA,IAAIG,MAAM,KAAK,IAAf,EAAqB;QACnB,MAAMY,WAAW,CAACjB,GAAD,CAAjB;MACD;;MAED,OAAOK,MAAM,CAACA,MAAd;IACD;EAAA;;EAEMa,WAAW,CAACd,QAAD,EAAsB;IACtC,KAAKG,SAAL,CAAeY,IAAf,CAAoBf,QAApB;IACA,OAAO,IAAP;EACD;;EAEMgB,SAAS,CAACJ,MAAD,EAAqB;IACnC,KAAKD,OAAL,CAAaI,IAAb,CAAkBH,MAAlB;IACA,OAAO,IAAP;EACD;;AAnEwB;;AAA3BK;;AAsEA,MAAMb,aAAa,GAAIR,GAAD,IAAiB,IAAIsB,KAAJ,CAAU,uCAAuCtB,GAAG,aAApD,CAAvC;;AACA,MAAMiB,WAAW,GAAIjB,GAAD,IAClB,IAAIsB,KAAJ,CAAU,qCAAqCtB,GAAG,iDAAlD,CADF","names":["debug","debug_1","UNKNOWN_RESOLVER","ResolverEngine","constructor","options","opts","enable","resolve","uri","workingDir","ctx","cwd","resolver","result","utils_1","resolvers","resolverError","require","url","currentResolver","index","name","toString","parsers","parser","parserError","addResolver","push","addParser","exports","Error"],"sources":["F:\\Games\\slotmachinereact\\node_modules\\@resolver-engine\\core\\src\\resolverengine.ts"],"sourcesContent":["import Debug from \"debug\";\nimport { Context } from \"./context\";\nimport { SubParser } from \"./parsers/subparser\";\nimport { SubResolver } from \"./resolvers/subresolver\";\nimport { firstResult } from \"./utils\";\n\nconst debug = Debug(\"resolverengine:main\");\n\nconst UNKNOWN_RESOLVER = \"unknown\";\n\nexport interface Options {\n  debug?: true;\n}\n\nexport class ResolverEngine<R> {\n  private resolvers: SubResolver[] = [];\n  private parsers: Array<SubParser<R>> = [];\n\n  constructor(options?: Options) {\n    const opts: Options = { ...options };\n    if (opts.debug) {\n      Debug.enable(\"resolverengine:*\");\n    }\n  }\n\n  // Takes a simplified name (URI) and converts into cannonical URL of the location\n  public async resolve(uri: string, workingDir?: string): Promise<string> {\n    debug(`Resolving \"${uri}\"`);\n\n    const ctx: Context = {\n      cwd: workingDir,\n      resolver: UNKNOWN_RESOLVER,\n    };\n\n    const result = await firstResult(this.resolvers, resolver => resolver(uri, ctx));\n\n    if (result === null) {\n      throw resolverError(uri);\n    }\n\n    debug(`Resolved \"${uri}\" into \"${result}\"`);\n\n    return result.result;\n  }\n\n  public async require(uri: string, workingDir?: string): Promise<R> {\n    debug(`Requiring \"${uri}\"`);\n\n    const ctx: Context = {\n      resolver: UNKNOWN_RESOLVER,\n      cwd: workingDir,\n    };\n\n    const url = await firstResult(this.resolvers, currentResolver => currentResolver(uri, ctx));\n\n    if (url === null) {\n      throw resolverError(uri);\n    }\n\n    // Through the context we extract information about execution details like the resolver that actually succeeded\n    const resolver: any = this.resolvers[url.index];\n    const name = typeof resolver === \"function\" ? resolver.name : resolver.toString();\n    ctx.resolver = name;\n\n    const result = await firstResult(this.parsers, parser => parser(url.result, ctx));\n\n    if (result === null) {\n      throw parserError(uri);\n    }\n\n    return result.result;\n  }\n\n  public addResolver(resolver: SubResolver): ResolverEngine<R> {\n    this.resolvers.push(resolver);\n    return this;\n  }\n\n  public addParser(parser: SubParser<R>): ResolverEngine<R> {\n    this.parsers.push(parser);\n    return this;\n  }\n}\n\nconst resolverError = (uri: string) => new Error(`None of the sub-resolvers resolved \"${uri}\" location.`);\nconst parserError = (uri: string) =>\n  new Error(`None of the sub-parsers resolved \"${uri}\" into data. Please confirm your configuration.`);\n"]},"metadata":{},"sourceType":"script"}
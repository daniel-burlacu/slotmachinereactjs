{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = require(\"../common/util\"),\n    getStringWidth = _require.getStringWidth;\n\nvar _require2 = require(\"../common/end-of-line\"),\n    convertEndOfLineToChars = _require2.convertEndOfLineToChars;\n\nvar _require3 = require(\"./doc-builders\"),\n    concat = _require3.concat,\n    fill = _require3.fill,\n    cursor = _require3.cursor;\n/** @type {{[groupId: PropertyKey]: MODE}} */\n\n\nvar groupModeMap;\nvar MODE_BREAK = 1;\nvar MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\n\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\n\nfunction makeAlign(ind, n, options) {\n  return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {\n    type: \"dedent\"\n  }, options) : !n ? ind : n.type === \"root\" ? Object.assign({}, ind, {\n    root: ind\n  }) : typeof n === \"string\" ? generateInd(ind, {\n    type: \"stringAlign\",\n    n: n\n  }, options) : generateInd(ind, {\n    type: \"numberAlign\",\n    n: n\n  }, options);\n}\n\nfunction generateInd(ind, newPart, options) {\n  var queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);\n  var value = \"\";\n  var length = 0;\n  var lastTabs = 0;\n  var lastSpaces = 0;\n\n  var _iterator = _createForOfIteratorHelper(queue),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n\n      switch (part.type) {\n        case \"indent\":\n          flush();\n\n          if (options.useTabs) {\n            addTabs(1);\n          } else {\n            addSpaces(options.tabWidth);\n          }\n\n          break;\n\n        case \"stringAlign\":\n          flush();\n          value += part.n;\n          length += part.n.length;\n          break;\n\n        case \"numberAlign\":\n          lastTabs += 1;\n          lastSpaces += part.n;\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  flushSpaces();\n  return Object.assign({}, ind, {\n    value: value,\n    length: length,\n    queue: queue\n  });\n\n  function addTabs(count) {\n    value += \"\\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n\n    resetLast();\n  }\n\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n\n    resetLast();\n  }\n\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\n\nfunction trim(out) {\n  if (out.length === 0) {\n    return 0;\n  }\n\n  var trimCount = 0; // Trim whitespace at the end of line\n\n  while (out.length > 0 && typeof out[out.length - 1] === \"string\" && out[out.length - 1].match(/^[ \\t]*$/)) {\n    trimCount += out.pop().length;\n  }\n\n  if (out.length && typeof out[out.length - 1] === \"string\") {\n    var trimmed = out[out.length - 1].replace(/[ \\t]*$/, \"\");\n    trimCount += out[out.length - 1].length - trimmed.length;\n    out[out.length - 1] = trimmed;\n  }\n\n  return trimCount;\n}\n\nfunction fits(next, restCommands, width, options, mustBeFlat) {\n  var restIdx = restCommands.length;\n  var cmds = [next]; // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n  var out = [];\n\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n\n      cmds.push(restCommands[restIdx - 1]);\n      restIdx--;\n      continue;\n    }\n\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n      width -= getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n          break;\n\n        case \"trim\":\n          width += trim(out);\n          break;\n\n        case \"group\":\n          if (mustBeFlat && doc[\"break\"]) {\n            return false;\n          }\n\n          cmds.push([ind, doc[\"break\"] ? MODE_BREAK : mode, doc.contents]);\n\n          if (doc.id) {\n            groupModeMap[doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n\n        case \"fill\":\n          for (var _i = doc.parts.length - 1; _i >= 0; _i--) {\n            cmds.push([ind, mode, doc.parts[_i]]);\n          }\n\n          break;\n\n        case \"if-break\":\n          {\n            var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (doc.breakContents) {\n                cmds.push([ind, mode, doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (doc.flatContents) {\n                cmds.push([ind, mode, doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n                  width -= 1;\n                }\n\n                break;\n              }\n\n              return true;\n\n            case MODE_BREAK:\n              return true;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  groupModeMap = {};\n  var width = options.printWidth;\n  var newLine = convertEndOfLineToChars(options.endOfLine);\n  var pos = 0; // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n  var cmds = [[rootIndent(), MODE_BREAK, doc]];\n  var out = [];\n  var shouldRemeasure = false;\n  var lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var _doc = x[2];\n\n    if (typeof _doc === \"string\") {\n      out.push(_doc);\n      pos += getStringWidth(_doc);\n    } else {\n      switch (_doc.type) {\n        case \"cursor\":\n          out.push(cursor.placeholder);\n          break;\n\n        case \"concat\":\n          for (var i = _doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, _doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, _doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);\n          break;\n\n        case \"trim\":\n          pos -= trim(out);\n          break;\n\n        case \"group\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([ind, _doc[\"break\"] ? MODE_BREAK : MODE_FLAT, _doc.contents]);\n                break;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              {\n                shouldRemeasure = false;\n                var next = [ind, MODE_FLAT, _doc.contents];\n                var rem = width - pos;\n\n                if (!_doc[\"break\"] && fits(next, cmds, rem, options)) {\n                  cmds.push(next);\n                } else {\n                  // Expanded states are a rare case where a document\n                  // can manually provide multiple representations of\n                  // itself. It provides an array of documents\n                  // going from the least expanded (most flattened)\n                  // representation first to the most expanded. If a\n                  // group has these, we need to manually go through\n                  // these states and find the first one that fits.\n                  if (_doc.expandedStates) {\n                    var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];\n\n                    if (_doc[\"break\"]) {\n                      cmds.push([ind, MODE_BREAK, mostExpanded]);\n                      break;\n                    } else {\n                      for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {\n                        if (_i2 >= _doc.expandedStates.length) {\n                          cmds.push([ind, MODE_BREAK, mostExpanded]);\n                          break;\n                        } else {\n                          var state = _doc.expandedStates[_i2];\n                          var cmd = [ind, MODE_FLAT, state];\n\n                          if (fits(cmd, cmds, rem, options)) {\n                            cmds.push(cmd);\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    cmds.push([ind, MODE_BREAK, _doc.contents]);\n                  }\n                }\n\n                break;\n              }\n          }\n\n          if (_doc.id) {\n            groupModeMap[_doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n        case \"fill\":\n          {\n            var _rem = width - pos;\n\n            var parts = _doc.parts;\n\n            if (parts.length === 0) {\n              break;\n            }\n\n            var content = parts[0];\n            var contentFlatCmd = [ind, MODE_FLAT, content];\n            var contentBreakCmd = [ind, MODE_BREAK, content];\n            var contentFits = fits(contentFlatCmd, [], _rem, options, true);\n\n            if (parts.length === 1) {\n              if (contentFits) {\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            }\n\n            var whitespace = parts[1];\n            var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n            var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n            if (parts.length === 2) {\n              if (contentFits) {\n                cmds.push(whitespaceFlatCmd);\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            } // At this point we've handled the first pair (context, separator)\n            // and will create a new fill doc for the rest of the content.\n            // Ideally we wouldn't mutate the array here but coping all the\n            // elements to a new array would make this algorithm quadratic,\n            // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n            parts.splice(0, 2);\n            var remainingCmd = [ind, mode, fill(parts)];\n            var secondContent = parts[0];\n            var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat([content, whitespace, secondContent])];\n            var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);\n\n            if (firstAndSecondContentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceFlatCmd);\n              cmds.push(contentFlatCmd);\n            } else if (contentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentBreakCmd);\n            }\n\n            break;\n          }\n\n        case \"if-break\":\n          {\n            var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (_doc.breakContents) {\n                cmds.push([ind, mode, _doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (_doc.flatContents) {\n                cmds.push([ind, mode, _doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, _doc.contents]);\n          break;\n\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, {\n              type: \"line\",\n              hard: true\n            }]);\n          }\n\n          break;\n\n        case \"line\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!_doc.hard) {\n                if (!_doc.soft) {\n                  out.push(\" \");\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, _doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (_doc.literal) {\n                if (ind.root) {\n                  out.push(newLine, ind.root.value);\n                  pos = ind.root.length;\n                } else {\n                  out.push(newLine);\n                  pos = 0;\n                }\n              } else {\n                pos -= trim(out);\n                out.push(newLine + ind.value);\n                pos = ind.length;\n              }\n\n              break;\n          }\n\n          break;\n\n        default:\n      }\n    }\n  }\n\n  var cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n\n  if (cursorPlaceholderIndex !== -1) {\n    var otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n    var beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\nmodule.exports = {\n  printDocToString: printDocToString\n};","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","_require","require","getStringWidth","_require2","convertEndOfLineToChars","_require3","concat","fill","cursor","groupModeMap","MODE_BREAK","MODE_FLAT","rootIndent","queue","makeIndent","ind","options","generateInd","type","makeAlign","Infinity","root","assign","newPart","lastTabs","lastSpaces","_iterator","_step","part","flush","useTabs","addTabs","addSpaces","tabWidth","Error","flushSpaces","count","repeat","flushTabs","resetLast","trim","out","trimCount","match","pop","trimmed","replace","fits","restCommands","width","mustBeFlat","restIdx","cmds","push","x","mode","doc","parts","contents","id","_i","groupMode","groupId","breakContents","flatContents","hard","soft","printDocToString","printWidth","newLine","endOfLine","pos","shouldRemeasure","lineSuffix","_doc","placeholder","rem","expandedStates","mostExpanded","_i2","state","cmd","_rem","content","contentFlatCmd","contentBreakCmd","contentFits","whitespace","whitespaceFlatCmd","whitespaceBreakCmd","splice","remainingCmd","secondContent","firstAndSecondContentFlatCmd","firstAndSecondContentFits","apply","reverse","literal","cursorPlaceholderIndex","indexOf","otherCursorPlaceholderIndex","beforeCursor","join","aroundCursor","afterCursor","formatted","cursorNodeStart","cursorNodeText","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/doc/doc-printer.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require(\"../common/util\"),\n    getStringWidth = _require.getStringWidth;\n\nvar _require2 = require(\"../common/end-of-line\"),\n    convertEndOfLineToChars = _require2.convertEndOfLineToChars;\n\nvar _require3 = require(\"./doc-builders\"),\n    concat = _require3.concat,\n    fill = _require3.fill,\n    cursor = _require3.cursor;\n/** @type {{[groupId: PropertyKey]: MODE}} */\n\n\nvar groupModeMap;\nvar MODE_BREAK = 1;\nvar MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\n\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\n\nfunction makeAlign(ind, n, options) {\n  return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {\n    type: \"dedent\"\n  }, options) : !n ? ind : n.type === \"root\" ? Object.assign({}, ind, {\n    root: ind\n  }) : typeof n === \"string\" ? generateInd(ind, {\n    type: \"stringAlign\",\n    n: n\n  }, options) : generateInd(ind, {\n    type: \"numberAlign\",\n    n: n\n  }, options);\n}\n\nfunction generateInd(ind, newPart, options) {\n  var queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);\n  var value = \"\";\n  var length = 0;\n  var lastTabs = 0;\n  var lastSpaces = 0;\n\n  var _iterator = _createForOfIteratorHelper(queue),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n\n      switch (part.type) {\n        case \"indent\":\n          flush();\n\n          if (options.useTabs) {\n            addTabs(1);\n          } else {\n            addSpaces(options.tabWidth);\n          }\n\n          break;\n\n        case \"stringAlign\":\n          flush();\n          value += part.n;\n          length += part.n.length;\n          break;\n\n        case \"numberAlign\":\n          lastTabs += 1;\n          lastSpaces += part.n;\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  flushSpaces();\n  return Object.assign({}, ind, {\n    value: value,\n    length: length,\n    queue: queue\n  });\n\n  function addTabs(count) {\n    value += \"\\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n\n    resetLast();\n  }\n\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n\n    resetLast();\n  }\n\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\n\nfunction trim(out) {\n  if (out.length === 0) {\n    return 0;\n  }\n\n  var trimCount = 0; // Trim whitespace at the end of line\n\n  while (out.length > 0 && typeof out[out.length - 1] === \"string\" && out[out.length - 1].match(/^[ \\t]*$/)) {\n    trimCount += out.pop().length;\n  }\n\n  if (out.length && typeof out[out.length - 1] === \"string\") {\n    var trimmed = out[out.length - 1].replace(/[ \\t]*$/, \"\");\n    trimCount += out[out.length - 1].length - trimmed.length;\n    out[out.length - 1] = trimmed;\n  }\n\n  return trimCount;\n}\n\nfunction fits(next, restCommands, width, options, mustBeFlat) {\n  var restIdx = restCommands.length;\n  var cmds = [next]; // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n  var out = [];\n\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n\n      cmds.push(restCommands[restIdx - 1]);\n      restIdx--;\n      continue;\n    }\n\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n      width -= getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (var i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n          break;\n\n        case \"trim\":\n          width += trim(out);\n          break;\n\n        case \"group\":\n          if (mustBeFlat && doc[\"break\"]) {\n            return false;\n          }\n\n          cmds.push([ind, doc[\"break\"] ? MODE_BREAK : mode, doc.contents]);\n\n          if (doc.id) {\n            groupModeMap[doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n\n        case \"fill\":\n          for (var _i = doc.parts.length - 1; _i >= 0; _i--) {\n            cmds.push([ind, mode, doc.parts[_i]]);\n          }\n\n          break;\n\n        case \"if-break\":\n          {\n            var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (doc.breakContents) {\n                cmds.push([ind, mode, doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (doc.flatContents) {\n                cmds.push([ind, mode, doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n                  width -= 1;\n                }\n\n                break;\n              }\n\n              return true;\n\n            case MODE_BREAK:\n              return true;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  groupModeMap = {};\n  var width = options.printWidth;\n  var newLine = convertEndOfLineToChars(options.endOfLine);\n  var pos = 0; // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n  var cmds = [[rootIndent(), MODE_BREAK, doc]];\n  var out = [];\n  var shouldRemeasure = false;\n  var lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    var x = cmds.pop();\n    var ind = x[0];\n    var mode = x[1];\n    var _doc = x[2];\n\n    if (typeof _doc === \"string\") {\n      out.push(_doc);\n      pos += getStringWidth(_doc);\n    } else {\n      switch (_doc.type) {\n        case \"cursor\":\n          out.push(cursor.placeholder);\n          break;\n\n        case \"concat\":\n          for (var i = _doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, _doc.parts[i]]);\n          }\n\n          break;\n\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, _doc.contents]);\n          break;\n\n        case \"align\":\n          cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);\n          break;\n\n        case \"trim\":\n          pos -= trim(out);\n          break;\n\n        case \"group\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([ind, _doc[\"break\"] ? MODE_BREAK : MODE_FLAT, _doc.contents]);\n                break;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              {\n                shouldRemeasure = false;\n                var next = [ind, MODE_FLAT, _doc.contents];\n                var rem = width - pos;\n\n                if (!_doc[\"break\"] && fits(next, cmds, rem, options)) {\n                  cmds.push(next);\n                } else {\n                  // Expanded states are a rare case where a document\n                  // can manually provide multiple representations of\n                  // itself. It provides an array of documents\n                  // going from the least expanded (most flattened)\n                  // representation first to the most expanded. If a\n                  // group has these, we need to manually go through\n                  // these states and find the first one that fits.\n                  if (_doc.expandedStates) {\n                    var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];\n\n                    if (_doc[\"break\"]) {\n                      cmds.push([ind, MODE_BREAK, mostExpanded]);\n                      break;\n                    } else {\n                      for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {\n                        if (_i2 >= _doc.expandedStates.length) {\n                          cmds.push([ind, MODE_BREAK, mostExpanded]);\n                          break;\n                        } else {\n                          var state = _doc.expandedStates[_i2];\n                          var cmd = [ind, MODE_FLAT, state];\n\n                          if (fits(cmd, cmds, rem, options)) {\n                            cmds.push(cmd);\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    cmds.push([ind, MODE_BREAK, _doc.contents]);\n                  }\n                }\n\n                break;\n              }\n          }\n\n          if (_doc.id) {\n            groupModeMap[_doc.id] = cmds[cmds.length - 1][1];\n          }\n\n          break;\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n        case \"fill\":\n          {\n            var _rem = width - pos;\n\n            var parts = _doc.parts;\n\n            if (parts.length === 0) {\n              break;\n            }\n\n            var content = parts[0];\n            var contentFlatCmd = [ind, MODE_FLAT, content];\n            var contentBreakCmd = [ind, MODE_BREAK, content];\n            var contentFits = fits(contentFlatCmd, [], _rem, options, true);\n\n            if (parts.length === 1) {\n              if (contentFits) {\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            }\n\n            var whitespace = parts[1];\n            var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n            var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n            if (parts.length === 2) {\n              if (contentFits) {\n                cmds.push(whitespaceFlatCmd);\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            } // At this point we've handled the first pair (context, separator)\n            // and will create a new fill doc for the rest of the content.\n            // Ideally we wouldn't mutate the array here but coping all the\n            // elements to a new array would make this algorithm quadratic,\n            // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n            parts.splice(0, 2);\n            var remainingCmd = [ind, mode, fill(parts)];\n            var secondContent = parts[0];\n            var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat([content, whitespace, secondContent])];\n            var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);\n\n            if (firstAndSecondContentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceFlatCmd);\n              cmds.push(contentFlatCmd);\n            } else if (contentFits) {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(remainingCmd);\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentBreakCmd);\n            }\n\n            break;\n          }\n\n        case \"if-break\":\n          {\n            var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;\n\n            if (groupMode === MODE_BREAK) {\n              if (_doc.breakContents) {\n                cmds.push([ind, mode, _doc.breakContents]);\n              }\n            }\n\n            if (groupMode === MODE_FLAT) {\n              if (_doc.flatContents) {\n                cmds.push([ind, mode, _doc.flatContents]);\n              }\n            }\n\n            break;\n          }\n\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, _doc.contents]);\n          break;\n\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, {\n              type: \"line\",\n              hard: true\n            }]);\n          }\n\n          break;\n\n        case \"line\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!_doc.hard) {\n                if (!_doc.soft) {\n                  out.push(\" \");\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n\n            // fallthrough\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, _doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (_doc.literal) {\n                if (ind.root) {\n                  out.push(newLine, ind.root.value);\n                  pos = ind.root.length;\n                } else {\n                  out.push(newLine);\n                  pos = 0;\n                }\n              } else {\n                pos -= trim(out);\n                out.push(newLine + ind.value);\n                pos = ind.length;\n              }\n\n              break;\n          }\n\n          break;\n\n        default:\n      }\n    }\n  }\n\n  var cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n\n  if (cursorPlaceholderIndex !== -1) {\n    var otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n    var beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\nmodule.exports = {\n  printDocToString: printDocToString\n};"],"mappings":"AAAA;;AAEA,SAASA,0BAAT,CAAoCC,CAApC,EAAuCC,cAAvC,EAAuD;EAAE,IAAIC,EAAJ;;EAAQ,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCH,CAAC,CAACG,MAAM,CAACC,QAAR,CAAD,IAAsB,IAA3D,EAAiE;IAAE,IAAIC,KAAK,CAACC,OAAN,CAAcN,CAAd,MAAqBE,EAAE,GAAGK,2BAA2B,CAACP,CAAD,CAArD,KAA6DC,cAAc,IAAID,CAAlB,IAAuB,OAAOA,CAAC,CAACQ,MAAT,KAAoB,QAA5G,EAAsH;MAAE,IAAIN,EAAJ,EAAQF,CAAC,GAAGE,EAAJ;MAAQ,IAAIO,CAAC,GAAG,CAAR;;MAAW,IAAIC,CAAC,GAAG,SAASA,CAAT,GAAa,CAAE,CAAvB;;MAAyB,OAAO;QAAEC,CAAC,EAAED,CAAL;QAAQE,CAAC,EAAE,SAASA,CAAT,GAAa;UAAE,IAAIH,CAAC,IAAIT,CAAC,CAACQ,MAAX,EAAmB,OAAO;YAAEK,IAAI,EAAE;UAAR,CAAP;UAAuB,OAAO;YAAEA,IAAI,EAAE,KAAR;YAAeC,KAAK,EAAEd,CAAC,CAACS,CAAC,EAAF;UAAvB,CAAP;QAAwC,CAA5G;QAA8GM,CAAC,EAAE,SAASA,CAAT,CAAWC,EAAX,EAAe;UAAE,MAAMA,EAAN;QAAW,CAA7I;QAA+IC,CAAC,EAAEP;MAAlJ,CAAP;IAA+J;;IAAC,MAAM,IAAIQ,SAAJ,CAAc,uIAAd,CAAN;EAA+J;;EAAC,IAAIC,gBAAgB,GAAG,IAAvB;EAAA,IAA6BC,MAAM,GAAG,KAAtC;EAAA,IAA6CC,GAA7C;EAAkD,OAAO;IAAEV,CAAC,EAAE,SAASA,CAAT,GAAa;MAAET,EAAE,GAAGF,CAAC,CAACG,MAAM,CAACC,QAAR,CAAD,EAAL;IAA4B,CAAhD;IAAkDQ,CAAC,EAAE,SAASA,CAAT,GAAa;MAAE,IAAIU,IAAI,GAAGpB,EAAE,CAACqB,IAAH,EAAX;MAAsBJ,gBAAgB,GAAGG,IAAI,CAACT,IAAxB;MAA8B,OAAOS,IAAP;IAAc,CAAtI;IAAwIP,CAAC,EAAE,SAASA,CAAT,CAAWS,GAAX,EAAgB;MAAEJ,MAAM,GAAG,IAAT;MAAeC,GAAG,GAAGG,GAAN;IAAY,CAAxL;IAA0LP,CAAC,EAAE,SAASA,CAAT,GAAa;MAAE,IAAI;QAAE,IAAI,CAACE,gBAAD,IAAqBjB,EAAE,CAAC,QAAD,CAAF,IAAgB,IAAzC,EAA+CA,EAAE,CAAC,QAAD,CAAF;MAAiB,CAAtE,SAA+E;QAAE,IAAIkB,MAAJ,EAAY,MAAMC,GAAN;MAAY;IAAE;EAAvT,CAAP;AAAmU;;AAEr+B,SAASd,2BAAT,CAAqCP,CAArC,EAAwCyB,MAAxC,EAAgD;EAAE,IAAI,CAACzB,CAAL,EAAQ;EAAQ,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAO0B,iBAAiB,CAAC1B,CAAD,EAAIyB,MAAJ,CAAxB;EAAqC,IAAIb,CAAC,GAAGe,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+B9B,CAA/B,EAAkC+B,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;EAAwD,IAAInB,CAAC,KAAK,QAAN,IAAkBZ,CAAC,CAACgC,WAAxB,EAAqCpB,CAAC,GAAGZ,CAAC,CAACgC,WAAF,CAAcC,IAAlB;EAAwB,IAAIrB,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOP,KAAK,CAAC6B,IAAN,CAAWlC,CAAX,CAAP;EAAsB,IAAIY,CAAC,KAAK,WAAN,IAAqB,2CAA2CuB,IAA3C,CAAgDvB,CAAhD,CAAzB,EAA6E,OAAOc,iBAAiB,CAAC1B,CAAD,EAAIyB,MAAJ,CAAxB;AAAsC;;AAEha,SAASC,iBAAT,CAA2BU,GAA3B,EAAgCC,GAAhC,EAAqC;EAAE,IAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAAC5B,MAA7B,EAAqC6B,GAAG,GAAGD,GAAG,CAAC5B,MAAV;;EAAkB,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAW6B,IAAI,GAAG,IAAIjC,KAAJ,CAAUgC,GAAV,CAAvB,EAAuC5B,CAAC,GAAG4B,GAA3C,EAAgD5B,CAAC,EAAjD,EAAqD;IAAE6B,IAAI,CAAC7B,CAAD,CAAJ,GAAU2B,GAAG,CAAC3B,CAAD,CAAb;EAAmB;;EAAC,OAAO6B,IAAP;AAAc;;AAEvL,IAAIC,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;AAAA,IACIC,cAAc,GAAGF,QAAQ,CAACE,cAD9B;;AAGA,IAAIC,SAAS,GAAGF,OAAO,CAAC,uBAAD,CAAvB;AAAA,IACIG,uBAAuB,GAAGD,SAAS,CAACC,uBADxC;;AAGA,IAAIC,SAAS,GAAGJ,OAAO,CAAC,gBAAD,CAAvB;AAAA,IACIK,MAAM,GAAGD,SAAS,CAACC,MADvB;AAAA,IAEIC,IAAI,GAAGF,SAAS,CAACE,IAFrB;AAAA,IAGIC,MAAM,GAAGH,SAAS,CAACG,MAHvB;AAIA;;;AAGA,IAAIC,YAAJ;AACA,IAAIC,UAAU,GAAG,CAAjB;AACA,IAAIC,SAAS,GAAG,CAAhB;;AAEA,SAASC,UAAT,GAAsB;EACpB,OAAO;IACLrC,KAAK,EAAE,EADF;IAELN,MAAM,EAAE,CAFH;IAGL4C,KAAK,EAAE;EAHF,CAAP;AAKD;;AAED,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkC;EAChC,OAAOC,WAAW,CAACF,GAAD,EAAM;IACtBG,IAAI,EAAE;EADgB,CAAN,EAEfF,OAFe,CAAlB;AAGD;;AAED,SAASG,SAAT,CAAmBJ,GAAnB,EAAwB1C,CAAxB,EAA2B2C,OAA3B,EAAoC;EAClC,OAAO3C,CAAC,KAAK,CAAC+C,QAAP,GAAkBL,GAAG,CAACM,IAAJ,IAAYT,UAAU,EAAxC,GAA6CvC,CAAC,GAAG,CAAJ,GAAQ4C,WAAW,CAACF,GAAD,EAAM;IAC3EG,IAAI,EAAE;EADqE,CAAN,EAEpEF,OAFoE,CAAnB,GAEtC,CAAC3C,CAAD,GAAK0C,GAAL,GAAW1C,CAAC,CAAC6C,IAAF,KAAW,MAAX,GAAoB9B,MAAM,CAACkC,MAAP,CAAc,EAAd,EAAkBP,GAAlB,EAAuB;IAClEM,IAAI,EAAEN;EAD4D,CAAvB,CAApB,GAEpB,OAAO1C,CAAP,KAAa,QAAb,GAAwB4C,WAAW,CAACF,GAAD,EAAM;IAC5CG,IAAI,EAAE,aADsC;IAE5C7C,CAAC,EAAEA;EAFyC,CAAN,EAGrC2C,OAHqC,CAAnC,GAGSC,WAAW,CAACF,GAAD,EAAM;IAC7BG,IAAI,EAAE,aADuB;IAE7B7C,CAAC,EAAEA;EAF0B,CAAN,EAGtB2C,OAHsB,CAPzB;AAWD;;AAED,SAASC,WAAT,CAAqBF,GAArB,EAA0BQ,OAA1B,EAAmCP,OAAnC,EAA4C;EAC1C,IAAIH,KAAK,GAAGU,OAAO,CAACL,IAAR,KAAiB,QAAjB,GAA4BH,GAAG,CAACF,KAAJ,CAAUrB,KAAV,CAAgB,CAAhB,EAAmB,CAAC,CAApB,CAA5B,GAAqDuB,GAAG,CAACF,KAAJ,CAAUP,MAAV,CAAiBiB,OAAjB,CAAjE;EACA,IAAIhD,KAAK,GAAG,EAAZ;EACA,IAAIN,MAAM,GAAG,CAAb;EACA,IAAIuD,QAAQ,GAAG,CAAf;EACA,IAAIC,UAAU,GAAG,CAAjB;;EAEA,IAAIC,SAAS,GAAGlE,0BAA0B,CAACqD,KAAD,CAA1C;EAAA,IACIc,KADJ;;EAGA,IAAI;IACF,KAAKD,SAAS,CAACtD,CAAV,EAAL,EAAoB,CAAC,CAACuD,KAAK,GAAGD,SAAS,CAACrD,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;MAClD,IAAIsD,IAAI,GAAGD,KAAK,CAACpD,KAAjB;;MAEA,QAAQqD,IAAI,CAACV,IAAb;QACE,KAAK,QAAL;UACEW,KAAK;;UAEL,IAAIb,OAAO,CAACc,OAAZ,EAAqB;YACnBC,OAAO,CAAC,CAAD,CAAP;UACD,CAFD,MAEO;YACLC,SAAS,CAAChB,OAAO,CAACiB,QAAT,CAAT;UACD;;UAED;;QAEF,KAAK,aAAL;UACEJ,KAAK;UACLtD,KAAK,IAAIqD,IAAI,CAACvD,CAAd;UACAJ,MAAM,IAAI2D,IAAI,CAACvD,CAAL,CAAOJ,MAAjB;UACA;;QAEF,KAAK,aAAL;UACEuD,QAAQ,IAAI,CAAZ;UACAC,UAAU,IAAIG,IAAI,CAACvD,CAAnB;UACA;;QAEF;;QAEA;UACE,MAAM,IAAI6D,KAAJ,CAAU,oBAAoB5B,MAApB,CAA2BsB,IAAI,CAACV,IAAhC,EAAsC,GAAtC,CAAV,CAAN;MA1BJ;IA4BD;EACF,CAjCD,CAiCE,OAAOpC,GAAP,EAAY;IACZ4C,SAAS,CAAClD,CAAV,CAAYM,GAAZ;EACD,CAnCD,SAmCU;IACR4C,SAAS,CAAChD,CAAV;EACD;;EAEDyD,WAAW;EACX,OAAO/C,MAAM,CAACkC,MAAP,CAAc,EAAd,EAAkBP,GAAlB,EAAuB;IAC5BxC,KAAK,EAAEA,KADqB;IAE5BN,MAAM,EAAEA,MAFoB;IAG5B4C,KAAK,EAAEA;EAHqB,CAAvB,CAAP;;EAMA,SAASkB,OAAT,CAAiBK,KAAjB,EAAwB;IACtB7D,KAAK,IAAI,KAAK8D,MAAL,CAAYD,KAAZ,CAAT;IACAnE,MAAM,IAAI+C,OAAO,CAACiB,QAAR,GAAmBG,KAA7B;EACD;;EAED,SAASJ,SAAT,CAAmBI,KAAnB,EAA0B;IACxB7D,KAAK,IAAI,IAAI8D,MAAJ,CAAWD,KAAX,CAAT;IACAnE,MAAM,IAAImE,KAAV;EACD;;EAED,SAASP,KAAT,GAAiB;IACf,IAAIb,OAAO,CAACc,OAAZ,EAAqB;MACnBQ,SAAS;IACV,CAFD,MAEO;MACLH,WAAW;IACZ;EACF;;EAED,SAASG,SAAT,GAAqB;IACnB,IAAId,QAAQ,GAAG,CAAf,EAAkB;MAChBO,OAAO,CAACP,QAAD,CAAP;IACD;;IAEDe,SAAS;EACV;;EAED,SAASJ,WAAT,GAAuB;IACrB,IAAIV,UAAU,GAAG,CAAjB,EAAoB;MAClBO,SAAS,CAACP,UAAD,CAAT;IACD;;IAEDc,SAAS;EACV;;EAED,SAASA,SAAT,GAAqB;IACnBf,QAAQ,GAAG,CAAX;IACAC,UAAU,GAAG,CAAb;EACD;AACF;;AAED,SAASe,IAAT,CAAcC,GAAd,EAAmB;EACjB,IAAIA,GAAG,CAACxE,MAAJ,KAAe,CAAnB,EAAsB;IACpB,OAAO,CAAP;EACD;;EAED,IAAIyE,SAAS,GAAG,CAAhB,CALiB,CAKE;;EAEnB,OAAOD,GAAG,CAACxE,MAAJ,GAAa,CAAb,IAAkB,OAAOwE,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAV,KAA+B,QAAjD,IAA6DwE,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAH,CAAoB0E,KAApB,CAA0B,UAA1B,CAApE,EAA2G;IACzGD,SAAS,IAAID,GAAG,CAACG,GAAJ,GAAU3E,MAAvB;EACD;;EAED,IAAIwE,GAAG,CAACxE,MAAJ,IAAc,OAAOwE,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAV,KAA+B,QAAjD,EAA2D;IACzD,IAAI4E,OAAO,GAAGJ,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAH,CAAoB6E,OAApB,CAA4B,SAA5B,EAAuC,EAAvC,CAAd;IACAJ,SAAS,IAAID,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAH,CAAoBA,MAApB,GAA6B4E,OAAO,CAAC5E,MAAlD;IACAwE,GAAG,CAACA,GAAG,CAACxE,MAAJ,GAAa,CAAd,CAAH,GAAsB4E,OAAtB;EACD;;EAED,OAAOH,SAAP;AACD;;AAED,SAASK,IAAT,CAAc/D,IAAd,EAAoBgE,YAApB,EAAkCC,KAAlC,EAAyCjC,OAAzC,EAAkDkC,UAAlD,EAA8D;EAC5D,IAAIC,OAAO,GAAGH,YAAY,CAAC/E,MAA3B;EACA,IAAImF,IAAI,GAAG,CAACpE,IAAD,CAAX,CAF4D,CAEzC;EACnB;;EAEA,IAAIyD,GAAG,GAAG,EAAV;;EAEA,OAAOQ,KAAK,IAAI,CAAhB,EAAmB;IACjB,IAAIG,IAAI,CAACnF,MAAL,KAAgB,CAApB,EAAuB;MACrB,IAAIkF,OAAO,KAAK,CAAhB,EAAmB;QACjB,OAAO,IAAP;MACD;;MAEDC,IAAI,CAACC,IAAL,CAAUL,YAAY,CAACG,OAAO,GAAG,CAAX,CAAtB;MACAA,OAAO;MACP;IACD;;IAED,IAAIG,CAAC,GAAGF,IAAI,CAACR,GAAL,EAAR;IACA,IAAI7B,GAAG,GAAGuC,CAAC,CAAC,CAAD,CAAX;IACA,IAAIC,IAAI,GAAGD,CAAC,CAAC,CAAD,CAAZ;IACA,IAAIE,GAAG,GAAGF,CAAC,CAAC,CAAD,CAAX;;IAEA,IAAI,OAAOE,GAAP,KAAe,QAAnB,EAA6B;MAC3Bf,GAAG,CAACY,IAAJ,CAASG,GAAT;MACAP,KAAK,IAAI/C,cAAc,CAACsD,GAAD,CAAvB;IACD,CAHD,MAGO;MACL,QAAQA,GAAG,CAACtC,IAAZ;QACE,KAAK,QAAL;UACE,KAAK,IAAIhD,CAAC,GAAGsF,GAAG,CAACC,KAAJ,CAAUxF,MAAV,GAAmB,CAAhC,EAAmCC,CAAC,IAAI,CAAxC,EAA2CA,CAAC,EAA5C,EAAgD;YAC9CkF,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYC,GAAG,CAACC,KAAJ,CAAUvF,CAAV,CAAZ,CAAV;UACD;;UAED;;QAEF,KAAK,QAAL;UACEkF,IAAI,CAACC,IAAL,CAAU,CAACvC,UAAU,CAACC,GAAD,EAAMC,OAAN,CAAX,EAA2BuC,IAA3B,EAAiCC,GAAG,CAACE,QAArC,CAAV;UACA;;QAEF,KAAK,OAAL;UACEN,IAAI,CAACC,IAAL,CAAU,CAAClC,SAAS,CAACJ,GAAD,EAAMyC,GAAG,CAACnF,CAAV,EAAa2C,OAAb,CAAV,EAAiCuC,IAAjC,EAAuCC,GAAG,CAACE,QAA3C,CAAV;UACA;;QAEF,KAAK,MAAL;UACET,KAAK,IAAIT,IAAI,CAACC,GAAD,CAAb;UACA;;QAEF,KAAK,OAAL;UACE,IAAIS,UAAU,IAAIM,GAAG,CAAC,OAAD,CAArB,EAAgC;YAC9B,OAAO,KAAP;UACD;;UAEDJ,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMyC,GAAG,CAAC,OAAD,CAAH,GAAe9C,UAAf,GAA4B6C,IAAlC,EAAwCC,GAAG,CAACE,QAA5C,CAAV;;UAEA,IAAIF,GAAG,CAACG,EAAR,EAAY;YACVlD,YAAY,CAAC+C,GAAG,CAACG,EAAL,CAAZ,GAAuBP,IAAI,CAACA,IAAI,CAACnF,MAAL,GAAc,CAAf,CAAJ,CAAsB,CAAtB,CAAvB;UACD;;UAED;;QAEF,KAAK,MAAL;UACE,KAAK,IAAI2F,EAAE,GAAGJ,GAAG,CAACC,KAAJ,CAAUxF,MAAV,GAAmB,CAAjC,EAAoC2F,EAAE,IAAI,CAA1C,EAA6CA,EAAE,EAA/C,EAAmD;YACjDR,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYC,GAAG,CAACC,KAAJ,CAAUG,EAAV,CAAZ,CAAV;UACD;;UAED;;QAEF,KAAK,UAAL;UACE;YACE,IAAIC,SAAS,GAAGL,GAAG,CAACM,OAAJ,GAAcrD,YAAY,CAAC+C,GAAG,CAACM,OAAL,CAA1B,GAA0CP,IAA1D;;YAEA,IAAIM,SAAS,KAAKnD,UAAlB,EAA8B;cAC5B,IAAI8C,GAAG,CAACO,aAAR,EAAuB;gBACrBX,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYC,GAAG,CAACO,aAAhB,CAAV;cACD;YACF;;YAED,IAAIF,SAAS,KAAKlD,SAAlB,EAA6B;cAC3B,IAAI6C,GAAG,CAACQ,YAAR,EAAsB;gBACpBZ,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYC,GAAG,CAACQ,YAAhB,CAAV;cACD;YACF;;YAED;UACD;;QAEH,KAAK,MAAL;UACE,QAAQT,IAAR;YACE;YACA,KAAK5C,SAAL;cACE,IAAI,CAAC6C,GAAG,CAACS,IAAT,EAAe;gBACb,IAAI,CAACT,GAAG,CAACU,IAAT,EAAe;kBACbzB,GAAG,CAACY,IAAJ,CAAS,GAAT;kBACAJ,KAAK,IAAI,CAAT;gBACD;;gBAED;cACD;;cAED,OAAO,IAAP;;YAEF,KAAKvC,UAAL;cACE,OAAO,IAAP;UAfJ;;UAkBA;MA9EJ;IAgFD;EACF;;EAED,OAAO,KAAP;AACD;;AAED,SAASyD,gBAAT,CAA0BX,GAA1B,EAA+BxC,OAA/B,EAAwC;EACtCP,YAAY,GAAG,EAAf;EACA,IAAIwC,KAAK,GAAGjC,OAAO,CAACoD,UAApB;EACA,IAAIC,OAAO,GAAGjE,uBAAuB,CAACY,OAAO,CAACsD,SAAT,CAArC;EACA,IAAIC,GAAG,GAAG,CAAV,CAJsC,CAIzB;EACb;EACA;;EAEA,IAAInB,IAAI,GAAG,CAAC,CAACxC,UAAU,EAAX,EAAeF,UAAf,EAA2B8C,GAA3B,CAAD,CAAX;EACA,IAAIf,GAAG,GAAG,EAAV;EACA,IAAI+B,eAAe,GAAG,KAAtB;EACA,IAAIC,UAAU,GAAG,EAAjB;;EAEA,OAAOrB,IAAI,CAACnF,MAAL,KAAgB,CAAvB,EAA0B;IACxB,IAAIqF,CAAC,GAAGF,IAAI,CAACR,GAAL,EAAR;IACA,IAAI7B,GAAG,GAAGuC,CAAC,CAAC,CAAD,CAAX;IACA,IAAIC,IAAI,GAAGD,CAAC,CAAC,CAAD,CAAZ;IACA,IAAIoB,IAAI,GAAGpB,CAAC,CAAC,CAAD,CAAZ;;IAEA,IAAI,OAAOoB,IAAP,KAAgB,QAApB,EAA8B;MAC5BjC,GAAG,CAACY,IAAJ,CAASqB,IAAT;MACAH,GAAG,IAAIrE,cAAc,CAACwE,IAAD,CAArB;IACD,CAHD,MAGO;MACL,QAAQA,IAAI,CAACxD,IAAb;QACE,KAAK,QAAL;UACEuB,GAAG,CAACY,IAAJ,CAAS7C,MAAM,CAACmE,WAAhB;UACA;;QAEF,KAAK,QAAL;UACE,KAAK,IAAIzG,CAAC,GAAGwG,IAAI,CAACjB,KAAL,CAAWxF,MAAX,GAAoB,CAAjC,EAAoCC,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;YAC/CkF,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYmB,IAAI,CAACjB,KAAL,CAAWvF,CAAX,CAAZ,CAAV;UACD;;UAED;;QAEF,KAAK,QAAL;UACEkF,IAAI,CAACC,IAAL,CAAU,CAACvC,UAAU,CAACC,GAAD,EAAMC,OAAN,CAAX,EAA2BuC,IAA3B,EAAiCmB,IAAI,CAAChB,QAAtC,CAAV;UACA;;QAEF,KAAK,OAAL;UACEN,IAAI,CAACC,IAAL,CAAU,CAAClC,SAAS,CAACJ,GAAD,EAAM2D,IAAI,CAACrG,CAAX,EAAc2C,OAAd,CAAV,EAAkCuC,IAAlC,EAAwCmB,IAAI,CAAChB,QAA7C,CAAV;UACA;;QAEF,KAAK,MAAL;UACEa,GAAG,IAAI/B,IAAI,CAACC,GAAD,CAAX;UACA;;QAEF,KAAK,OAAL;UACE,QAAQc,IAAR;YACE,KAAK5C,SAAL;cACE,IAAI,CAAC6D,eAAL,EAAsB;gBACpBpB,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAM2D,IAAI,CAAC,OAAD,CAAJ,GAAgBhE,UAAhB,GAA6BC,SAAnC,EAA8C+D,IAAI,CAAChB,QAAnD,CAAV;gBACA;cACD;;YAEH;;YAEA,KAAKhD,UAAL;cACE;gBACE8D,eAAe,GAAG,KAAlB;gBACA,IAAIxF,IAAI,GAAG,CAAC+B,GAAD,EAAMJ,SAAN,EAAiB+D,IAAI,CAAChB,QAAtB,CAAX;gBACA,IAAIkB,GAAG,GAAG3B,KAAK,GAAGsB,GAAlB;;gBAEA,IAAI,CAACG,IAAI,CAAC,OAAD,CAAL,IAAkB3B,IAAI,CAAC/D,IAAD,EAAOoE,IAAP,EAAawB,GAAb,EAAkB5D,OAAlB,CAA1B,EAAsD;kBACpDoC,IAAI,CAACC,IAAL,CAAUrE,IAAV;gBACD,CAFD,MAEO;kBACL;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA,IAAI0F,IAAI,CAACG,cAAT,EAAyB;oBACvB,IAAIC,YAAY,GAAGJ,IAAI,CAACG,cAAL,CAAoBH,IAAI,CAACG,cAAL,CAAoB5G,MAApB,GAA6B,CAAjD,CAAnB;;oBAEA,IAAIyG,IAAI,CAAC,OAAD,CAAR,EAAmB;sBACjBtB,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAML,UAAN,EAAkBoE,YAAlB,CAAV;sBACA;oBACD,CAHD,MAGO;sBACL,KAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGL,IAAI,CAACG,cAAL,CAAoB5G,MAApB,GAA6B,CAArD,EAAwD8G,GAAG,EAA3D,EAA+D;wBAC7D,IAAIA,GAAG,IAAIL,IAAI,CAACG,cAAL,CAAoB5G,MAA/B,EAAuC;0BACrCmF,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAML,UAAN,EAAkBoE,YAAlB,CAAV;0BACA;wBACD,CAHD,MAGO;0BACL,IAAIE,KAAK,GAAGN,IAAI,CAACG,cAAL,CAAoBE,GAApB,CAAZ;0BACA,IAAIE,GAAG,GAAG,CAAClE,GAAD,EAAMJ,SAAN,EAAiBqE,KAAjB,CAAV;;0BAEA,IAAIjC,IAAI,CAACkC,GAAD,EAAM7B,IAAN,EAAYwB,GAAZ,EAAiB5D,OAAjB,CAAR,EAAmC;4BACjCoC,IAAI,CAACC,IAAL,CAAU4B,GAAV;4BACA;0BACD;wBACF;sBACF;oBACF;kBACF,CAtBD,MAsBO;oBACL7B,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAML,UAAN,EAAkBgE,IAAI,CAAChB,QAAvB,CAAV;kBACD;gBACF;;gBAED;cACD;UArDL;;UAwDA,IAAIgB,IAAI,CAACf,EAAT,EAAa;YACXlD,YAAY,CAACiE,IAAI,CAACf,EAAN,CAAZ,GAAwBP,IAAI,CAACA,IAAI,CAACnF,MAAL,GAAc,CAAf,CAAJ,CAAsB,CAAtB,CAAxB;UACD;;UAED;QACF;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA,KAAK,MAAL;UACE;YACE,IAAIiH,IAAI,GAAGjC,KAAK,GAAGsB,GAAnB;;YAEA,IAAId,KAAK,GAAGiB,IAAI,CAACjB,KAAjB;;YAEA,IAAIA,KAAK,CAACxF,MAAN,KAAiB,CAArB,EAAwB;cACtB;YACD;;YAED,IAAIkH,OAAO,GAAG1B,KAAK,CAAC,CAAD,CAAnB;YACA,IAAI2B,cAAc,GAAG,CAACrE,GAAD,EAAMJ,SAAN,EAAiBwE,OAAjB,CAArB;YACA,IAAIE,eAAe,GAAG,CAACtE,GAAD,EAAML,UAAN,EAAkByE,OAAlB,CAAtB;YACA,IAAIG,WAAW,GAAGvC,IAAI,CAACqC,cAAD,EAAiB,EAAjB,EAAqBF,IAArB,EAA2BlE,OAA3B,EAAoC,IAApC,CAAtB;;YAEA,IAAIyC,KAAK,CAACxF,MAAN,KAAiB,CAArB,EAAwB;cACtB,IAAIqH,WAAJ,EAAiB;gBACflC,IAAI,CAACC,IAAL,CAAU+B,cAAV;cACD,CAFD,MAEO;gBACLhC,IAAI,CAACC,IAAL,CAAUgC,eAAV;cACD;;cAED;YACD;;YAED,IAAIE,UAAU,GAAG9B,KAAK,CAAC,CAAD,CAAtB;YACA,IAAI+B,iBAAiB,GAAG,CAACzE,GAAD,EAAMJ,SAAN,EAAiB4E,UAAjB,CAAxB;YACA,IAAIE,kBAAkB,GAAG,CAAC1E,GAAD,EAAML,UAAN,EAAkB6E,UAAlB,CAAzB;;YAEA,IAAI9B,KAAK,CAACxF,MAAN,KAAiB,CAArB,EAAwB;cACtB,IAAIqH,WAAJ,EAAiB;gBACflC,IAAI,CAACC,IAAL,CAAUmC,iBAAV;gBACApC,IAAI,CAACC,IAAL,CAAU+B,cAAV;cACD,CAHD,MAGO;gBACLhC,IAAI,CAACC,IAAL,CAAUoC,kBAAV;gBACArC,IAAI,CAACC,IAAL,CAAUgC,eAAV;cACD;;cAED;YACD,CAtCH,CAsCI;YACF;YACA;YACA;YACA;;;YAGA5B,KAAK,CAACiC,MAAN,CAAa,CAAb,EAAgB,CAAhB;YACA,IAAIC,YAAY,GAAG,CAAC5E,GAAD,EAAMwC,IAAN,EAAYhD,IAAI,CAACkD,KAAD,CAAhB,CAAnB;YACA,IAAImC,aAAa,GAAGnC,KAAK,CAAC,CAAD,CAAzB;YACA,IAAIoC,4BAA4B,GAAG,CAAC9E,GAAD,EAAMJ,SAAN,EAAiBL,MAAM,CAAC,CAAC6E,OAAD,EAAUI,UAAV,EAAsBK,aAAtB,CAAD,CAAvB,CAAnC;YACA,IAAIE,yBAAyB,GAAG/C,IAAI,CAAC8C,4BAAD,EAA+B,EAA/B,EAAmCX,IAAnC,EAAyClE,OAAzC,EAAkD,IAAlD,CAApC;;YAEA,IAAI8E,yBAAJ,EAA+B;cAC7B1C,IAAI,CAACC,IAAL,CAAUsC,YAAV;cACAvC,IAAI,CAACC,IAAL,CAAUmC,iBAAV;cACApC,IAAI,CAACC,IAAL,CAAU+B,cAAV;YACD,CAJD,MAIO,IAAIE,WAAJ,EAAiB;cACtBlC,IAAI,CAACC,IAAL,CAAUsC,YAAV;cACAvC,IAAI,CAACC,IAAL,CAAUoC,kBAAV;cACArC,IAAI,CAACC,IAAL,CAAU+B,cAAV;YACD,CAJM,MAIA;cACLhC,IAAI,CAACC,IAAL,CAAUsC,YAAV;cACAvC,IAAI,CAACC,IAAL,CAAUoC,kBAAV;cACArC,IAAI,CAACC,IAAL,CAAUgC,eAAV;YACD;;YAED;UACD;;QAEH,KAAK,UAAL;UACE;YACE,IAAIxB,SAAS,GAAGa,IAAI,CAACZ,OAAL,GAAerD,YAAY,CAACiE,IAAI,CAACZ,OAAN,CAA3B,GAA4CP,IAA5D;;YAEA,IAAIM,SAAS,KAAKnD,UAAlB,EAA8B;cAC5B,IAAIgE,IAAI,CAACX,aAAT,EAAwB;gBACtBX,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYmB,IAAI,CAACX,aAAjB,CAAV;cACD;YACF;;YAED,IAAIF,SAAS,KAAKlD,SAAlB,EAA6B;cAC3B,IAAI+D,IAAI,CAACV,YAAT,EAAuB;gBACrBZ,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYmB,IAAI,CAACV,YAAjB,CAAV;cACD;YACF;;YAED;UACD;;QAEH,KAAK,aAAL;UACES,UAAU,CAACpB,IAAX,CAAgB,CAACtC,GAAD,EAAMwC,IAAN,EAAYmB,IAAI,CAAChB,QAAjB,CAAhB;UACA;;QAEF,KAAK,sBAAL;UACE,IAAIe,UAAU,CAACxG,MAAX,GAAoB,CAAxB,EAA2B;YACzBmF,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAY;cACpBrC,IAAI,EAAE,MADc;cAEpB+C,IAAI,EAAE;YAFc,CAAZ,CAAV;UAID;;UAED;;QAEF,KAAK,MAAL;UACE,QAAQV,IAAR;YACE,KAAK5C,SAAL;cACE,IAAI,CAAC+D,IAAI,CAACT,IAAV,EAAgB;gBACd,IAAI,CAACS,IAAI,CAACR,IAAV,EAAgB;kBACdzB,GAAG,CAACY,IAAJ,CAAS,GAAT;kBACAkB,GAAG,IAAI,CAAP;gBACD;;gBAED;cACD,CAPD,MAOO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;gBACAC,eAAe,GAAG,IAAlB;cACD;;YAEH;;YAEA,KAAK9D,UAAL;cACE,IAAI+D,UAAU,CAACxG,MAAf,EAAuB;gBACrBmF,IAAI,CAACC,IAAL,CAAU,CAACtC,GAAD,EAAMwC,IAAN,EAAYmB,IAAZ,CAAV;gBACA,GAAGrB,IAAH,CAAQ0C,KAAR,CAAc3C,IAAd,EAAoBqB,UAAU,CAACuB,OAAX,EAApB;gBACAvB,UAAU,GAAG,EAAb;gBACA;cACD;;cAED,IAAIC,IAAI,CAACuB,OAAT,EAAkB;gBAChB,IAAIlF,GAAG,CAACM,IAAR,EAAc;kBACZoB,GAAG,CAACY,IAAJ,CAASgB,OAAT,EAAkBtD,GAAG,CAACM,IAAJ,CAAS9C,KAA3B;kBACAgG,GAAG,GAAGxD,GAAG,CAACM,IAAJ,CAASpD,MAAf;gBACD,CAHD,MAGO;kBACLwE,GAAG,CAACY,IAAJ,CAASgB,OAAT;kBACAE,GAAG,GAAG,CAAN;gBACD;cACF,CARD,MAQO;gBACLA,GAAG,IAAI/B,IAAI,CAACC,GAAD,CAAX;gBACAA,GAAG,CAACY,IAAJ,CAASgB,OAAO,GAAGtD,GAAG,CAACxC,KAAvB;gBACAgG,GAAG,GAAGxD,GAAG,CAAC9C,MAAV;cACD;;cAED;UA3CJ;;UA8CA;;QAEF;MAlQF;IAoQD;EACF;;EAED,IAAIiI,sBAAsB,GAAGzD,GAAG,CAAC0D,OAAJ,CAAY3F,MAAM,CAACmE,WAAnB,CAA7B;;EAEA,IAAIuB,sBAAsB,KAAK,CAAC,CAAhC,EAAmC;IACjC,IAAIE,2BAA2B,GAAG3D,GAAG,CAAC0D,OAAJ,CAAY3F,MAAM,CAACmE,WAAnB,EAAgCuB,sBAAsB,GAAG,CAAzD,CAAlC;IACA,IAAIG,YAAY,GAAG5D,GAAG,CAACjD,KAAJ,CAAU,CAAV,EAAa0G,sBAAb,EAAqCI,IAArC,CAA0C,EAA1C,CAAnB;IACA,IAAIC,YAAY,GAAG9D,GAAG,CAACjD,KAAJ,CAAU0G,sBAAsB,GAAG,CAAnC,EAAsCE,2BAAtC,EAAmEE,IAAnE,CAAwE,EAAxE,CAAnB;IACA,IAAIE,WAAW,GAAG/D,GAAG,CAACjD,KAAJ,CAAU4G,2BAA2B,GAAG,CAAxC,EAA2CE,IAA3C,CAAgD,EAAhD,CAAlB;IACA,OAAO;MACLG,SAAS,EAAEJ,YAAY,GAAGE,YAAf,GAA8BC,WADpC;MAELE,eAAe,EAAEL,YAAY,CAACpI,MAFzB;MAGL0I,cAAc,EAAEJ;IAHX,CAAP;EAKD;;EAED,OAAO;IACLE,SAAS,EAAEhE,GAAG,CAAC6D,IAAJ,CAAS,EAAT;EADN,CAAP;AAGD;;AAEDM,MAAM,CAACC,OAAP,GAAiB;EACf1C,gBAAgB,EAAEA;AADH,CAAjB"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.supportEmit = void 0;\n\nconst ethers_1 = require(\"ethers\");\n\nconst transaction_1 = require(\"./misc/transaction\");\n\nfunction supportEmit(Assertion) {\n  const filterLogsWithTopics = (logs, topic, contractAddress) => logs.filter(log => log.topics.includes(topic)).filter(log => log.address && log.address.toLowerCase() === contractAddress.toLowerCase());\n\n  Assertion.addMethod('emit', function (contract, eventName) {\n    const tx = this._obj;\n    const derivedPromise = transaction_1.waitForPendingTransaction(tx, contract.provider).then(receipt => {\n      let eventFragment;\n\n      try {\n        eventFragment = contract.interface.getEvent(eventName);\n      } catch (e) {// ignore error\n      }\n\n      if (eventFragment === undefined) {\n        const isNegated = this.__flags.negate === true;\n        this.assert(isNegated, `Expected event \"${eventName}\" to be emitted, but it doesn't` + ' exist in the contract. Please make sure you\\'ve compiled' + ' its latest version before running the test.', `WARNING: Expected event \"${eventName}\" NOT to be emitted.` + ' The event wasn\\'t emitted because it doesn\\'t' + ' exist in the contract. Please make sure you\\'ve compiled' + ' its latest version before running the test.', eventName, '');\n        return;\n      }\n\n      const topic = contract.interface.getEventTopic(eventFragment);\n      this.logs = filterLogsWithTopics(receipt.logs, topic, contract.address);\n      this.assert(this.logs.length > 0, `Expected event \"${eventName}\" to be emitted, but it wasn't`, `Expected event \"${eventName}\" NOT to be emitted, but it was`);\n    });\n    this.then = derivedPromise.then.bind(derivedPromise);\n    this.catch = derivedPromise.catch.bind(derivedPromise);\n    this.promise = derivedPromise;\n    this.contract = contract;\n    this.eventName = eventName;\n    return this;\n  });\n\n  const assertArgsArraysEqual = (context, expectedArgs, log) => {\n    const actualArgs = context.contract.interface.parseLog(log).args;\n    context.assert(actualArgs.length === expectedArgs.length, `Expected \"${context.eventName}\" event to have ${expectedArgs.length} argument(s), ` + `but it has ${actualArgs.length}`, 'Do not combine .not. with .withArgs()', expectedArgs.length, actualArgs.length);\n\n    for (let index = 0; index < expectedArgs.length; index++) {\n      if (expectedArgs[index].length !== undefined && typeof expectedArgs[index] !== 'string') {\n        for (let j = 0; j < expectedArgs[index].length; j++) {\n          new Assertion(actualArgs[index][j]).equal(expectedArgs[index][j]);\n        }\n      } else {\n        if (actualArgs[index].hash !== undefined && actualArgs[index]._isIndexed === true) {\n          const expectedArgBytes = ethers_1.utils.isHexString(expectedArgs[index]) ? ethers_1.utils.arrayify(expectedArgs[index]) : ethers_1.utils.toUtf8Bytes(expectedArgs[index]);\n          new Assertion(actualArgs[index].hash).to.be.oneOf([expectedArgs[index], ethers_1.utils.keccak256(expectedArgBytes)]);\n        } else {\n          new Assertion(actualArgs[index]).equal(expectedArgs[index]);\n        }\n      }\n    }\n  };\n\n  const tryAssertArgsArraysEqual = (context, expectedArgs, logs) => {\n    if (logs.length === 1) return assertArgsArraysEqual(context, expectedArgs, logs[0]);\n\n    for (const index in logs) {\n      try {\n        assertArgsArraysEqual(context, expectedArgs, logs[index]);\n        return;\n      } catch (_a) {}\n    }\n\n    context.assert(false, `Specified args not emitted in any of ${context.logs.length} emitted \"${context.eventName}\" events`, 'Do not combine .not. with .withArgs()');\n  };\n\n  Assertion.addMethod('withArgs', function () {\n    for (var _len = arguments.length, expectedArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      expectedArgs[_key] = arguments[_key];\n    }\n\n    const derivedPromise = this.promise.then(() => {\n      tryAssertArgsArraysEqual(this, expectedArgs, this.logs);\n    });\n    this.then = derivedPromise.then.bind(derivedPromise);\n    this.catch = derivedPromise.catch.bind(derivedPromise);\n    return this;\n  });\n}\n\nexports.supportEmit = supportEmit;","map":{"version":3,"names":["Object","defineProperty","exports","value","supportEmit","ethers_1","require","transaction_1","Assertion","filterLogsWithTopics","logs","topic","contractAddress","filter","log","topics","includes","address","toLowerCase","addMethod","contract","eventName","tx","_obj","derivedPromise","waitForPendingTransaction","provider","then","receipt","eventFragment","interface","getEvent","e","undefined","isNegated","__flags","negate","assert","getEventTopic","length","bind","catch","promise","assertArgsArraysEqual","context","expectedArgs","actualArgs","parseLog","args","index","j","equal","hash","_isIndexed","expectedArgBytes","utils","isHexString","arrayify","toUtf8Bytes","to","be","oneOf","keccak256","tryAssertArgsArraysEqual","_a"],"sources":["F:/Games/slotmachinereact/node_modules/@ethereum-waffle/chai/dist/cjs/matchers/emit.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.supportEmit = void 0;\nconst ethers_1 = require(\"ethers\");\nconst transaction_1 = require(\"./misc/transaction\");\nfunction supportEmit(Assertion) {\n    const filterLogsWithTopics = (logs, topic, contractAddress) => logs.filter((log) => log.topics.includes(topic))\n        .filter((log) => log.address && log.address.toLowerCase() === contractAddress.toLowerCase());\n    Assertion.addMethod('emit', function (contract, eventName) {\n        const tx = this._obj;\n        const derivedPromise = transaction_1.waitForPendingTransaction(tx, contract.provider)\n            .then((receipt) => {\n            let eventFragment;\n            try {\n                eventFragment = contract.interface.getEvent(eventName);\n            }\n            catch (e) {\n                // ignore error\n            }\n            if (eventFragment === undefined) {\n                const isNegated = this.__flags.negate === true;\n                this.assert(isNegated, `Expected event \"${eventName}\" to be emitted, but it doesn't` +\n                    ' exist in the contract. Please make sure you\\'ve compiled' +\n                    ' its latest version before running the test.', `WARNING: Expected event \"${eventName}\" NOT to be emitted.` +\n                    ' The event wasn\\'t emitted because it doesn\\'t' +\n                    ' exist in the contract. Please make sure you\\'ve compiled' +\n                    ' its latest version before running the test.', eventName, '');\n                return;\n            }\n            const topic = contract.interface.getEventTopic(eventFragment);\n            this.logs = filterLogsWithTopics(receipt.logs, topic, contract.address);\n            this.assert(this.logs.length > 0, `Expected event \"${eventName}\" to be emitted, but it wasn't`, `Expected event \"${eventName}\" NOT to be emitted, but it was`);\n        });\n        this.then = derivedPromise.then.bind(derivedPromise);\n        this.catch = derivedPromise.catch.bind(derivedPromise);\n        this.promise = derivedPromise;\n        this.contract = contract;\n        this.eventName = eventName;\n        return this;\n    });\n    const assertArgsArraysEqual = (context, expectedArgs, log) => {\n        const actualArgs = context.contract.interface.parseLog(log).args;\n        context.assert(actualArgs.length === expectedArgs.length, `Expected \"${context.eventName}\" event to have ${expectedArgs.length} argument(s), ` +\n            `but it has ${actualArgs.length}`, 'Do not combine .not. with .withArgs()', expectedArgs.length, actualArgs.length);\n        for (let index = 0; index < expectedArgs.length; index++) {\n            if (expectedArgs[index].length !== undefined && typeof expectedArgs[index] !== 'string') {\n                for (let j = 0; j < expectedArgs[index].length; j++) {\n                    new Assertion(actualArgs[index][j]).equal(expectedArgs[index][j]);\n                }\n            }\n            else {\n                if (actualArgs[index].hash !== undefined && actualArgs[index]._isIndexed === true) {\n                    const expectedArgBytes = ethers_1.utils.isHexString(expectedArgs[index])\n                        ? ethers_1.utils.arrayify(expectedArgs[index]) : ethers_1.utils.toUtf8Bytes(expectedArgs[index]);\n                    new Assertion(actualArgs[index].hash).to.be.oneOf([expectedArgs[index], ethers_1.utils.keccak256(expectedArgBytes)]);\n                }\n                else {\n                    new Assertion(actualArgs[index]).equal(expectedArgs[index]);\n                }\n            }\n        }\n    };\n    const tryAssertArgsArraysEqual = (context, expectedArgs, logs) => {\n        if (logs.length === 1)\n            return assertArgsArraysEqual(context, expectedArgs, logs[0]);\n        for (const index in logs) {\n            try {\n                assertArgsArraysEqual(context, expectedArgs, logs[index]);\n                return;\n            }\n            catch (_a) { }\n        }\n        context.assert(false, `Specified args not emitted in any of ${context.logs.length} emitted \"${context.eventName}\" events`, 'Do not combine .not. with .withArgs()');\n    };\n    Assertion.addMethod('withArgs', function (...expectedArgs) {\n        const derivedPromise = this.promise.then(() => {\n            tryAssertArgsArraysEqual(this, expectedArgs, this.logs);\n        });\n        this.then = derivedPromise.then.bind(derivedPromise);\n        this.catch = derivedPromise.catch.bind(derivedPromise);\n        return this;\n    });\n}\nexports.supportEmit = supportEmit;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar stringWidth = require(\"string-width\");\n\nvar escapeStringRegexp = require(\"escape-string-regexp\");\n\nvar getLast = require(\"../utils/get-last\"); // eslint-disable-next-line no-control-regex\n\n\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\n\nfunction isExportDeclaration(node) {\n  if (node) {\n    switch (node.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n\n  return null;\n}\n\nfunction skip(chars) {\n  return function (text, index, opts) {\n    var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n\n    if (index === false) {\n      return false;\n    }\n\n    var length = text.length;\n    var cursor = index;\n\n    while (cursor >= 0 && cursor < length) {\n      var c = text.charAt(cursor);\n\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n\n    return false;\n  };\n}\n\nvar skipWhitespace = skip(/\\s/);\nvar skipSpaces = skip(\" \\t\");\nvar skipToLineEnd = skip(\",; \\t\");\nvar skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (var i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n\n  return index;\n} // This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\n\n\nfunction skipNewline(text, index, opts) {\n  var backwards = opts && opts.backwards;\n\n  if (index === false) {\n    return false;\n  }\n\n  var atIndex = text.charAt(index);\n\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  var idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (var i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n\n  return false;\n} // Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n\n\nfunction isPreviousLineEmpty(text, node, locStart) {\n  var idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  idx = skipNewline(text, idx, {\n    backwards: true\n  });\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  var idx2 = skipNewline(text, idx, {\n    backwards: true\n  });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmptyAfterIndex(text, index) {\n  var oldIdx = null;\n  var idx = index;\n\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction isNextLineEmpty(text, node, locEnd) {\n  return isNextLineEmptyAfterIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n  var oldIdx = null;\n\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n\n  return idx;\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n  return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\nvar PRECEDENCE = {};\n[[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nvar equalityOperators = {\n  \"==\": true,\n  \"!=\": true,\n  \"===\": true,\n  \"!==\": true\n};\nvar multiplicativeOperators = {\n  \"*\": true,\n  \"/\": true,\n  \"%\": true\n};\nvar bitshiftOperators = {\n  \">>\": true,\n  \">>>\": true,\n  \"<<\": true\n};\n\nfunction shouldFlatten(parentOp, nodeOp) {\n  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n    return false;\n  } // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n\n\n  if (parentOp === \"**\") {\n    return false;\n  } // x == y == z --> (x == y) == z\n\n\n  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n    return false;\n  } // x * y % z --> (x * y) % z\n\n\n  if (nodeOp === \"%\" && multiplicativeOperators[parentOp] || parentOp === \"%\" && multiplicativeOperators[nodeOp]) {\n    return false;\n  } // x * y / z --> (x * y) / z\n  // x / y * z --> (x / y) * z\n\n\n  if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n    return false;\n  } // x << y << z --> (x << y) << z\n\n\n  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBitwiseOperator(operator) {\n  return !!bitshiftOperators[operator] || operator === \"|\" || operator === \"^\" || operator === \"&\";\n} // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n// holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n// already necessary grouping parentheses.\n\n\nfunction startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {\n  node = getLeftMost(node);\n\n  switch (node.type) {\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n    case \"DoExpression\":\n      return forbidFunctionClassAndDoExpr;\n\n    case \"ObjectExpression\":\n      return true;\n\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);\n\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);\n\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);\n\n    case \"UpdateExpression\":\n      return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);\n\n    case \"BindExpression\":\n      return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);\n\n    case \"TSAsExpression\":\n      return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);\n\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  }\n\n  return node;\n}\n\nfunction getAlignmentSize(value, tabWidth, startIndex) {\n  startIndex = startIndex || 0;\n  var size = 0;\n\n  for (var i = startIndex; i < value.length; ++i) {\n    if (value[i] === \"\\t\") {\n      // Tabs behave in a way that they are aligned to the nearest\n      // multiple of tabWidth:\n      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n\n  return size;\n}\n\nfunction getIndentSize(value, tabWidth) {\n  var lastNewlineIndex = value.lastIndexOf(\"\\n\");\n\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n\n  return getAlignmentSize( // All the leading whitespaces\n  value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0], tabWidth);\n}\n\nfunction getPreferredQuote(raw, preferredQuote) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw;\n  var _double = {\n    quote: '\"',\n    regex: /\"/g\n  };\n  var single = {\n    quote: \"'\",\n    regex: /'/g\n  };\n  var preferred = preferredQuote === \"'\" ? single : _double;\n  var alternate = preferred === single ? _double : single;\n  var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n\n  if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n    var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n    result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;\n  }\n\n  return result;\n}\n\nfunction printString(raw, options, isDirectiveLiteral) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw; // Check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n\n  var canChangeDirectiveQuotes = !rawContent.includes('\"') && !rawContent.includes(\"'\");\n  var enclosingQuote = options.parser === \"json\" ? '\"' : options.__isInHtmlAttribute ? \"'\" : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"'); // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n\n  if (isDirectiveLiteral) {\n    if (canChangeDirectiveQuotes) {\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n\n    return raw;\n  } // It might sound unnecessary to use `makeString` even if the string already\n  // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n\n\n  return makeString(rawContent, enclosingQuote, !(options.parser === \"css\" || options.parser === \"less\" || options.parser === \"scss\" || options.embeddedInHtml));\n}\n\nfunction makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n  var otherQuote = enclosingQuote === '\"' ? \"'\" : '\"'; // Matches _any_ escape and unescaped quotes (both single and double).\n\n  var regex = /\\\\([\\s\\S])|(['\"])/g; // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n\n  var newContent = rawContent.replace(regex, function (match, escaped, quote) {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    } // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n\n\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    if (quote) {\n      return quote;\n    } // Unescape any unnecessarily escaped character.\n    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n\n\n    return unescapeUnnecessaryEscapes && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n  });\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printNumber(rawNumber) {\n  return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.\n  .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\") // Remove unnecessary scientific notation (1e0).\n  .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\") // Make sure numbers always start with a digit.\n  .replace(/^([+-])?\\./, \"$10.\") // Remove extraneous trailing decimal zeroes.\n  .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\") // Remove trailing dot.\n  .replace(/\\.(?=e|$)/, \"\");\n}\n\nfunction getMaxContinuousCount(str, target) {\n  var results = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (results === null) {\n    return 0;\n  }\n\n  return results.reduce(function (maxCount, result) {\n    return Math.max(maxCount, result.length / target.length);\n  }, 0);\n}\n\nfunction getMinNotPresentContinuousCount(str, target) {\n  var matches = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (matches === null) {\n    return 0;\n  }\n\n  var countPresent = new Map();\n  var max = 0;\n\n  var _iterator = _createForOfIteratorHelper(matches),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var match = _step.value;\n      var count = match.length / target.length;\n      countPresent.set(count, true);\n\n      if (count > max) {\n        max = count;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  for (var i = 1; i < max; i++) {\n    if (!countPresent.get(i)) {\n      return i;\n    }\n  }\n\n  return max + 1;\n}\n\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\n\n\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n\n  return stringWidth(text);\n}\n\nfunction hasIgnoreComment(path) {\n  var node = path.getValue();\n  return hasNodeIgnoreComment(node);\n}\n\nfunction hasNodeIgnoreComment(node) {\n  return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n\nfunction matchAncestorTypes(path, types, index) {\n  index = index || 0;\n  types = types.slice();\n\n  while (types.length) {\n    var parent = path.getParentNode(index);\n    var type = types.shift();\n\n    if (!parent || parent.type !== type) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n  comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment\n  // We already \"print\" it via the raw text, we don't need to re-print it as a\n  // comment\n\n  if (node.type === \"JSXText\") {\n    comment.printed = true;\n  }\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction isWithinParentArrayProperty(path, propertyName) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (parent == null) {\n    return false;\n  }\n\n  if (!Array.isArray(parent[propertyName])) {\n    return false;\n  }\n\n  var key = path.getName();\n  return parent[propertyName][key] === node;\n}\n\nfunction replaceEndOfLineWith(text, replacement) {\n  var parts = [];\n\n  var _iterator2 = _createForOfIteratorHelper(text.split(\"\\n\")),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var part = _step2.value;\n\n      if (parts.length !== 0) {\n        parts.push(replacement);\n      }\n\n      parts.push(part);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  replaceEndOfLineWith: replaceEndOfLineWith,\n  getStringWidth: getStringWidth,\n  getMaxContinuousCount: getMaxContinuousCount,\n  getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,\n  getPrecedence: getPrecedence,\n  shouldFlatten: shouldFlatten,\n  isBitwiseOperator: isBitwiseOperator,\n  isExportDeclaration: isExportDeclaration,\n  getParentExportDeclaration: getParentExportDeclaration,\n  getPenultimate: getPenultimate,\n  getLast: getLast,\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,\n  getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,\n  skip: skip,\n  skipWhitespace: skipWhitespace,\n  skipSpaces: skipSpaces,\n  skipToLineEnd: skipToLineEnd,\n  skipEverythingButNewLine: skipEverythingButNewLine,\n  skipInlineComment: skipInlineComment,\n  skipTrailingComment: skipTrailingComment,\n  skipNewline: skipNewline,\n  isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,\n  isNextLineEmpty: isNextLineEmpty,\n  isPreviousLineEmpty: isPreviousLineEmpty,\n  hasNewline: hasNewline,\n  hasNewlineInRange: hasNewlineInRange,\n  hasSpaces: hasSpaces,\n  setLocStart: setLocStart,\n  setLocEnd: setLocEnd,\n  startsWithNoLookaheadToken: startsWithNoLookaheadToken,\n  getAlignmentSize: getAlignmentSize,\n  getIndentSize: getIndentSize,\n  getPreferredQuote: getPreferredQuote,\n  printString: printString,\n  printNumber: printNumber,\n  hasIgnoreComment: hasIgnoreComment,\n  hasNodeIgnoreComment: hasNodeIgnoreComment,\n  makeString: makeString,\n  matchAncestorTypes: matchAncestorTypes,\n  addLeadingComment: addLeadingComment,\n  addDanglingComment: addDanglingComment,\n  addTrailingComment: addTrailingComment,\n  isWithinParentArrayProperty: isWithinParentArrayProperty\n};","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","stringWidth","require","escapeStringRegexp","getLast","notAsciiRegex","isExportDeclaration","node","type","getParentExportDeclaration","path","parentNode","getParentNode","getName","getPenultimate","skip","chars","text","index","opts","backwards","cursor","c","charAt","RegExp","indexOf","skipWhitespace","skipSpaces","skipToLineEnd","skipEverythingButNewLine","skipInlineComment","skipTrailingComment","skipNewline","atIndex","hasNewline","idx","idx2","hasNewlineInRange","start","end","isPreviousLineEmpty","locStart","isNextLineEmptyAfterIndex","oldIdx","isNextLineEmpty","locEnd","getNextNonSpaceNonCommentCharacterIndexWithStartIndex","getNextNonSpaceNonCommentCharacterIndex","getNextNonSpaceNonCommentCharacter","hasSpaces","setLocStart","range","setLocEnd","PRECEDENCE","forEach","tier","op","getPrecedence","equalityOperators","multiplicativeOperators","bitshiftOperators","shouldFlatten","parentOp","nodeOp","isBitwiseOperator","operator","startsWithNoLookaheadToken","forbidFunctionClassAndDoExpr","getLeftMost","object","tag","callee","prefix","argument","expressions","expression","left","getAlignmentSize","tabWidth","startIndex","size","getIndentSize","lastNewlineIndex","lastIndexOf","match","getPreferredQuote","raw","preferredQuote","rawContent","_double","quote","regex","single","preferred","alternate","result","includes","numPreferredQuotes","numAlternateQuotes","printString","options","isDirectiveLiteral","canChangeDirectiveQuotes","enclosingQuote","parser","__isInHtmlAttribute","singleQuote","makeString","embeddedInHtml","unescapeUnnecessaryEscapes","otherQuote","newContent","replace","escaped","printNumber","rawNumber","toLowerCase","getMaxContinuousCount","str","target","results","concat","reduce","maxCount","Math","max","getMinNotPresentContinuousCount","matches","countPresent","Map","_iterator","_step","count","set","get","getStringWidth","hasIgnoreComment","getValue","hasNodeIgnoreComment","comments","some","comment","trim","matchAncestorTypes","types","parent","shift","addCommentHelper","push","printed","addLeadingComment","leading","trailing","addDanglingComment","addTrailingComment","isWithinParentArrayProperty","propertyName","key","replaceEndOfLineWith","replacement","parts","_iterator2","split","_step2","part","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/common/util.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar stringWidth = require(\"string-width\");\n\nvar escapeStringRegexp = require(\"escape-string-regexp\");\n\nvar getLast = require(\"../utils/get-last\"); // eslint-disable-next-line no-control-regex\n\n\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\n\nfunction isExportDeclaration(node) {\n  if (node) {\n    switch (node.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n\n  return null;\n}\n\nfunction skip(chars) {\n  return function (text, index, opts) {\n    var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n\n    if (index === false) {\n      return false;\n    }\n\n    var length = text.length;\n    var cursor = index;\n\n    while (cursor >= 0 && cursor < length) {\n      var c = text.charAt(cursor);\n\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n\n    return false;\n  };\n}\n\nvar skipWhitespace = skip(/\\s/);\nvar skipSpaces = skip(\" \\t\");\nvar skipToLineEnd = skip(\",; \\t\");\nvar skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (var i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n\n  return index;\n} // This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\n\n\nfunction skipNewline(text, index, opts) {\n  var backwards = opts && opts.backwards;\n\n  if (index === false) {\n    return false;\n  }\n\n  var atIndex = text.charAt(index);\n\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n\n    if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  var idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (var i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n\n  return false;\n} // Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n\n\nfunction isPreviousLineEmpty(text, node, locStart) {\n  var idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  idx = skipNewline(text, idx, {\n    backwards: true\n  });\n  idx = skipSpaces(text, idx, {\n    backwards: true\n  });\n  var idx2 = skipNewline(text, idx, {\n    backwards: true\n  });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmptyAfterIndex(text, index) {\n  var oldIdx = null;\n  var idx = index;\n\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction isNextLineEmpty(text, node, locEnd) {\n  return isNextLineEmptyAfterIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n  var oldIdx = null;\n\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n\n  return idx;\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n  return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\nvar PRECEDENCE = {};\n[[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nvar equalityOperators = {\n  \"==\": true,\n  \"!=\": true,\n  \"===\": true,\n  \"!==\": true\n};\nvar multiplicativeOperators = {\n  \"*\": true,\n  \"/\": true,\n  \"%\": true\n};\nvar bitshiftOperators = {\n  \">>\": true,\n  \">>>\": true,\n  \"<<\": true\n};\n\nfunction shouldFlatten(parentOp, nodeOp) {\n  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n    return false;\n  } // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n\n\n  if (parentOp === \"**\") {\n    return false;\n  } // x == y == z --> (x == y) == z\n\n\n  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n    return false;\n  } // x * y % z --> (x * y) % z\n\n\n  if (nodeOp === \"%\" && multiplicativeOperators[parentOp] || parentOp === \"%\" && multiplicativeOperators[nodeOp]) {\n    return false;\n  } // x * y / z --> (x * y) / z\n  // x / y * z --> (x / y) * z\n\n\n  if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n    return false;\n  } // x << y << z --> (x << y) << z\n\n\n  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBitwiseOperator(operator) {\n  return !!bitshiftOperators[operator] || operator === \"|\" || operator === \"^\" || operator === \"&\";\n} // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n// holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n// already necessary grouping parentheses.\n\n\nfunction startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {\n  node = getLeftMost(node);\n\n  switch (node.type) {\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n    case \"DoExpression\":\n      return forbidFunctionClassAndDoExpr;\n\n    case \"ObjectExpression\":\n      return true;\n\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);\n\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);\n\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);\n\n    case \"UpdateExpression\":\n      return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);\n\n    case \"BindExpression\":\n      return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);\n\n    case \"TSAsExpression\":\n      return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);\n\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  }\n\n  return node;\n}\n\nfunction getAlignmentSize(value, tabWidth, startIndex) {\n  startIndex = startIndex || 0;\n  var size = 0;\n\n  for (var i = startIndex; i < value.length; ++i) {\n    if (value[i] === \"\\t\") {\n      // Tabs behave in a way that they are aligned to the nearest\n      // multiple of tabWidth:\n      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n\n  return size;\n}\n\nfunction getIndentSize(value, tabWidth) {\n  var lastNewlineIndex = value.lastIndexOf(\"\\n\");\n\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n\n  return getAlignmentSize( // All the leading whitespaces\n  value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0], tabWidth);\n}\n\nfunction getPreferredQuote(raw, preferredQuote) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw;\n  var _double = {\n    quote: '\"',\n    regex: /\"/g\n  };\n  var single = {\n    quote: \"'\",\n    regex: /'/g\n  };\n  var preferred = preferredQuote === \"'\" ? single : _double;\n  var alternate = preferred === single ? _double : single;\n  var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n\n  if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n    var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n    result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;\n  }\n\n  return result;\n}\n\nfunction printString(raw, options, isDirectiveLiteral) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  var rawContent = raw; // Check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n\n  var canChangeDirectiveQuotes = !rawContent.includes('\"') && !rawContent.includes(\"'\");\n  var enclosingQuote = options.parser === \"json\" ? '\"' : options.__isInHtmlAttribute ? \"'\" : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"'); // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n\n  if (isDirectiveLiteral) {\n    if (canChangeDirectiveQuotes) {\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n\n    return raw;\n  } // It might sound unnecessary to use `makeString` even if the string already\n  // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n\n\n  return makeString(rawContent, enclosingQuote, !(options.parser === \"css\" || options.parser === \"less\" || options.parser === \"scss\" || options.embeddedInHtml));\n}\n\nfunction makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n  var otherQuote = enclosingQuote === '\"' ? \"'\" : '\"'; // Matches _any_ escape and unescaped quotes (both single and double).\n\n  var regex = /\\\\([\\s\\S])|(['\"])/g; // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n\n  var newContent = rawContent.replace(regex, function (match, escaped, quote) {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    } // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n\n\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    if (quote) {\n      return quote;\n    } // Unescape any unnecessarily escaped character.\n    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n\n\n    return unescapeUnnecessaryEscapes && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n  });\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printNumber(rawNumber) {\n  return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.\n  .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\") // Remove unnecessary scientific notation (1e0).\n  .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\") // Make sure numbers always start with a digit.\n  .replace(/^([+-])?\\./, \"$10.\") // Remove extraneous trailing decimal zeroes.\n  .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\") // Remove trailing dot.\n  .replace(/\\.(?=e|$)/, \"\");\n}\n\nfunction getMaxContinuousCount(str, target) {\n  var results = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (results === null) {\n    return 0;\n  }\n\n  return results.reduce(function (maxCount, result) {\n    return Math.max(maxCount, result.length / target.length);\n  }, 0);\n}\n\nfunction getMinNotPresentContinuousCount(str, target) {\n  var matches = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n  if (matches === null) {\n    return 0;\n  }\n\n  var countPresent = new Map();\n  var max = 0;\n\n  var _iterator = _createForOfIteratorHelper(matches),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var match = _step.value;\n      var count = match.length / target.length;\n      countPresent.set(count, true);\n\n      if (count > max) {\n        max = count;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  for (var i = 1; i < max; i++) {\n    if (!countPresent.get(i)) {\n      return i;\n    }\n  }\n\n  return max + 1;\n}\n\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\n\n\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n\n  return stringWidth(text);\n}\n\nfunction hasIgnoreComment(path) {\n  var node = path.getValue();\n  return hasNodeIgnoreComment(node);\n}\n\nfunction hasNodeIgnoreComment(node) {\n  return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n\nfunction matchAncestorTypes(path, types, index) {\n  index = index || 0;\n  types = types.slice();\n\n  while (types.length) {\n    var parent = path.getParentNode(index);\n    var type = types.shift();\n\n    if (!parent || parent.type !== type) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n  comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment\n  // We already \"print\" it via the raw text, we don't need to re-print it as a\n  // comment\n\n  if (node.type === \"JSXText\") {\n    comment.printed = true;\n  }\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction isWithinParentArrayProperty(path, propertyName) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (parent == null) {\n    return false;\n  }\n\n  if (!Array.isArray(parent[propertyName])) {\n    return false;\n  }\n\n  var key = path.getName();\n  return parent[propertyName][key] === node;\n}\n\nfunction replaceEndOfLineWith(text, replacement) {\n  var parts = [];\n\n  var _iterator2 = _createForOfIteratorHelper(text.split(\"\\n\")),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var part = _step2.value;\n\n      if (parts.length !== 0) {\n        parts.push(replacement);\n      }\n\n      parts.push(part);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  replaceEndOfLineWith: replaceEndOfLineWith,\n  getStringWidth: getStringWidth,\n  getMaxContinuousCount: getMaxContinuousCount,\n  getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,\n  getPrecedence: getPrecedence,\n  shouldFlatten: shouldFlatten,\n  isBitwiseOperator: isBitwiseOperator,\n  isExportDeclaration: isExportDeclaration,\n  getParentExportDeclaration: getParentExportDeclaration,\n  getPenultimate: getPenultimate,\n  getLast: getLast,\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,\n  getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,\n  skip: skip,\n  skipWhitespace: skipWhitespace,\n  skipSpaces: skipSpaces,\n  skipToLineEnd: skipToLineEnd,\n  skipEverythingButNewLine: skipEverythingButNewLine,\n  skipInlineComment: skipInlineComment,\n  skipTrailingComment: skipTrailingComment,\n  skipNewline: skipNewline,\n  isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,\n  isNextLineEmpty: isNextLineEmpty,\n  isPreviousLineEmpty: isPreviousLineEmpty,\n  hasNewline: hasNewline,\n  hasNewlineInRange: hasNewlineInRange,\n  hasSpaces: hasSpaces,\n  setLocStart: setLocStart,\n  setLocEnd: setLocEnd,\n  startsWithNoLookaheadToken: startsWithNoLookaheadToken,\n  getAlignmentSize: getAlignmentSize,\n  getIndentSize: getIndentSize,\n  getPreferredQuote: getPreferredQuote,\n  printString: printString,\n  printNumber: printNumber,\n  hasIgnoreComment: hasIgnoreComment,\n  hasNodeIgnoreComment: hasNodeIgnoreComment,\n  makeString: makeString,\n  matchAncestorTypes: matchAncestorTypes,\n  addLeadingComment: addLeadingComment,\n  addDanglingComment: addDanglingComment,\n  addTrailingComment: addTrailingComment,\n  isWithinParentArrayProperty: isWithinParentArrayProperty\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}
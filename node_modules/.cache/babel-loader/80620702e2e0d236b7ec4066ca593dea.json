{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar assert = require(\"assert\");\n\nvar util = require(\"../common/util\");\n\nvar comments = require(\"./comments\");\n\nvar _require = require(\"./utils\"),\n    getLeftSidePathName = _require.getLeftSidePathName,\n    hasNakedLeftSide = _require.hasNakedLeftSide,\n    hasFlowShorthandAnnotationComment = _require.hasFlowShorthandAnnotationComment;\n\nfunction hasClosureCompilerTypeCastComment(text, path) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  var n = path.getValue();\n  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n  function hasAncestorTypeCastComment(index) {\n    var ancestor = path.getParentNode(index);\n    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n  }\n\n  function hasTypeCastComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading && comments.isBlockComment(comment) && isTypeCastComment(comment.value);\n    });\n  }\n\n  function isParenthesized(node) {\n    // Closure typecast comments only really make sense when _not_ using\n    // typescript or flow parsers, so we take advantage of the babel parser's\n    // parenthesized expressions.\n    return node.extra && node.extra.parenthesized;\n  }\n\n  function isTypeCastComment(comment) {\n    var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n      return line.replace(/^[\\s*]+/, \"\");\n    }).join(\" \").trim();\n\n    if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n      return false;\n    }\n\n    var isCompletelyClosed = false;\n    var unpairedBracketCount = 0;\n\n    var _iterator = _createForOfIteratorHelper(cleaned),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _char = _step.value;\n\n        if (_char === \"{\") {\n          if (isCompletelyClosed) {\n            return false;\n          }\n\n          unpairedBracketCount++;\n        } else if (_char === \"}\") {\n          if (unpairedBracketCount === 0) {\n            return false;\n          }\n\n          unpairedBracketCount--;\n\n          if (unpairedBracketCount === 0) {\n            isCompletelyClosed = true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return unpairedBracketCount === 0;\n  }\n}\n\nfunction needsParens(path, options) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = path.getName();\n  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n\n  if (path.getValue() !== node) {\n    return false;\n  } // to avoid unexpected `}}` in HTML interpolations\n\n\n  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n    return true;\n  } // Only statements don't need parentheses.\n\n\n  if (isStatement(node)) {\n    return false;\n  } // Closure compiler requires that type casted expressions to be surrounded by\n  // parentheses.\n\n\n  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n    return true;\n  }\n\n  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n  // parser. The Flow parser turns Flow comments into type annotation nodes in its\n  // AST, which we handle separately.\n  options.parser !== \"flow\" && hasFlowShorthandAnnotationComment(path.getValue())) {\n    return true;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  } // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n\n\n  if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n    return true;\n  } // `export default function` or `export default class` can't be followed by\n  // anything after. So an expression like `export default (function(){}).toString()`\n  // needs to be followed by a parentheses\n\n\n  if (parent.type === \"ExportDefaultDeclaration\") {\n    return shouldWrapFunctionForExportDefault(path, options);\n  }\n\n  if (parent.type === \"Decorator\" && parent.expression === node) {\n    var hasCallExpression = false;\n    var hasMemberExpression = false;\n    var current = node;\n\n    while (current) {\n      switch (current.type) {\n        case \"MemberExpression\":\n          hasMemberExpression = true;\n          current = current.object;\n          break;\n\n        case \"CallExpression\":\n          if (\n          /** @(x().y) */\n          hasMemberExpression ||\n          /** @(x().y()) */\n          hasCallExpression) {\n            return true;\n          }\n\n          hasCallExpression = true;\n          current = current.callee;\n          break;\n\n        case \"Identifier\":\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    return true;\n  }\n\n  if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n  util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  true)) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n      }\n\n    // else fallthrough\n\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n        case \"BindExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        case \"TSNonNullExpression\":\n          return true;\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      {\n        if (parent.type === \"UpdateExpression\") {\n          return true;\n        }\n\n        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n          var i = 0;\n\n          while (node) {\n            var _parent = path.getParentNode(i++);\n\n            if (!_parent) {\n              return false;\n            }\n\n            if (_parent.type === \"ForStatement\" && _parent.init === node) {\n              return true;\n            }\n\n            node = _parent;\n          }\n\n          return false;\n        };\n\n        if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n          return true;\n        }\n      }\n    // fallthrough\n\n    case \"TSTypeAssertion\":\n    case \"TSAsExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"ConditionalExpression\":\n          return node.type === \"TSAsExpression\";\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ClassExpression\":\n        case \"ClassDeclaration\":\n          return name === \"superClass\" && parent.superClass === node;\n\n        case \"TSTypeAssertion\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BindExpression\":\n        case \"AwaitExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"UpdateExpression\":\n          return true;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"AssignmentExpression\":\n          return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            if (!node.operator && node.type !== \"TSTypeAssertion\") {\n              return true;\n            }\n\n            var po = parent.operator;\n            var pp = util.getPrecedence(po);\n            var no = node.operator;\n            var np = util.getPrecedence(no);\n\n            if (pp > np) {\n              return true;\n            }\n\n            if ((po === \"||\" || po === \"??\") && no === \"&&\") {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert.strictEqual(parent.right, node);\n              return true;\n            }\n\n            if (pp === np && !util.shouldFlatten(po, no)) {\n              return true;\n            }\n\n            if (pp < np && no === \"%\") {\n              return po === \"+\" || po === \"-\";\n            } // Add parenthesis when working with bitwise operators\n            // It's not stricly needed but helps with code understanding\n\n\n            if (util.isBitwiseOperator(po)) {\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"TSParenthesizedType\":\n      {\n        var grandParent = path.getParentNode(1);\n        /**\n         * const foo = (): (() => void) => (): void => null;\n         *                 ^          ^\n         */\n\n        if (getUnparenthesizedNode(node).type === \"TSFunctionType\" && parent.type === \"TSTypeAnnotation\" && grandParent.type === \"ArrowFunctionExpression\" && grandParent.returnType === parent) {\n          return true;\n        }\n\n        if ((parent.type === \"TSTypeParameter\" || parent.type === \"TypeParameter\" || parent.type === \"TSTypeAliasDeclaration\" || parent.type === \"TSTypeAnnotation\" || parent.type === \"TSParenthesizedType\" || parent.type === \"TSTypeParameterInstantiation\") && grandParent.type !== \"TSTypeOperator\" && grandParent.type !== \"TSOptionalType\") {\n          return false;\n        } // Delegate to inner TSParenthesizedType\n\n\n        if (node.typeAnnotation.type === \"TSParenthesizedType\" && parent.type !== \"TSArrayType\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        case \"ArrowFunctionExpression\":\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n          return name !== \"body\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n        return true;\n      }\n\n    // else fallthrough\n\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"BindExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return parent.object === node;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      {\n        var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n        return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n        ancestor.type === \"NullableTypeAnnotation\";\n      }\n\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"Literal\":\n      if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n      // See corresponding workaround in printer.js case: \"Literal\"\n      options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n        // To avoid becoming a directive\n        var _grandParent = path.getParentNode(1);\n\n        return _grandParent.type === \"Program\" || _grandParent.type === \"BlockStatement\";\n      }\n\n      return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n    case \"AssignmentExpression\":\n      {\n        var _grandParent2 = path.getParentNode(1);\n\n        if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n          return true;\n        } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n          return false;\n        } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n          return false;\n        } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n          return false;\n        } else if (parent.type === \"ExpressionStatement\") {\n          return node.left.type === \"ObjectPattern\";\n        } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n          return false;\n        } else if (parent.type === \"AssignmentExpression\") {\n          return false;\n        } else if (parent.type === \"SequenceExpression\" && _grandParent2 && _grandParent2.type === \"ForStatement\" && (_grandParent2.init === parent || _grandParent2.update === parent)) {\n          return false;\n        } else if (parent.type === \"Property\" && parent.value === node) {\n          return false;\n        } else if (parent.type === \"NGChainedExpression\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"NGPipeExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"TSTypeAssertion\":\n        case \"TypeCastExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\";\n        // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n\n        case \"TaggedTemplateExpression\":\n          return true;\n        // This is basically a kind of IIFE.\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"TSAsExpression\":\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n        case \"AwaitExpression\":\n        case \"TSTypeAssertion\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        default:\n          return false;\n      }\n\n    case \"OptionalMemberExpression\":\n      return parent.type === \"MemberExpression\";\n\n    case \"CallExpression\":\n    case \"MemberExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"TSNonNullExpression\":\n      if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" && parent.callee === node) {\n        var object = node;\n\n        while (object) {\n          switch (object.type) {\n            case \"CallExpression\":\n              return true;\n\n            case \"MemberExpression\":\n            case \"BindExpression\":\n              object = object.object;\n              break;\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n            case \"TaggedTemplateExpression\":\n              object = object.tag;\n              break;\n\n            case \"TSNonNullExpression\":\n              object = object.expression;\n              break;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n\n    case \"BindExpression\":\n      if (parent.type === \"BindExpression\" && name === \"callee\" && parent.callee === node || parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node || parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      return false;\n\n    case \"NGPipeExpression\":\n      if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n\n      return true;\n  }\n\n  return false;\n}\n\nfunction isStatement(node) {\n  return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n}\n\nfunction getUnparenthesizedNode(node) {\n  return node.type === \"TSParenthesizedType\" ? getUnparenthesizedNode(node.typeAnnotation) : node;\n}\n\nfunction endsWithRightBracket(node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isFollowedByRightBracket(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var name = path.getName();\n\n  switch (parent.type) {\n    case \"NGPipeExpression\":\n      if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ObjectProperty\":\n      if (name === \"value\") {\n        var parentParent = path.getParentNode(1);\n        return parentParent.properties[parentParent.properties.length - 1] === parent;\n      }\n\n      break;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      if (name === \"right\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n      if (name === \"alternate\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"UnaryExpression\":\n      if (parent.prefix) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n  }\n\n  return false;\n}\n\nfunction shouldWrapFunctionForExportDefault(path, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n    return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n    // (e.g. `export default (function() {})();`)\n    // in this case we don't need to add extra parens\n    !needsParens(path, options);\n  }\n\n  if (!hasNakedLeftSide(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return shouldWrapFunctionForExportDefault(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nmodule.exports = needsParens;","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","assert","require","util","comments","_require","getLeftSidePathName","hasNakedLeftSide","hasFlowShorthandAnnotationComment","hasClosureCompilerTypeCastComment","text","path","getValue","isParenthesized","hasTypeCastComment","hasAncestorTypeCastComment","index","ancestor","getParentNode","node","some","comment","leading","isBlockComment","isTypeCastComment","extra","parenthesized","cleaned","trim","split","map","line","replace","join","isCompletelyClosed","unpairedBracketCount","_iterator","_step","_char","needsParens","options","parent","getName","getNode","__isInHtmlInterpolation","bracketSpacing","endsWithRightBracket","isFollowedByRightBracket","isStatement","originalText","parser","type","superClass","shouldWrapFunctionForExportDefault","expression","hasCallExpression","hasMemberExpression","current","object","callee","body","startsWithNoLookaheadToken","prefix","operator","isLeftOfAForStatement","_parent","init","left","po","pp","getPrecedence","no","np","strictEqual","right","shouldFlatten","isBitwiseOperator","grandParent","getUnparenthesizedNode","returnType","typeAnnotation","directive","substr","locStart","_grandParent","_grandParent2","key","computed","update","tag","arguments","callParent","parentParent","properties","apply","childPath","concat","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/@miksu/prettier/lib/language-js/needs-parens.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar assert = require(\"assert\");\n\nvar util = require(\"../common/util\");\n\nvar comments = require(\"./comments\");\n\nvar _require = require(\"./utils\"),\n    getLeftSidePathName = _require.getLeftSidePathName,\n    hasNakedLeftSide = _require.hasNakedLeftSide,\n    hasFlowShorthandAnnotationComment = _require.hasFlowShorthandAnnotationComment;\n\nfunction hasClosureCompilerTypeCastComment(text, path) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  var n = path.getValue();\n  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n  function hasAncestorTypeCastComment(index) {\n    var ancestor = path.getParentNode(index);\n    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n  }\n\n  function hasTypeCastComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading && comments.isBlockComment(comment) && isTypeCastComment(comment.value);\n    });\n  }\n\n  function isParenthesized(node) {\n    // Closure typecast comments only really make sense when _not_ using\n    // typescript or flow parsers, so we take advantage of the babel parser's\n    // parenthesized expressions.\n    return node.extra && node.extra.parenthesized;\n  }\n\n  function isTypeCastComment(comment) {\n    var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n      return line.replace(/^[\\s*]+/, \"\");\n    }).join(\" \").trim();\n\n    if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n      return false;\n    }\n\n    var isCompletelyClosed = false;\n    var unpairedBracketCount = 0;\n\n    var _iterator = _createForOfIteratorHelper(cleaned),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _char = _step.value;\n\n        if (_char === \"{\") {\n          if (isCompletelyClosed) {\n            return false;\n          }\n\n          unpairedBracketCount++;\n        } else if (_char === \"}\") {\n          if (unpairedBracketCount === 0) {\n            return false;\n          }\n\n          unpairedBracketCount--;\n\n          if (unpairedBracketCount === 0) {\n            isCompletelyClosed = true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return unpairedBracketCount === 0;\n  }\n}\n\nfunction needsParens(path, options) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = path.getName();\n  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n\n  if (path.getValue() !== node) {\n    return false;\n  } // to avoid unexpected `}}` in HTML interpolations\n\n\n  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n    return true;\n  } // Only statements don't need parentheses.\n\n\n  if (isStatement(node)) {\n    return false;\n  } // Closure compiler requires that type casted expressions to be surrounded by\n  // parentheses.\n\n\n  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n    return true;\n  }\n\n  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n  // parser. The Flow parser turns Flow comments into type annotation nodes in its\n  // AST, which we handle separately.\n  options.parser !== \"flow\" && hasFlowShorthandAnnotationComment(path.getValue())) {\n    return true;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  } // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n\n\n  if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n    return true;\n  } // `export default function` or `export default class` can't be followed by\n  // anything after. So an expression like `export default (function(){}).toString()`\n  // needs to be followed by a parentheses\n\n\n  if (parent.type === \"ExportDefaultDeclaration\") {\n    return shouldWrapFunctionForExportDefault(path, options);\n  }\n\n  if (parent.type === \"Decorator\" && parent.expression === node) {\n    var hasCallExpression = false;\n    var hasMemberExpression = false;\n    var current = node;\n\n    while (current) {\n      switch (current.type) {\n        case \"MemberExpression\":\n          hasMemberExpression = true;\n          current = current.object;\n          break;\n\n        case \"CallExpression\":\n          if (\n          /** @(x().y) */\n          hasMemberExpression ||\n          /** @(x().y()) */\n          hasCallExpression) {\n            return true;\n          }\n\n          hasCallExpression = true;\n          current = current.callee;\n          break;\n\n        case \"Identifier\":\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    return true;\n  }\n\n  if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n  util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  true)) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n      }\n\n    // else fallthrough\n\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n        case \"BindExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        case \"TSNonNullExpression\":\n          return true;\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      {\n        if (parent.type === \"UpdateExpression\") {\n          return true;\n        }\n\n        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n          var i = 0;\n\n          while (node) {\n            var _parent = path.getParentNode(i++);\n\n            if (!_parent) {\n              return false;\n            }\n\n            if (_parent.type === \"ForStatement\" && _parent.init === node) {\n              return true;\n            }\n\n            node = _parent;\n          }\n\n          return false;\n        };\n\n        if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n          return true;\n        }\n      }\n    // fallthrough\n\n    case \"TSTypeAssertion\":\n    case \"TSAsExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"ConditionalExpression\":\n          return node.type === \"TSAsExpression\";\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ClassExpression\":\n        case \"ClassDeclaration\":\n          return name === \"superClass\" && parent.superClass === node;\n\n        case \"TSTypeAssertion\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BindExpression\":\n        case \"AwaitExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"UpdateExpression\":\n          return true;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"AssignmentExpression\":\n          return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            if (!node.operator && node.type !== \"TSTypeAssertion\") {\n              return true;\n            }\n\n            var po = parent.operator;\n            var pp = util.getPrecedence(po);\n            var no = node.operator;\n            var np = util.getPrecedence(no);\n\n            if (pp > np) {\n              return true;\n            }\n\n            if ((po === \"||\" || po === \"??\") && no === \"&&\") {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert.strictEqual(parent.right, node);\n              return true;\n            }\n\n            if (pp === np && !util.shouldFlatten(po, no)) {\n              return true;\n            }\n\n            if (pp < np && no === \"%\") {\n              return po === \"+\" || po === \"-\";\n            } // Add parenthesis when working with bitwise operators\n            // It's not stricly needed but helps with code understanding\n\n\n            if (util.isBitwiseOperator(po)) {\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"TSParenthesizedType\":\n      {\n        var grandParent = path.getParentNode(1);\n        /**\n         * const foo = (): (() => void) => (): void => null;\n         *                 ^          ^\n         */\n\n        if (getUnparenthesizedNode(node).type === \"TSFunctionType\" && parent.type === \"TSTypeAnnotation\" && grandParent.type === \"ArrowFunctionExpression\" && grandParent.returnType === parent) {\n          return true;\n        }\n\n        if ((parent.type === \"TSTypeParameter\" || parent.type === \"TypeParameter\" || parent.type === \"TSTypeAliasDeclaration\" || parent.type === \"TSTypeAnnotation\" || parent.type === \"TSParenthesizedType\" || parent.type === \"TSTypeParameterInstantiation\") && grandParent.type !== \"TSTypeOperator\" && grandParent.type !== \"TSOptionalType\") {\n          return false;\n        } // Delegate to inner TSParenthesizedType\n\n\n        if (node.typeAnnotation.type === \"TSParenthesizedType\" && parent.type !== \"TSArrayType\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        case \"ArrowFunctionExpression\":\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n          return name !== \"body\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n        return true;\n      }\n\n    // else fallthrough\n\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"BindExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return parent.object === node;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      {\n        var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n        return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n        ancestor.type === \"NullableTypeAnnotation\";\n      }\n\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"Literal\":\n      if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n      // See corresponding workaround in printer.js case: \"Literal\"\n      options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n        // To avoid becoming a directive\n        var _grandParent = path.getParentNode(1);\n\n        return _grandParent.type === \"Program\" || _grandParent.type === \"BlockStatement\";\n      }\n\n      return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n    case \"AssignmentExpression\":\n      {\n        var _grandParent2 = path.getParentNode(1);\n\n        if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n          return true;\n        } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n          return false;\n        } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n          return false;\n        } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n          return false;\n        } else if (parent.type === \"ExpressionStatement\") {\n          return node.left.type === \"ObjectPattern\";\n        } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n          return false;\n        } else if (parent.type === \"AssignmentExpression\") {\n          return false;\n        } else if (parent.type === \"SequenceExpression\" && _grandParent2 && _grandParent2.type === \"ForStatement\" && (_grandParent2.init === parent || _grandParent2.update === parent)) {\n          return false;\n        } else if (parent.type === \"Property\" && parent.value === node) {\n          return false;\n        } else if (parent.type === \"NGChainedExpression\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"NGPipeExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"TSTypeAssertion\":\n        case \"TypeCastExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\";\n        // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n\n        case \"TaggedTemplateExpression\":\n          return true;\n        // This is basically a kind of IIFE.\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"TSAsExpression\":\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n        case \"AwaitExpression\":\n        case \"TSTypeAssertion\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        default:\n          return false;\n      }\n\n    case \"OptionalMemberExpression\":\n      return parent.type === \"MemberExpression\";\n\n    case \"CallExpression\":\n    case \"MemberExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"TSNonNullExpression\":\n      if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" && parent.callee === node) {\n        var object = node;\n\n        while (object) {\n          switch (object.type) {\n            case \"CallExpression\":\n              return true;\n\n            case \"MemberExpression\":\n            case \"BindExpression\":\n              object = object.object;\n              break;\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n            case \"TaggedTemplateExpression\":\n              object = object.tag;\n              break;\n\n            case \"TSNonNullExpression\":\n              object = object.expression;\n              break;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n\n    case \"BindExpression\":\n      if (parent.type === \"BindExpression\" && name === \"callee\" && parent.callee === node || parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node || parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      return false;\n\n    case \"NGPipeExpression\":\n      if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n\n      return true;\n  }\n\n  return false;\n}\n\nfunction isStatement(node) {\n  return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n}\n\nfunction getUnparenthesizedNode(node) {\n  return node.type === \"TSParenthesizedType\" ? getUnparenthesizedNode(node.typeAnnotation) : node;\n}\n\nfunction endsWithRightBracket(node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isFollowedByRightBracket(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var name = path.getName();\n\n  switch (parent.type) {\n    case \"NGPipeExpression\":\n      if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ObjectProperty\":\n      if (name === \"value\") {\n        var parentParent = path.getParentNode(1);\n        return parentParent.properties[parentParent.properties.length - 1] === parent;\n      }\n\n      break;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      if (name === \"right\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n      if (name === \"alternate\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"UnaryExpression\":\n      if (parent.prefix) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n  }\n\n  return false;\n}\n\nfunction shouldWrapFunctionForExportDefault(path, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n    return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n    // (e.g. `export default (function() {})();`)\n    // in this case we don't need to add extra parens\n    !needsParens(path, options);\n  }\n\n  if (!hasNakedLeftSide(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return shouldWrapFunctionForExportDefault(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nmodule.exports = needsParens;"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var util = require(\"util\");\n\nvar AbstractLevelDOWN = require(\"abstract-leveldown\").AbstractLevelDOWN;\n\nvar async = require(\"async\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar tmp = require(\"tmp\");\n\nutil.inherits(FileDown, AbstractLevelDOWN);\n\nfunction FileDown(location) {\n  this.location = location;\n  const tmpDir = path.join(location, \"_tmp\");\n\n  try {\n    // Fixes https://github.com/trufflesuite/ganache/issues/1617\n    fs.mkdirSync(tmpDir, {\n      recursive: true,\n      mode: 0o1777\n    });\n  } catch (e) {\n    // `recursive` doesn't throw if the file exists, but `recursive` doesn't\n    // exist in Node 8, so we catch the EEXISTS error in that case and ignore it.\n    // once we drop node 8 suport we can remove this try/catch\n    if (e.code !== \"EEXIST\") {\n      throw e;\n    }\n  }\n\n  this.tmpOptions = {\n    keep: true,\n    dir: tmpDir\n  };\n  AbstractLevelDOWN.call(this, location);\n}\n\nFileDown.prototype._open = function (options, callback) {\n  var self = this;\n  callback(null, self);\n};\n\nconst accessQueue = {\n  next: lKey => {\n    const cont = accessQueue.cache[lKey].shift();\n\n    if (cont) {\n      cont();\n    } else {\n      delete accessQueue.cache[lKey];\n    }\n  },\n  execute: (lKey, callback) => {\n    const cache = accessQueue.cache[lKey];\n\n    if (cache) {\n      cache.push(callback);\n    } else {\n      accessQueue.cache[lKey] = [];\n      callback();\n    }\n  },\n  cache: {}\n};\nconst fds = new Set();\n\nconst cleanup = exit => {\n  try {\n    fds.forEach(fdPath => {\n      const [fd, path] = fdPath;\n\n      try {\n        fs.closeSync(fd);\n      } catch (e) {// ignore\n      } finally {\n        try {\n          fs.unlinkSync(path);\n        } catch (e) {// ignore\n        }\n      }\n    });\n    fds.clear();\n  } finally {\n    if (exit) {\n      process.exit(0);\n    }\n  }\n};\n\nprocess.on(\"SIGINT\", cleanup);\nprocess.on(\"exit\", () => cleanup(false));\n\nFileDown.prototype._put = function (key, value, options, callback) {\n  const lKey = path.join(this.location, key); // This fixes an issue caused by writing AND reading the same key multiple times\n  // simultaneously. Sometimes the read operation would end up reading the value as 0 bytes\n  // due to the way writes are performed in node. To fix this, we implemented a queue so only a\n  // single read or write operation can occur at a time for each key; basically an in-memory lock.\n  // Additionally, during testing we found that it was possible for a write operation to fail\n  // due to program termination. This failure would sometimes cause the key to _exist_ but contain\n  // 0 bytes (which is always invalid). To fix this we write to a temp file, and only if it works\n  // do we move this temp file to its correct key location. This prevents early termination from\n  // writing partial/empty values.\n  // Of course, all this will eventually be for nothing as we are migrating the db to actual an\n  // leveldb implementation that doesn't use a separate file for every key Soon(TM).\n\n  accessQueue.execute(lKey, () => {\n    // get a tmp file to write the contents to...\n    tmp.file(this.tmpOptions, (err, path, fd, cleanupTmpFile) => {\n      if (err) {\n        callback(err);\n        accessQueue.next(lKey);\n        return;\n      }\n\n      const pair = [fd, path];\n      fds.add(pair);\n\n      const cleanupAndCallback = err => {\n        err && cleanupTmpFile();\n        fds.delete(pair);\n        callback(err);\n        accessQueue.next(lKey);\n      }; // write the value to our temporary file\n\n\n      fs.writeFile(fd, value, \"utf8\", err => {\n        if (err) {\n          cleanupAndCallback(err);\n          return;\n        } // It worked! Move the temporary file to its final destination\n\n\n        fs.rename(path, lKey, err => {\n          if (err) {\n            cleanupAndCallback(err);\n            return;\n          } // make sure we close this file descriptor now that the file is no\n          // longer \"temporary\" (because we successfully moved it)\n\n\n          fs.close(fd, () => cleanupAndCallback());\n        });\n      });\n    });\n  });\n};\n\nFileDown.prototype._get = function (key, options, callback) {\n  const lKey = path.join(this.location, key);\n  accessQueue.execute(lKey, () => {\n    fs.readFile(lKey, \"utf8\", (err, data) => {\n      if (err) {\n        callback(new Error(\"NotFound\"));\n      } else {\n        callback(null, data);\n      }\n\n      accessQueue.next(lKey);\n    });\n  });\n};\n\nFileDown.prototype._del = function (key, options, callback) {\n  fs.unlink(path.join(this.location, key), function (err) {\n    // Ignore when we try to delete a file that doesn't exist.\n    // I'm not sure why this happens. Worth looking into.\n    if (err) {\n      if (err.message.indexOf(\"ENOENT\") >= 0) {\n        return callback();\n      } else {\n        return callback(err);\n      }\n    }\n\n    callback();\n  });\n};\n\nFileDown.prototype._batch = function (array, options, callback) {\n  var self = this;\n  async.each(array, function (item, finished) {\n    if (item.type === \"put\") {\n      self.put(item.key, item.value, options, finished);\n    } else if (item.type === \"del\") {\n      self.del(item.key, options, finished);\n    } else {\n      finished(new Error(\"Unknown batch type\", item.type));\n    }\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback();\n  });\n};\n\nmodule.exports = function (location) {\n  return new FileDown(location);\n};","map":{"version":3,"names":["util","require","AbstractLevelDOWN","async","fs","path","tmp","inherits","FileDown","location","tmpDir","join","mkdirSync","recursive","mode","e","code","tmpOptions","keep","dir","call","prototype","_open","options","callback","self","accessQueue","next","lKey","cont","cache","shift","execute","push","fds","Set","cleanup","exit","forEach","fdPath","fd","closeSync","unlinkSync","clear","process","on","_put","key","value","file","err","cleanupTmpFile","pair","add","cleanupAndCallback","delete","writeFile","rename","close","_get","readFile","data","Error","_del","unlink","message","indexOf","_batch","array","each","item","finished","type","put","del","module","exports"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/lib/database/filedown.js"],"sourcesContent":["var util = require(\"util\");\nvar AbstractLevelDOWN = require(\"abstract-leveldown\").AbstractLevelDOWN;\nvar async = require(\"async\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar tmp = require(\"tmp\");\n\nutil.inherits(FileDown, AbstractLevelDOWN);\n\nfunction FileDown(location) {\n  this.location = location;\n  const tmpDir = path.join(location, \"_tmp\");\n  try {\n    // Fixes https://github.com/trufflesuite/ganache/issues/1617\n    fs.mkdirSync(tmpDir, { recursive: true, mode: 0o1777 });\n  } catch (e) {\n    // `recursive` doesn't throw if the file exists, but `recursive` doesn't\n    // exist in Node 8, so we catch the EEXISTS error in that case and ignore it.\n    // once we drop node 8 suport we can remove this try/catch\n    if (e.code !== \"EEXIST\") {\n      throw e;\n    }\n  }\n  this.tmpOptions = { keep: true, dir: tmpDir };\n  AbstractLevelDOWN.call(this, location);\n}\n\nFileDown.prototype._open = function(options, callback) {\n  var self = this;\n  callback(null, self);\n};\nconst accessQueue = {\n  next: (lKey) => {\n    const cont = accessQueue.cache[lKey].shift();\n    if (cont) {\n      cont();\n    } else {\n      delete accessQueue.cache[lKey];\n    }\n  },\n  execute: (lKey, callback) => {\n    const cache = accessQueue.cache[lKey];\n    if (cache) {\n      cache.push(callback);\n    } else {\n      accessQueue.cache[lKey] = [];\n      callback();\n    }\n  },\n  cache: {}\n};\n\nconst fds = new Set();\nconst cleanup = (exit) => {\n  try {\n    fds.forEach((fdPath) => {\n      const [fd, path] = fdPath;\n      try {\n        fs.closeSync(fd);\n      } catch (e) {\n        // ignore\n      } finally {\n        try {\n          fs.unlinkSync(path);\n        } catch (e) {\n          // ignore\n        }\n      }\n    });\n    fds.clear();\n  } finally {\n    if (exit) {\n      process.exit(0);\n    }\n  }\n};\nprocess.on(\"SIGINT\", cleanup);\nprocess.on(\"exit\", () => cleanup(false));\n\nFileDown.prototype._put = function(key, value, options, callback) {\n  const lKey = path.join(this.location, key);\n  // This fixes an issue caused by writing AND reading the same key multiple times\n  // simultaneously. Sometimes the read operation would end up reading the value as 0 bytes\n  // due to the way writes are performed in node. To fix this, we implemented a queue so only a\n  // single read or write operation can occur at a time for each key; basically an in-memory lock.\n  // Additionally, during testing we found that it was possible for a write operation to fail\n  // due to program termination. This failure would sometimes cause the key to _exist_ but contain\n  // 0 bytes (which is always invalid). To fix this we write to a temp file, and only if it works\n  // do we move this temp file to its correct key location. This prevents early termination from\n  // writing partial/empty values.\n  // Of course, all this will eventually be for nothing as we are migrating the db to actual an\n  // leveldb implementation that doesn't use a separate file for every key Soon(TM).\n  accessQueue.execute(lKey, () => {\n    // get a tmp file to write the contents to...\n    tmp.file(this.tmpOptions, (err, path, fd, cleanupTmpFile) => {\n      if (err) {\n        callback(err);\n        accessQueue.next(lKey);\n        return;\n      }\n      const pair = [fd, path];\n      fds.add(pair);\n      const cleanupAndCallback = (err) => {\n        err && cleanupTmpFile();\n        fds.delete(pair);\n        callback(err);\n        accessQueue.next(lKey);\n      };\n\n      // write the value to our temporary file\n      fs.writeFile(fd, value, \"utf8\", (err) => {\n        if (err) {\n          cleanupAndCallback(err);\n          return;\n        }\n\n        // It worked! Move the temporary file to its final destination\n        fs.rename(path, lKey, (err) => {\n          if (err) {\n            cleanupAndCallback(err);\n            return;\n          }\n\n          // make sure we close this file descriptor now that the file is no\n          // longer \"temporary\" (because we successfully moved it)\n          fs.close(fd, () => cleanupAndCallback());\n        });\n      });\n    });\n  });\n};\n\nFileDown.prototype._get = function(key, options, callback) {\n  const lKey = path.join(this.location, key);\n  accessQueue.execute(lKey, () => {\n    fs.readFile(lKey, \"utf8\", (err, data) => {\n      if (err) {\n        callback(new Error(\"NotFound\"));\n      } else {\n        callback(null, data);\n      }\n      accessQueue.next(lKey);\n    });\n  });\n};\n\nFileDown.prototype._del = function(key, options, callback) {\n  fs.unlink(path.join(this.location, key), function(err) {\n    // Ignore when we try to delete a file that doesn't exist.\n    // I'm not sure why this happens. Worth looking into.\n    if (err) {\n      if (err.message.indexOf(\"ENOENT\") >= 0) {\n        return callback();\n      } else {\n        return callback(err);\n      }\n    }\n    callback();\n  });\n};\n\nFileDown.prototype._batch = function(array, options, callback) {\n  var self = this;\n  async.each(\n    array,\n    function(item, finished) {\n      if (item.type === \"put\") {\n        self.put(item.key, item.value, options, finished);\n      } else if (item.type === \"del\") {\n        self.del(item.key, options, finished);\n      } else {\n        finished(new Error(\"Unknown batch type\", item.type));\n      }\n    },\n    function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    }\n  );\n};\n\nmodule.exports = function(location) {\n  return new FileDown(location);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
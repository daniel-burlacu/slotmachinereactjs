{"ast":null,"code":"const assert = require('assert');\n\nconst levelup = require('levelup');\n\nconst memdown = require('memdown');\n\nconst async = require('async');\n\nconst rlp = require('rlp');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst semaphore = require('semaphore');\n\nconst TrieNode = require('./trieNode');\n\nconst ReadStream = require('./readStream');\n\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\n\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\n\nconst doKeysMatch = require('./util').doKeysMatch;\n\nconst callTogether = require('./util').callTogether;\n\nconst asyncFirstSeries = require('./util').asyncFirstSeries;\n\nmodule.exports = Trie;\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\n\nfunction Trie(db, root) {\n  var self = this;\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n  this.sem = semaphore(1); // setup dbs\n\n  this.db = db || levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this.db];\n  this._putDBs = [this.db];\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value);\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n      } else {\n        value = self.EMPTY_TRIE_ROOT;\n      }\n\n      this._root = value;\n    },\n    get: function () {\n      return this._root;\n    }\n  });\n  this.root = root;\n}\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\n\n\nTrie.prototype.get = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null;\n\n    if (node && remainder.length === 0) {\n      value = node.value;\n    }\n\n    cb(err, value);\n  });\n};\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\n\n\nTrie.prototype.put = function (key, value, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  value = ethUtil.toBuffer(value);\n\n  if (!value || value.toString() === '') {\n    self.del(key, cb);\n  } else {\n    cb = callTogether(cb, self.sem.leave);\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          } // then update\n\n\n          self._updateNode(key, value, keyRemainder, stack, cb);\n        });\n      } else {\n        self._createInitialNode(key, value, cb); // if no root initialize this trie\n\n      }\n    });\n  }\n};\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\n\n\nTrie.prototype.del = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (foundValue) {\n        self._deleteNode(key, stack, cb);\n      } else {\n        cb();\n      }\n    });\n  });\n};\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\n\n\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key);\n\n  function dbGet(db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null);\n      } else {\n        cb2(null, foundNode);\n      }\n    });\n  }\n\n  asyncFirstSeries(this._getDBs, dbGet, cb);\n}; // retrieves a node from dbs by hash\n\n\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node));\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err;\n      }\n\n      if (value) {\n        value = new TrieNode(rlp.decode(value));\n      }\n\n      cb(value);\n    });\n  }\n}; // TODO: remove the proxy method when changing the caching\n\n\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this._putDBs, dbPut, cb);\n};\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\n\n\nTrie.prototype.putRaw = Trie.prototype._putRaw;\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\n\nTrie.prototype.delRaw = function (key, cb) {\n  function del(db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this._putDBs, del, cb);\n}; // writes a single node to dbs\n\n\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash();\n  var serialized = node.serialize();\n\n  this._putRaw(hash, serialized, cb);\n}; // writes many nodes to db\n\n\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch(db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb);\n  }\n\n  async.each(this._putDBs, dbBatch, cb);\n};\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this;\n  var root = self.root;\n  var stack = [];\n  targetKey = TrieNode.stringToNibbles(targetKey);\n\n  this._walkTrie(root, processNode, cb);\n\n  function processNode(nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || [];\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n    stack.push(node);\n\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack); // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0];\n        var branchNode = node.getValue(branchIndex);\n\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack);\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex);\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack);\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack);\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack);\n      } else {\n        // keys match, continue search\n        walkController.next();\n      }\n    }\n  }\n};\n/*\n * Finds all nodes that store k,v values\n */\n\n\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments);\n  });\n};\n/*\n * Finds all nodes that store k,v values\n */\n\n\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key;\n\n    if (node.key) {\n      fullKey = key.concat(node.key);\n    }\n\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else {\n      // keep looking for value nodes\n      walkController.next();\n    }\n  }, cb);\n};\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\n\n\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next();\n    } else {\n      onFound(nodeRef, node, key, walkController.next);\n    }\n  }, cb);\n};\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\n\n\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = [];\n  var lastNode = stack.pop(); // add the new nodes\n\n  key = TrieNode.stringToNibbles(key); // Check if the last node is a leaf and the key matches to this\n\n  var matchLeaf = false;\n\n  if (lastNode.type === 'leaf') {\n    var l = 0;\n\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i];\n\n      if (n.type === 'branch') {\n        l++;\n      } else {\n        l += n.key.length;\n      }\n    }\n\n    if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n      matchLeaf = true;\n    }\n  }\n\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value;\n    stack.push(lastNode);\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode);\n\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift(); // create a new leaf\n\n      var newLeaf = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeaf);\n    } else {\n      lastNode.value = value;\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key;\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n    var newBranchNode = new TrieNode('branch'); // create a new extention node\n\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength);\n      var newExtNode = new TrieNode('extention', newKey, value);\n      stack.push(newExtNode);\n      lastKey.splice(0, matchingLength);\n      keyRemainder.splice(0, matchingLength);\n    }\n\n    stack.push(newBranchNode);\n\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift();\n\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey;\n\n        var formatedNode = this._formatNode(lastNode, false, toSave);\n\n        newBranchNode.setValue(branchKey, formatedNode);\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave);\n\n        newBranchNode.setValue(branchKey, lastNode.value);\n      }\n    } else {\n      newBranchNode.value = lastNode.value;\n    }\n\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift(); // add a leaf node to the new branch node\n\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeafNode);\n    } else {\n      newBranchNode.value = value;\n    }\n  }\n\n  this._saveStack(key, stack, toSave, cb);\n}; // walk tree\n\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this;\n  root = root || self.root;\n\n  onDone = onDone || function () {};\n\n  var aborted = false;\n  var returnValues = [];\n\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone();\n  }\n\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err);\n      }\n\n      onDone.apply(null, returnValues);\n    });\n  }); // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n\n\n  var maxPoolSize = 500;\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n\n  function processNode(nodeRef, node, key, cb) {\n    if (!node) return cb();\n    if (aborted) return cb();\n    var stopped = false;\n    key = key || [];\n    var walkController = {\n      stop: function () {\n        stopped = true;\n        cb();\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true;\n        returnValues = arguments;\n        cb();\n      },\n      next: function () {\n        if (aborted) {\n          return cb();\n        }\n\n        if (stopped) {\n          return cb();\n        }\n\n        var children = node.getChildren();\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0];\n          var childRef = childData[1];\n          var childKey = key.concat(keyExtension);\n          var priority = childKey.length;\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback();\n              processNode(childRef, childNode, childKey, cb);\n            });\n          });\n        }, cb);\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex);\n        var childKey = key.slice();\n        childKey.push(childIndex);\n        var priority = childKey.length;\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback();\n            processNode(childRef, childNode, childKey, cb);\n          });\n        });\n      }\n    };\n    onNode(nodeRef, node, key, walkController);\n  }\n};\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\n\n\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot; // update nodes\n\n  while (stack.length) {\n    var node = stack.pop();\n\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length);\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length);\n\n      if (lastRoot) {\n        node.value = lastRoot;\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop();\n        node.setValue(branchKey, lastRoot);\n      }\n    }\n\n    lastRoot = this._formatNode(node, stack.length === 0, opStack);\n  }\n\n  if (lastRoot) {\n    this.root = lastRoot;\n  }\n\n  this._batchNodes(opStack, cb);\n};\n\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key;\n\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null);\n        stack.push(extentionNode);\n        key.push(branchKey);\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey);\n        branchNode.key = branchNodeKey; // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n\n        branchNodeKey.unshift(0);\n        branchNodeKey.unshift(key.length);\n        key.splice.apply(key, branchNodeKey);\n      }\n\n      stack.push(branchNode);\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key;\n\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey);\n        key.push(branchKey);\n        parentNode.key = parentKey;\n        stack.push(parentNode);\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey);\n        key = key.concat(branchNodeKey);\n        parentKey = parentKey.concat(branchNodeKey);\n        branchNode.key = parentKey;\n      }\n\n      stack.push(branchNode);\n    }\n\n    return key;\n  }\n\n  var lastNode = stack.pop();\n  var parentNode = stack.pop();\n  var opStack = [];\n  var self = this;\n\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key);\n  }\n\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT;\n    cb();\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null;\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key;\n      key.splice(key.length - lastNodeKey.length); // delete the value\n\n      this._formatNode(lastNode, false, true, opStack);\n\n      parentNode.setValue(key.pop(), null);\n      lastNode = parentNode;\n      parentNode = stack.pop();\n    } // nodes on the branch\n\n\n    var branchNodes = []; // count the number of nodes on the branch\n\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i);\n      if (val) branchNodes.push([i, val]);\n    }); // if there is only one branch node left, collapse the branch node\n\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1];\n      var branchNodeKey = branchNodes[0][0]; // look up node\n\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n\n        self._saveStack(key, stack, opStack, cb);\n      });\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n\n      stack.push(lastNode);\n\n      self._saveStack(key, stack, opStack, cb);\n    }\n  }\n}; // Creates the initial node from an empty tree\n\n\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value);\n  this.root = newNode.hash();\n\n  this._putNode(newNode, cb);\n}; // formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\n\n\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove;\n    remove = false;\n  }\n\n  var rlpNode = node.serialize();\n\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash();\n\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      });\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      });\n    }\n\n    return hashRoot;\n  }\n\n  return node.raw;\n};\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\n\n\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this);\n}; // creates a new trie backed by the same db\n// and starting at the same root\n\n\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root);\n};\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\n\n\nTrie.prototype.batch = function (ops, cb) {\n  var self = this;\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2);\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2);\n    } else {\n      cb2();\n    }\n  }, cb);\n};\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\n\n\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root);\n\n  this._lookupNode(root, function (value) {\n    cb(null, !!value);\n  });\n};","map":{"version":3,"names":["assert","require","levelup","memdown","async","rlp","ethUtil","semaphore","TrieNode","ReadStream","PrioritizedTaskExecutor","matchingNibbleLength","doKeysMatch","callTogether","asyncFirstSeries","module","exports","Trie","db","root","self","EMPTY_TRIE_ROOT","SHA3_RLP","sem","_getDBs","_putDBs","Object","defineProperty","set","value","toBuffer","length","_root","get","prototype","key","cb","findPath","err","node","remainder","stack","put","toString","del","leave","take","foundValue","keyRemainder","_updateNode","_createInitialNode","_deleteNode","getRaw","dbGet","cb2","keyEncoding","valueEncoding","foundNode","_lookupNode","isRawNode","decode","_putRaw","val","dbPut","each","putRaw","delRaw","_putNode","hash","serialized","serialize","_batchNodes","opStack","dbBatch","batch","targetKey","stringToNibbles","_walkTrie","processNode","nodeRef","keyProgress","walkController","nodeKey","slice","matchingLen","push","type","return","branchIndex","branchNode","getValue","only","next","_findNode","apply","arguments","_findValueNodes","onFound","fullKey","concat","_findDbNodes","toSave","lastNode","pop","matchLeaf","l","i","n","shift","newLeaf","lastKey","matchingLength","newBranchNode","newKey","newExtNode","splice","branchKey","formatedNode","_formatNode","setValue","newLeafNode","_saveStack","onNode","onDone","aborted","returnValues","maxPoolSize","taskExecutor","stopped","stop","children","getChildren","forEachOf","childData","index","keyExtension","childRef","childKey","priority","execute","taskCallback","childNode","childIndex","lastRoot","processBranchNode","parentNode","branchNodeKey","extentionNode","unshift","parentKey","Array","isArray","lastNodeKey","branchNodes","raw","forEach","newNode","topLevel","remove","rlpNode","hashRoot","isCheckpoint","createReadStream","copy","ops","eachSeries","op","checkRoot"],"sources":["F:/Games/slotmachinereact/node_modules/ganache-core/node_modules/ethereumjs-vm/node_modules/merkle-patricia-tree/baseTrie.js"],"sourcesContent":["const assert = require('assert')\nconst levelup = require('levelup')\nconst memdown = require('memdown')\nconst async = require('async')\nconst rlp = require('rlp')\nconst ethUtil = require('ethereumjs-util')\nconst semaphore = require('semaphore')\nconst TrieNode = require('./trieNode')\nconst ReadStream = require('./readStream')\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\nconst doKeysMatch = require('./util').doKeysMatch\nconst callTogether = require('./util').callTogether\nconst asyncFirstSeries = require('./util').asyncFirstSeries\n\nmodule.exports = Trie\n\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\nfunction Trie (db, root) {\n  var self = this\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP\n  this.sem = semaphore(1)\n\n  // setup dbs\n  this.db = db ||\n    levelup('', {\n      db: memdown\n    })\n\n  this._getDBs = [this.db]\n  this._putDBs = [this.db]\n\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value)\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes')\n      } else {\n        value = self.EMPTY_TRIE_ROOT\n      }\n\n      this._root = value\n    },\n    get: function () {\n      return this._root\n    }\n  })\n\n  this.root = root\n}\n\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\nTrie.prototype.get = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null\n    if (node && remainder.length === 0) {\n      value = node.value\n    }\n\n    cb(err, value)\n  })\n}\n\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.put = function (key, value, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  value = ethUtil.toBuffer(value)\n\n  if (!value || value.toString() === '') {\n    self.del(key, cb)\n  } else {\n    cb = callTogether(cb, self.sem.leave)\n\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err)\n          }\n          // then update\n          self._updateNode(key, value, keyRemainder, stack, cb)\n        })\n      } else {\n        self._createInitialNode(key, value, cb) // if no root initialize this trie\n      }\n    })\n  }\n}\n\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\nTrie.prototype.del = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  cb = callTogether(cb, self.sem.leave)\n\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err)\n      }\n      if (foundValue) {\n        self._deleteNode(key, stack, cb)\n      } else {\n        cb()\n      }\n    })\n  })\n}\n\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key)\n\n  function dbGet (db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null)\n      } else {\n        cb2(null, foundNode)\n      }\n    })\n  }\n  asyncFirstSeries(this._getDBs, dbGet, cb)\n}\n\n// retrieves a node from dbs by hash\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node))\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err\n      }\n\n      if (value) {\n        value = new TrieNode(rlp.decode(value))\n      }\n\n      cb(value)\n    })\n  }\n}\n\n// TODO: remove the proxy method when changing the caching\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut (db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, dbPut, cb)\n}\n\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.putRaw = Trie.prototype._putRaw\n\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.delRaw = function (key, cb) {\n  function del (db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, del, cb)\n}\n\n// writes a single node to dbs\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash()\n  var serialized = node.serialize()\n  this._putRaw(hash, serialized, cb)\n}\n\n// writes many nodes to db\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch (db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb)\n  }\n\n  async.each(this._putDBs, dbBatch, cb)\n}\n\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this\n  var root = self.root\n  var stack = []\n  targetKey = TrieNode.stringToNibbles(targetKey)\n\n  this._walkTrie(root, processNode, cb)\n\n  function processNode (nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || []\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey))\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey)\n\n    stack.push(node)\n\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack)\n      // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0]\n        var branchNode = node.getValue(branchIndex)\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack)\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex)\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack)\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack)\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack)\n      } else {\n        // keys match, continue search\n        walkController.next()\n      }\n    }\n  }\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments)\n  })\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key\n\n    if (node.key) {\n      fullKey = key.concat(node.key)\n    }\n\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else {\n      // keep looking for value nodes\n      walkController.next()\n    }\n  }, cb)\n}\n\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next()\n    } else {\n      onFound(nodeRef, node, key, walkController.next)\n    }\n  }, cb)\n}\n\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = []\n  var lastNode = stack.pop()\n\n  // add the new nodes\n  key = TrieNode.stringToNibbles(key)\n\n  // Check if the last node is a leaf and the key matches to this\n  var matchLeaf = false\n  if (lastNode.type === 'leaf') {\n    var l = 0\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i]\n      if (n.type === 'branch') {\n        l++\n      } else {\n        l += n.key.length\n      }\n    }\n    if ((matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length) && (keyRemainder.length === 0)) {\n      matchLeaf = true\n    }\n  }\n\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value\n    stack.push(lastNode)\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode)\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift()\n      // create a new leaf\n      var newLeaf = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeaf)\n    } else {\n      lastNode.value = value\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder)\n    var newBranchNode = new TrieNode('branch')\n\n    // create a new extention node\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength)\n      var newExtNode = new TrieNode('extention', newKey, value)\n      stack.push(newExtNode)\n      lastKey.splice(0, matchingLength)\n      keyRemainder.splice(0, matchingLength)\n    }\n\n    stack.push(newBranchNode)\n\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift()\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey\n        var formatedNode = this._formatNode(lastNode, false, toSave)\n        newBranchNode.setValue(branchKey, formatedNode)\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave)\n        newBranchNode.setValue(branchKey, lastNode.value)\n      }\n    } else {\n      newBranchNode.value = lastNode.value\n    }\n\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift()\n      // add a leaf node to the new branch node\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeafNode)\n    } else {\n      newBranchNode.value = value\n    }\n  }\n\n  this._saveStack(key, stack, toSave, cb)\n}\n\n// walk tree\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this\n  root = root || self.root\n  onDone = onDone || function () {}\n  var aborted = false\n  var returnValues = []\n\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone()\n  }\n\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err)\n      }\n      onDone.apply(null, returnValues)\n    })\n  })\n\n  // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n  var maxPoolSize = 500\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize)\n\n  function processNode (nodeRef, node, key, cb) {\n    if (!node) return cb()\n    if (aborted) return cb()\n    var stopped = false\n    key = key || []\n\n    var walkController = {\n      stop: function () {\n        stopped = true\n        cb()\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true\n        returnValues = arguments\n        cb()\n      },\n      next: function () {\n        if (aborted) {\n          return cb()\n        }\n        if (stopped) {\n          return cb()\n        }\n        var children = node.getChildren()\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0]\n          var childRef = childData[1]\n          var childKey = key.concat(keyExtension)\n          var priority = childKey.length\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback()\n              processNode(childRef, childNode, childKey, cb)\n            })\n          })\n        }, cb)\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex)\n        var childKey = key.slice()\n        childKey.push(childIndex)\n        var priority = childKey.length\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback()\n            processNode(childRef, childNode, childKey, cb)\n          })\n        })\n      }\n    }\n    onNode(nodeRef, node, key, walkController)\n  }\n}\n\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot\n\n  // update nodes\n  while (stack.length) {\n    var node = stack.pop()\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length)\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length)\n      if (lastRoot) {\n        node.value = lastRoot\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop()\n        node.setValue(branchKey, lastRoot)\n      }\n    }\n    lastRoot = this._formatNode(node, stack.length === 0, opStack)\n  }\n\n  if (lastRoot) {\n    this.root = lastRoot\n  }\n\n  this._batchNodes(opStack, cb)\n}\n\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode (key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null)\n        stack.push(extentionNode)\n        key.push(branchKey)\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey)\n        branchNode.key = branchNodeKey\n\n        // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n        branchNodeKey.unshift(0)\n        branchNodeKey.unshift(key.length)\n        key.splice.apply(key, branchNodeKey)\n      }\n      stack.push(branchNode)\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey)\n        key.push(branchKey)\n        parentNode.key = parentKey\n        stack.push(parentNode)\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey)\n        key = key.concat(branchNodeKey)\n        parentKey = parentKey.concat(branchNodeKey)\n        branchNode.key = parentKey\n      }\n      stack.push(branchNode)\n    }\n\n    return key\n  }\n\n  var lastNode = stack.pop()\n  var parentNode = stack.pop()\n  var opStack = []\n  var self = this\n\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key)\n  }\n\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT\n    cb()\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key\n      key.splice(key.length - lastNodeKey.length)\n      // delete the value\n      this._formatNode(lastNode, false, true, opStack)\n      parentNode.setValue(key.pop(), null)\n      lastNode = parentNode\n      parentNode = stack.pop()\n    }\n\n    // nodes on the branch\n    var branchNodes = []\n    // count the number of nodes on the branch\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i)\n      if (val) branchNodes.push([i, val])\n    })\n\n    // if there is only one branch node left, collapse the branch node\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1]\n      var branchNodeKey = branchNodes[0][0]\n\n      // look up node\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack)\n        self._saveStack(key, stack, opStack, cb)\n      })\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      stack.push(lastNode)\n      self._saveStack(key, stack, opStack, cb)\n    }\n  }\n}\n\n// Creates the initial node from an empty tree\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value)\n  this.root = newNode.hash()\n  this._putNode(newNode, cb)\n}\n\n// formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove\n    remove = false\n  }\n\n  var rlpNode = node.serialize()\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash()\n\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      })\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      })\n    }\n    return hashRoot\n  }\n  return node.raw\n}\n\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this)\n}\n\n// creates a new trie backed by the same db\n// and starting at the same root\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root)\n}\n\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\nTrie.prototype.batch = function (ops, cb) {\n  var self = this\n\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2)\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2)\n    } else {\n      cb2()\n    }\n  }, cb)\n}\n\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root)\n  this._lookupNode(root, function (value) {\n    cb(null, !!value)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
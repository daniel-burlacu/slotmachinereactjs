{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.saveOutput = void 0;\n\nconst path_1 = require(\"path\");\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst getHumanReadableAbi_1 = require(\"./getHumanReadableAbi\");\n\nconst mkdirp_1 = __importDefault(require(\"mkdirp\"));\n\nconst fsOps = {\n  createDirectory: mkdirp_1.default.sync,\n  writeFile: fs_1.default.writeFileSync\n};\n\nasync function saveOutput(output, config) {\n  let filesystem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsOps;\n  config.outputType = config.outputType || 'multiple';\n  filesystem.createDirectory(config.outputDirectory);\n\n  if (['multiple', 'all'].includes(config.outputType)) {\n    saveOutputSingletons(output, config, filesystem);\n  }\n\n  if (['combined', 'all'].includes(config.outputType)) {\n    saveOutputCombined(output, config, filesystem);\n  }\n\n  if (['minimal'].includes(config.outputType)) {\n    saveOutputMinimal(output, config, filesystem);\n  }\n}\n\nexports.saveOutput = saveOutput;\n\nasync function saveOutputMinimal(output, config) {\n  let filesystem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsOps;\n\n  for (const [, file] of Object.entries(output.contracts)) {\n    for (const [contractName, contractJson] of Object.entries(file)) {\n      const filePath = path_1.join(config.outputDirectory, `${contractName}.json`);\n      filesystem.writeFile(filePath, getMinimalContent(contractJson, config));\n    }\n  }\n}\n\nfunction getMinimalContent(contractJson, config) {\n  const abi = config.outputHumanReadableAbi ? getHumanReadableAbi_1.getHumanReadableAbi(contractJson.abi) : contractJson.abi;\n  const bytecode = contractJson.evm.bytecode.object;\n  return JSON.stringify({\n    abi,\n    bytecode\n  }, null, 2);\n}\n\nasync function saveOutputSingletons(output, config) {\n  let filesystem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsOps;\n\n  for (const [, file] of Object.entries(output.contracts)) {\n    for (const [contractName, contractJson] of Object.entries(file)) {\n      const filePath = path_1.join(config.outputDirectory, `${contractName}.json`);\n      filesystem.writeFile(filePath, getContent(contractJson, config));\n    }\n  }\n}\n\nasync function saveOutputCombined(output, config) {\n  let filesystem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsOps;\n\n  for (const [key, file] of Object.entries(output.contracts)) {\n    for (const [contractName, contractJson] of Object.entries(file)) {\n      contractJson.bin = contractJson.evm.bytecode.object;\n      contractJson['bin-runtime'] = contractJson.evm.deployedBytecode.object;\n      contractJson.srcmap = contractJson.evm.bytecode.sourceMap;\n      contractJson['srcmap-runtime'] = contractJson.evm.deployedBytecode.sourceMap;\n      output.contracts[String(key) + ':' + String(contractName)] = contractJson;\n    }\n\n    delete output.contracts[key];\n  }\n\n  const allSources = [];\n\n  for (const [key, value] of Object.entries(output.sources)) {\n    value.AST = value.ast;\n    delete value.ast;\n    allSources.push(key);\n  }\n\n  output.sourceList = allSources;\n  filesystem.writeFile(path_1.join(config.outputDirectory, 'Combined-Json.json'), JSON.stringify(output, null, 2));\n}\n\nfunction getContent(contractJson, config) {\n  contractJson.bytecode = contractJson.evm.bytecode.object;\n\n  if (config.outputHumanReadableAbi) {\n    contractJson.humanReadableAbi = getHumanReadableAbi_1.getHumanReadableAbi(contractJson.abi);\n  }\n\n  return JSON.stringify(contractJson, null, 2);\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","saveOutput","path_1","require","fs_1","getHumanReadableAbi_1","mkdirp_1","fsOps","createDirectory","default","sync","writeFile","writeFileSync","output","config","filesystem","outputType","outputDirectory","includes","saveOutputSingletons","saveOutputCombined","saveOutputMinimal","file","entries","contracts","contractName","contractJson","filePath","join","getMinimalContent","abi","outputHumanReadableAbi","getHumanReadableAbi","bytecode","evm","object","JSON","stringify","getContent","key","bin","deployedBytecode","srcmap","sourceMap","String","allSources","sources","AST","ast","push","sourceList","humanReadableAbi"],"sources":["F:/Games/slotmachinereact/node_modules/@ethereum-waffle/compiler/dist/cjs/saveOutput.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.saveOutput = void 0;\nconst path_1 = require(\"path\");\nconst fs_1 = __importDefault(require(\"fs\"));\nconst getHumanReadableAbi_1 = require(\"./getHumanReadableAbi\");\nconst mkdirp_1 = __importDefault(require(\"mkdirp\"));\nconst fsOps = {\n    createDirectory: mkdirp_1.default.sync,\n    writeFile: fs_1.default.writeFileSync\n};\nasync function saveOutput(output, config, filesystem = fsOps) {\n    config.outputType = config.outputType || 'multiple';\n    filesystem.createDirectory(config.outputDirectory);\n    if (['multiple', 'all'].includes(config.outputType)) {\n        saveOutputSingletons(output, config, filesystem);\n    }\n    if (['combined', 'all'].includes(config.outputType)) {\n        saveOutputCombined(output, config, filesystem);\n    }\n    if (['minimal'].includes(config.outputType)) {\n        saveOutputMinimal(output, config, filesystem);\n    }\n}\nexports.saveOutput = saveOutput;\nasync function saveOutputMinimal(output, config, filesystem = fsOps) {\n    for (const [, file] of Object.entries(output.contracts)) {\n        for (const [contractName, contractJson] of Object.entries(file)) {\n            const filePath = path_1.join(config.outputDirectory, `${contractName}.json`);\n            filesystem.writeFile(filePath, getMinimalContent(contractJson, config));\n        }\n    }\n}\nfunction getMinimalContent(contractJson, config) {\n    const abi = config.outputHumanReadableAbi\n        ? getHumanReadableAbi_1.getHumanReadableAbi(contractJson.abi)\n        : contractJson.abi;\n    const bytecode = contractJson.evm.bytecode.object;\n    return JSON.stringify({ abi, bytecode }, null, 2);\n}\nasync function saveOutputSingletons(output, config, filesystem = fsOps) {\n    for (const [, file] of Object.entries(output.contracts)) {\n        for (const [contractName, contractJson] of Object.entries(file)) {\n            const filePath = path_1.join(config.outputDirectory, `${contractName}.json`);\n            filesystem.writeFile(filePath, getContent(contractJson, config));\n        }\n    }\n}\nasync function saveOutputCombined(output, config, filesystem = fsOps) {\n    for (const [key, file] of Object.entries(output.contracts)) {\n        for (const [contractName, contractJson] of Object.entries(file)) {\n            contractJson.bin = contractJson.evm.bytecode.object;\n            contractJson['bin-runtime'] = contractJson.evm.deployedBytecode.object;\n            contractJson.srcmap = contractJson.evm.bytecode.sourceMap;\n            contractJson['srcmap-runtime'] = contractJson.evm.deployedBytecode.sourceMap;\n            output.contracts[String(key) + ':' + String(contractName)] = contractJson;\n        }\n        delete output.contracts[key];\n    }\n    const allSources = [];\n    for (const [key, value] of Object.entries(output.sources)) {\n        value.AST = value.ast;\n        delete value.ast;\n        allSources.push(key);\n    }\n    output.sourceList = allSources;\n    filesystem.writeFile(path_1.join(config.outputDirectory, 'Combined-Json.json'), JSON.stringify(output, null, 2));\n}\nfunction getContent(contractJson, config) {\n    contractJson.bytecode = contractJson.evm.bytecode.object;\n    if (config.outputHumanReadableAbi) {\n        contractJson.humanReadableAbi = getHumanReadableAbi_1.getHumanReadableAbi(contractJson.abi);\n    }\n    return JSON.stringify(contractJson, null, 2);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
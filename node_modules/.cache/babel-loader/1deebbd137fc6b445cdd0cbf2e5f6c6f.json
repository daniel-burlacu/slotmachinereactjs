{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ENS = exports.deployENS = exports.createReverseRegistrar = exports.createResolver = void 0;\n\nconst ens_1 = require(\"@ensdomains/ens\");\n\nconst resolver_1 = require(\"@ensdomains/resolver\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst {\n  namehash\n} = ethers_1.utils;\nconst {\n  HashZero\n} = ethers_1.constants;\n\nasync function createResolver(signer, ens) {\n  const resolver = await utils_1.deployContract(signer, resolver_1.PublicResolver, [ens.address]);\n  const resolverNode = namehash('resolver');\n  const resolverLabel = ethers_1.utils.id('resolver');\n  await ens.setSubnodeOwner(HashZero, resolverLabel, await signer.getAddress());\n  await ens.setResolver(resolverNode, resolver.address);\n  await resolver['setAddr(bytes32,uint256,bytes)'](resolverNode, utils_1.COIN_TYPE_ETH, resolver.address);\n  return resolver;\n}\n\nexports.createResolver = createResolver;\n\nasync function createReverseRegistrar(signer, ens, resolver) {\n  const reverseRegistrar = await utils_1.deployContract(signer, ens_1.ReverseRegistrar, [ens.address, resolver.address]);\n  await ens.setSubnodeOwner(HashZero, ethers_1.utils.id('reverse'), await signer.getAddress());\n  await ens.setSubnodeOwner(namehash('reverse'), ethers_1.utils.id('addr'), reverseRegistrar.address);\n  return reverseRegistrar;\n}\n\nexports.createReverseRegistrar = createReverseRegistrar;\n\nasync function deployENS(signer) {\n  const ens = await utils_1.deployContract(signer, ens_1.ENSRegistry, []);\n  const resolver = await createResolver(signer, ens);\n  const reverseRegistrar = await createReverseRegistrar(signer, ens, resolver);\n  return new ENS(signer, ens, resolver, reverseRegistrar);\n}\n\nexports.deployENS = deployENS;\n\nclass ENS {\n  constructor(signer, ens, resolver, reverseRegistrar) {\n    this.registrars = {};\n    this.signer = signer;\n    this.ens = ens;\n    this.resolver = resolver;\n    this.reverseRegistrar = reverseRegistrar;\n  }\n\n  async createTopLevelDomain(domain) {\n    const node = namehash(domain);\n    this.registrars = { ...this.registrars,\n      [domain]: await utils_1.deployContract(this.signer, ens_1.FIFSRegistrar, [this.ens.address, node])\n    };\n    await this.ens.setSubnodeOwner(HashZero, ethers_1.utils.id(domain), this.registrars[domain].address);\n  }\n\n  async createSubDomainNonRecursive(domain) {\n    const {\n      label,\n      node,\n      decodedRootNode\n    } = utils_1.getDomainInfo(domain);\n    await this.registrars[decodedRootNode].register(label, await this.signer.getAddress());\n    await this.ens.setResolver(node, this.resolver.address);\n    const registrar = await utils_1.deployContract(this.signer, ens_1.FIFSRegistrar, [this.ens.address, node]);\n    await this.ens.setOwner(node, registrar.address);\n    this.registrars = { ...this.registrars,\n      [domain]: registrar\n    };\n  }\n\n  async createDomain(domain, options) {\n    try {\n      utils_1.getDomainInfo(domain);\n      await this.createSubDomain(domain, options);\n    } catch (err) {\n      if (err instanceof errors_1.ExpectedTopLevelDomain) {\n        await this.createTopLevelDomain(domain);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async ensureDomainExist(domain, options) {\n    const recursive = (options === null || options === void 0 ? void 0 : options.recursive) || false;\n\n    if (!this.registrars[domain]) {\n      if (recursive) {\n        await this.createDomain(domain, options);\n      } else {\n        throw new errors_1.MissingDomain(domain);\n      }\n    }\n  }\n\n  async createSubDomain(domain, options) {\n    const {\n      decodedRootNode\n    } = utils_1.getDomainInfo(domain);\n    await this.ensureDomainExist(decodedRootNode, options);\n    await this.createSubDomainNonRecursive(domain);\n  }\n\n  async setAddressNonRecursive(domain, address) {\n    const {\n      node,\n      label,\n      decodedRootNode\n    } = utils_1.getDomainInfo(domain);\n    const registrar = this.registrars[decodedRootNode];\n    await registrar.register(label, await this.signer.getAddress());\n    await this.ens.setResolver(node, this.resolver.address);\n    await this.resolver['setAddr(bytes32,uint256,bytes)'](node, utils_1.COIN_TYPE_ETH, address);\n  }\n\n  async setAddress(domain, address, options) {\n    const {\n      decodedRootNode\n    } = utils_1.getDomainInfo(domain);\n    await this.ensureDomainExist(decodedRootNode, options);\n    await this.setAddressNonRecursive(domain, address);\n  }\n\n  async setAddressWithReverse(domain, signer, options) {\n    await this.setAddress(domain, await signer.getAddress(), options);\n    await this.reverseRegistrar.connect(signer).setName(domain);\n  }\n\n}\n\nexports.ENS = ENS;","map":{"version":3,"names":["Object","defineProperty","exports","value","ENS","deployENS","createReverseRegistrar","createResolver","ens_1","require","resolver_1","ethers_1","utils_1","errors_1","namehash","utils","HashZero","constants","signer","ens","resolver","deployContract","PublicResolver","address","resolverNode","resolverLabel","id","setSubnodeOwner","getAddress","setResolver","COIN_TYPE_ETH","reverseRegistrar","ReverseRegistrar","ENSRegistry","constructor","registrars","createTopLevelDomain","domain","node","FIFSRegistrar","createSubDomainNonRecursive","label","decodedRootNode","getDomainInfo","register","registrar","setOwner","createDomain","options","createSubDomain","err","ExpectedTopLevelDomain","ensureDomainExist","recursive","MissingDomain","setAddressNonRecursive","setAddress","setAddressWithReverse","connect","setName"],"sources":["F:/Games/slotmachinereact/node_modules/@ethereum-waffle/ens/dist/cjs/ENS.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ENS = exports.deployENS = exports.createReverseRegistrar = exports.createResolver = void 0;\nconst ens_1 = require(\"@ensdomains/ens\");\nconst resolver_1 = require(\"@ensdomains/resolver\");\nconst ethers_1 = require(\"ethers\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst { namehash } = ethers_1.utils;\nconst { HashZero } = ethers_1.constants;\nasync function createResolver(signer, ens) {\n    const resolver = await utils_1.deployContract(signer, resolver_1.PublicResolver, [ens.address]);\n    const resolverNode = namehash('resolver');\n    const resolverLabel = ethers_1.utils.id('resolver');\n    await ens.setSubnodeOwner(HashZero, resolverLabel, await signer.getAddress());\n    await ens.setResolver(resolverNode, resolver.address);\n    await resolver['setAddr(bytes32,uint256,bytes)'](resolverNode, utils_1.COIN_TYPE_ETH, resolver.address);\n    return resolver;\n}\nexports.createResolver = createResolver;\nasync function createReverseRegistrar(signer, ens, resolver) {\n    const reverseRegistrar = await utils_1.deployContract(signer, ens_1.ReverseRegistrar, [ens.address, resolver.address]);\n    await ens.setSubnodeOwner(HashZero, ethers_1.utils.id('reverse'), await signer.getAddress());\n    await ens.setSubnodeOwner(namehash('reverse'), ethers_1.utils.id('addr'), reverseRegistrar.address);\n    return reverseRegistrar;\n}\nexports.createReverseRegistrar = createReverseRegistrar;\nasync function deployENS(signer) {\n    const ens = await utils_1.deployContract(signer, ens_1.ENSRegistry, []);\n    const resolver = await createResolver(signer, ens);\n    const reverseRegistrar = await createReverseRegistrar(signer, ens, resolver);\n    return new ENS(signer, ens, resolver, reverseRegistrar);\n}\nexports.deployENS = deployENS;\nclass ENS {\n    constructor(signer, ens, resolver, reverseRegistrar) {\n        this.registrars = {};\n        this.signer = signer;\n        this.ens = ens;\n        this.resolver = resolver;\n        this.reverseRegistrar = reverseRegistrar;\n    }\n    async createTopLevelDomain(domain) {\n        const node = namehash(domain);\n        this.registrars = {\n            ...this.registrars,\n            [domain]: await utils_1.deployContract(this.signer, ens_1.FIFSRegistrar, [this.ens.address, node])\n        };\n        await this.ens.setSubnodeOwner(HashZero, ethers_1.utils.id(domain), this.registrars[domain].address);\n    }\n    async createSubDomainNonRecursive(domain) {\n        const { label, node, decodedRootNode } = utils_1.getDomainInfo(domain);\n        await this.registrars[decodedRootNode].register(label, await this.signer.getAddress());\n        await this.ens.setResolver(node, this.resolver.address);\n        const registrar = await utils_1.deployContract(this.signer, ens_1.FIFSRegistrar, [this.ens.address, node]);\n        await this.ens.setOwner(node, registrar.address);\n        this.registrars = {\n            ...this.registrars,\n            [domain]: registrar\n        };\n    }\n    async createDomain(domain, options) {\n        try {\n            utils_1.getDomainInfo(domain);\n            await this.createSubDomain(domain, options);\n        }\n        catch (err) {\n            if (err instanceof errors_1.ExpectedTopLevelDomain) {\n                await this.createTopLevelDomain(domain);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async ensureDomainExist(domain, options) {\n        const recursive = (options === null || options === void 0 ? void 0 : options.recursive) || false;\n        if (!this.registrars[domain]) {\n            if (recursive) {\n                await this.createDomain(domain, options);\n            }\n            else {\n                throw new errors_1.MissingDomain(domain);\n            }\n        }\n    }\n    async createSubDomain(domain, options) {\n        const { decodedRootNode } = utils_1.getDomainInfo(domain);\n        await this.ensureDomainExist(decodedRootNode, options);\n        await this.createSubDomainNonRecursive(domain);\n    }\n    async setAddressNonRecursive(domain, address) {\n        const { node, label, decodedRootNode } = utils_1.getDomainInfo(domain);\n        const registrar = this.registrars[decodedRootNode];\n        await registrar.register(label, await this.signer.getAddress());\n        await this.ens.setResolver(node, this.resolver.address);\n        await this.resolver['setAddr(bytes32,uint256,bytes)'](node, utils_1.COIN_TYPE_ETH, address);\n    }\n    async setAddress(domain, address, options) {\n        const { decodedRootNode } = utils_1.getDomainInfo(domain);\n        await this.ensureDomainExist(decodedRootNode, options);\n        await this.setAddressNonRecursive(domain, address);\n    }\n    async setAddressWithReverse(domain, signer, options) {\n        await this.setAddress(domain, await signer.getAddress(), options);\n        await this.reverseRegistrar.connect(signer).setName(domain);\n    }\n}\nexports.ENS = ENS;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,GAAR,GAAcF,OAAO,CAACG,SAAR,GAAoBH,OAAO,CAACI,sBAAR,GAAiCJ,OAAO,CAACK,cAAR,GAAyB,KAAK,CAAjG;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAArB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,sBAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAM;EAAEK;AAAF,IAAeH,QAAQ,CAACI,KAA9B;AACA,MAAM;EAAEC;AAAF,IAAeL,QAAQ,CAACM,SAA9B;;AACA,eAAeV,cAAf,CAA8BW,MAA9B,EAAsCC,GAAtC,EAA2C;EACvC,MAAMC,QAAQ,GAAG,MAAMR,OAAO,CAACS,cAAR,CAAuBH,MAAvB,EAA+BR,UAAU,CAACY,cAA1C,EAA0D,CAACH,GAAG,CAACI,OAAL,CAA1D,CAAvB;EACA,MAAMC,YAAY,GAAGV,QAAQ,CAAC,UAAD,CAA7B;EACA,MAAMW,aAAa,GAAGd,QAAQ,CAACI,KAAT,CAAeW,EAAf,CAAkB,UAAlB,CAAtB;EACA,MAAMP,GAAG,CAACQ,eAAJ,CAAoBX,QAApB,EAA8BS,aAA9B,EAA6C,MAAMP,MAAM,CAACU,UAAP,EAAnD,CAAN;EACA,MAAMT,GAAG,CAACU,WAAJ,CAAgBL,YAAhB,EAA8BJ,QAAQ,CAACG,OAAvC,CAAN;EACA,MAAMH,QAAQ,CAAC,gCAAD,CAAR,CAA2CI,YAA3C,EAAyDZ,OAAO,CAACkB,aAAjE,EAAgFV,QAAQ,CAACG,OAAzF,CAAN;EACA,OAAOH,QAAP;AACH;;AACDlB,OAAO,CAACK,cAAR,GAAyBA,cAAzB;;AACA,eAAeD,sBAAf,CAAsCY,MAAtC,EAA8CC,GAA9C,EAAmDC,QAAnD,EAA6D;EACzD,MAAMW,gBAAgB,GAAG,MAAMnB,OAAO,CAACS,cAAR,CAAuBH,MAAvB,EAA+BV,KAAK,CAACwB,gBAArC,EAAuD,CAACb,GAAG,CAACI,OAAL,EAAcH,QAAQ,CAACG,OAAvB,CAAvD,CAA/B;EACA,MAAMJ,GAAG,CAACQ,eAAJ,CAAoBX,QAApB,EAA8BL,QAAQ,CAACI,KAAT,CAAeW,EAAf,CAAkB,SAAlB,CAA9B,EAA4D,MAAMR,MAAM,CAACU,UAAP,EAAlE,CAAN;EACA,MAAMT,GAAG,CAACQ,eAAJ,CAAoBb,QAAQ,CAAC,SAAD,CAA5B,EAAyCH,QAAQ,CAACI,KAAT,CAAeW,EAAf,CAAkB,MAAlB,CAAzC,EAAoEK,gBAAgB,CAACR,OAArF,CAAN;EACA,OAAOQ,gBAAP;AACH;;AACD7B,OAAO,CAACI,sBAAR,GAAiCA,sBAAjC;;AACA,eAAeD,SAAf,CAAyBa,MAAzB,EAAiC;EAC7B,MAAMC,GAAG,GAAG,MAAMP,OAAO,CAACS,cAAR,CAAuBH,MAAvB,EAA+BV,KAAK,CAACyB,WAArC,EAAkD,EAAlD,CAAlB;EACA,MAAMb,QAAQ,GAAG,MAAMb,cAAc,CAACW,MAAD,EAASC,GAAT,CAArC;EACA,MAAMY,gBAAgB,GAAG,MAAMzB,sBAAsB,CAACY,MAAD,EAASC,GAAT,EAAcC,QAAd,CAArD;EACA,OAAO,IAAIhB,GAAJ,CAAQc,MAAR,EAAgBC,GAAhB,EAAqBC,QAArB,EAA+BW,gBAA/B,CAAP;AACH;;AACD7B,OAAO,CAACG,SAAR,GAAoBA,SAApB;;AACA,MAAMD,GAAN,CAAU;EACN8B,WAAW,CAAChB,MAAD,EAASC,GAAT,EAAcC,QAAd,EAAwBW,gBAAxB,EAA0C;IACjD,KAAKI,UAAL,GAAkB,EAAlB;IACA,KAAKjB,MAAL,GAAcA,MAAd;IACA,KAAKC,GAAL,GAAWA,GAAX;IACA,KAAKC,QAAL,GAAgBA,QAAhB;IACA,KAAKW,gBAAL,GAAwBA,gBAAxB;EACH;;EACyB,MAApBK,oBAAoB,CAACC,MAAD,EAAS;IAC/B,MAAMC,IAAI,GAAGxB,QAAQ,CAACuB,MAAD,CAArB;IACA,KAAKF,UAAL,GAAkB,EACd,GAAG,KAAKA,UADM;MAEd,CAACE,MAAD,GAAU,MAAMzB,OAAO,CAACS,cAAR,CAAuB,KAAKH,MAA5B,EAAoCV,KAAK,CAAC+B,aAA1C,EAAyD,CAAC,KAAKpB,GAAL,CAASI,OAAV,EAAmBe,IAAnB,CAAzD;IAFF,CAAlB;IAIA,MAAM,KAAKnB,GAAL,CAASQ,eAAT,CAAyBX,QAAzB,EAAmCL,QAAQ,CAACI,KAAT,CAAeW,EAAf,CAAkBW,MAAlB,CAAnC,EAA8D,KAAKF,UAAL,CAAgBE,MAAhB,EAAwBd,OAAtF,CAAN;EACH;;EACgC,MAA3BiB,2BAA2B,CAACH,MAAD,EAAS;IACtC,MAAM;MAAEI,KAAF;MAASH,IAAT;MAAeI;IAAf,IAAmC9B,OAAO,CAAC+B,aAAR,CAAsBN,MAAtB,CAAzC;IACA,MAAM,KAAKF,UAAL,CAAgBO,eAAhB,EAAiCE,QAAjC,CAA0CH,KAA1C,EAAiD,MAAM,KAAKvB,MAAL,CAAYU,UAAZ,EAAvD,CAAN;IACA,MAAM,KAAKT,GAAL,CAASU,WAAT,CAAqBS,IAArB,EAA2B,KAAKlB,QAAL,CAAcG,OAAzC,CAAN;IACA,MAAMsB,SAAS,GAAG,MAAMjC,OAAO,CAACS,cAAR,CAAuB,KAAKH,MAA5B,EAAoCV,KAAK,CAAC+B,aAA1C,EAAyD,CAAC,KAAKpB,GAAL,CAASI,OAAV,EAAmBe,IAAnB,CAAzD,CAAxB;IACA,MAAM,KAAKnB,GAAL,CAAS2B,QAAT,CAAkBR,IAAlB,EAAwBO,SAAS,CAACtB,OAAlC,CAAN;IACA,KAAKY,UAAL,GAAkB,EACd,GAAG,KAAKA,UADM;MAEd,CAACE,MAAD,GAAUQ;IAFI,CAAlB;EAIH;;EACiB,MAAZE,YAAY,CAACV,MAAD,EAASW,OAAT,EAAkB;IAChC,IAAI;MACApC,OAAO,CAAC+B,aAAR,CAAsBN,MAAtB;MACA,MAAM,KAAKY,eAAL,CAAqBZ,MAArB,EAA6BW,OAA7B,CAAN;IACH,CAHD,CAIA,OAAOE,GAAP,EAAY;MACR,IAAIA,GAAG,YAAYrC,QAAQ,CAACsC,sBAA5B,EAAoD;QAChD,MAAM,KAAKf,oBAAL,CAA0BC,MAA1B,CAAN;MACH,CAFD,MAGK;QACD,MAAMa,GAAN;MACH;IACJ;EACJ;;EACsB,MAAjBE,iBAAiB,CAACf,MAAD,EAASW,OAAT,EAAkB;IACrC,MAAMK,SAAS,GAAG,CAACL,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACK,SAA3D,KAAyE,KAA3F;;IACA,IAAI,CAAC,KAAKlB,UAAL,CAAgBE,MAAhB,CAAL,EAA8B;MAC1B,IAAIgB,SAAJ,EAAe;QACX,MAAM,KAAKN,YAAL,CAAkBV,MAAlB,EAA0BW,OAA1B,CAAN;MACH,CAFD,MAGK;QACD,MAAM,IAAInC,QAAQ,CAACyC,aAAb,CAA2BjB,MAA3B,CAAN;MACH;IACJ;EACJ;;EACoB,MAAfY,eAAe,CAACZ,MAAD,EAASW,OAAT,EAAkB;IACnC,MAAM;MAAEN;IAAF,IAAsB9B,OAAO,CAAC+B,aAAR,CAAsBN,MAAtB,CAA5B;IACA,MAAM,KAAKe,iBAAL,CAAuBV,eAAvB,EAAwCM,OAAxC,CAAN;IACA,MAAM,KAAKR,2BAAL,CAAiCH,MAAjC,CAAN;EACH;;EAC2B,MAAtBkB,sBAAsB,CAAClB,MAAD,EAASd,OAAT,EAAkB;IAC1C,MAAM;MAAEe,IAAF;MAAQG,KAAR;MAAeC;IAAf,IAAmC9B,OAAO,CAAC+B,aAAR,CAAsBN,MAAtB,CAAzC;IACA,MAAMQ,SAAS,GAAG,KAAKV,UAAL,CAAgBO,eAAhB,CAAlB;IACA,MAAMG,SAAS,CAACD,QAAV,CAAmBH,KAAnB,EAA0B,MAAM,KAAKvB,MAAL,CAAYU,UAAZ,EAAhC,CAAN;IACA,MAAM,KAAKT,GAAL,CAASU,WAAT,CAAqBS,IAArB,EAA2B,KAAKlB,QAAL,CAAcG,OAAzC,CAAN;IACA,MAAM,KAAKH,QAAL,CAAc,gCAAd,EAAgDkB,IAAhD,EAAsD1B,OAAO,CAACkB,aAA9D,EAA6EP,OAA7E,CAAN;EACH;;EACe,MAAViC,UAAU,CAACnB,MAAD,EAASd,OAAT,EAAkByB,OAAlB,EAA2B;IACvC,MAAM;MAAEN;IAAF,IAAsB9B,OAAO,CAAC+B,aAAR,CAAsBN,MAAtB,CAA5B;IACA,MAAM,KAAKe,iBAAL,CAAuBV,eAAvB,EAAwCM,OAAxC,CAAN;IACA,MAAM,KAAKO,sBAAL,CAA4BlB,MAA5B,EAAoCd,OAApC,CAAN;EACH;;EAC0B,MAArBkC,qBAAqB,CAACpB,MAAD,EAASnB,MAAT,EAAiB8B,OAAjB,EAA0B;IACjD,MAAM,KAAKQ,UAAL,CAAgBnB,MAAhB,EAAwB,MAAMnB,MAAM,CAACU,UAAP,EAA9B,EAAmDoB,OAAnD,CAAN;IACA,MAAM,KAAKjB,gBAAL,CAAsB2B,OAAtB,CAA8BxC,MAA9B,EAAsCyC,OAAtC,CAA8CtB,MAA9C,CAAN;EACH;;AAxEK;;AA0EVnC,OAAO,CAACE,GAAR,GAAcA,GAAd"},"metadata":{},"sourceType":"script"}